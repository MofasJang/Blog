<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一句</title>
    <url>/posts/daily/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <!-- ### <script type="text/javascript" src="https://api.uixsj.cn/hitokoto/w.php?code=js"></script><div id="xsjhitokoto"><script>xsjhitokoto()</script></div> -->
<h1 id="正在加载今日诗词…"><a href="#正在加载今日诗词…" class="headerlink" title="正在加载今日诗词…."></a><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script><span id="jinrishici-sentence">正在加载今日诗词….</span></h1>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p><iframe scrolling="no" src="https://tianqiapi.com/api.php?style=tz&skin=gif" frameborder="0" width="100%" height="30" allowtransparency="true"></iframe></p>
<h2 id><a href="#" class="headerlink" title></a><a id="more"></a></h2><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="最长的弯路也是最近的归途。"><a href="#最长的弯路也是最近的归途。" class="headerlink" title="最长的弯路也是最近的归途。"></a>最长的弯路也是最近的归途。</h3><h2 id="———C·S·路易斯"><a href="#———C·S·路易斯" class="headerlink" title="———C·S·路易斯"></a>———C·S·路易斯</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.11.5</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="我点燃了火，"><a href="#我点燃了火，" class="headerlink" title="我点燃了火，"></a>我点燃了火，</h3><h3 id="却控制不了它。"><a href="#却控制不了它。" class="headerlink" title="却控制不了它。"></a>却控制不了它。</h3><h2 id="———三体"><a href="#———三体" class="headerlink" title="———三体"></a>———三体</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.11.4</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="在没有危险的地方，"><a href="#在没有危险的地方，" class="headerlink" title="在没有危险的地方，"></a>在没有危险的地方，</h3><h3 id="那里爱情拥有双眼，"><a href="#那里爱情拥有双眼，" class="headerlink" title="那里爱情拥有双眼，"></a>那里爱情拥有双眼，</h3><h3 id="不会盲目。"><a href="#不会盲目。" class="headerlink" title="不会盲目。"></a>不会盲目。</h3><h2 id="———戴米恩·莱斯"><a href="#———戴米恩·莱斯" class="headerlink" title="———戴米恩·莱斯"></a>———戴米恩·莱斯</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.11.3</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="无论我们处在怎样的年纪，"><a href="#无论我们处在怎样的年纪，" class="headerlink" title="无论我们处在怎样的年纪，"></a>无论我们处在怎样的年纪，</h3><h3 id="只要能看到未来，"><a href="#只要能看到未来，" class="headerlink" title="只要能看到未来，"></a>只要能看到未来，</h3><h3 id="就能获得青春。"><a href="#就能获得青春。" class="headerlink" title="就能获得青春。"></a>就能获得青春。</h3><h2 id="————保罗·索伦蒂诺"><a href="#————保罗·索伦蒂诺" class="headerlink" title="————保罗·索伦蒂诺"></a>————保罗·索伦蒂诺</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.11.2</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="她今夜出去只喝香槟，"><a href="#她今夜出去只喝香槟，" class="headerlink" title="她今夜出去只喝香槟，"></a>她今夜出去只喝香槟，</h3><h3 id="她几乎打量了所有男人，"><a href="#她几乎打量了所有男人，" class="headerlink" title="她几乎打量了所有男人，"></a>她几乎打量了所有男人，</h3><h3 id="她在玩她的游戏，"><a href="#她在玩她的游戏，" class="headerlink" title="她在玩她的游戏，"></a>她在玩她的游戏，</h3><h3 id="你可以听到他们说，"><a href="#你可以听到他们说，" class="headerlink" title="你可以听到他们说，"></a>你可以听到他们说，</h3><h3 id="她很漂亮，"><a href="#她很漂亮，" class="headerlink" title="她很漂亮，"></a>她很漂亮，</h3><h3 id="我们要为她的美貌付钱。"><a href="#我们要为她的美貌付钱。" class="headerlink" title="我们要为她的美貌付钱。"></a>我们要为她的美貌付钱。</h3><h2 id="————发电站"><a href="#————发电站" class="headerlink" title="————发电站"></a>————发电站</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.11.1</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="人生若只如初见，"><a href="#人生若只如初见，" class="headerlink" title="人生若只如初见，"></a>人生若只如初见，</h3><h3 id="何事秋风悲画扇。"><a href="#何事秋风悲画扇。" class="headerlink" title="何事秋风悲画扇。"></a>何事秋风悲画扇。</h3><h2 id="————木兰花·拟古决绝词柬友"><a href="#————木兰花·拟古决绝词柬友" class="headerlink" title="————木兰花·拟古决绝词柬友"></a>————木兰花·拟古决绝词柬友</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.31</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="我并不是一味喜欢老旧的东西，"><a href="#我并不是一味喜欢老旧的东西，" class="headerlink" title="我并不是一味喜欢老旧的东西，"></a>我并不是一味喜欢老旧的东西，</h3><h3 id="我喜欢的，是建立在经典不变的基础上，"><a href="#我喜欢的，是建立在经典不变的基础上，" class="headerlink" title="我喜欢的，是建立在经典不变的基础上，"></a>我喜欢的，是建立在经典不变的基础上，</h3><h3 id="再融入新的东西。"><a href="#再融入新的东西。" class="headerlink" title="再融入新的东西。"></a>再融入新的东西。</h3><h3 id="我觉得有品味的人，"><a href="#我觉得有品味的人，" class="headerlink" title="我觉得有品味的人，"></a>我觉得有品味的人，</h3><h3 id="能够把这些常规的永远不变的东西和新的东西很好地融合在一起。"><a href="#能够把这些常规的永远不变的东西和新的东西很好地融合在一起。" class="headerlink" title="能够把这些常规的永远不变的东西和新的东西很好地融合在一起。"></a>能够把这些常规的永远不变的东西和新的东西很好地融合在一起。</h3><h2 id="————长冈贤明"><a href="#————长冈贤明" class="headerlink" title="————长冈贤明"></a>————长冈贤明</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.30</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="人闲桂花落，"><a href="#人闲桂花落，" class="headerlink" title="人闲桂花落，"></a>人闲桂花落，</h3><h3 id="夜静春山空。"><a href="#夜静春山空。" class="headerlink" title="夜静春山空。"></a>夜静春山空。</h3><h2 id="————鸟鸣涧"><a href="#————鸟鸣涧" class="headerlink" title="————鸟鸣涧"></a>————鸟鸣涧</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.29</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="他们太过于个人化，"><a href="#他们太过于个人化，" class="headerlink" title="他们太过于个人化，"></a>他们太过于个人化，</h3><h3 id="太过于阳春白雪……"><a href="#太过于阳春白雪……" class="headerlink" title="太过于阳春白雪……"></a>太过于阳春白雪……</h3><h3 id="今后应该比我迄今为止所做的更加尊重观众。"><a href="#今后应该比我迄今为止所做的更加尊重观众。" class="headerlink" title="今后应该比我迄今为止所做的更加尊重观众。"></a>今后应该比我迄今为止所做的更加尊重观众。</h3><h2 id="————赖纳·维尔纳·法斯宾德"><a href="#————赖纳·维尔纳·法斯宾德" class="headerlink" title="————赖纳·维尔纳·法斯宾德"></a>————赖纳·维尔纳·法斯宾德</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.28</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="这世界开始时没有人，"><a href="#这世界开始时没有人，" class="headerlink" title="这世界开始时没有人，"></a>这世界开始时没有人，</h3><h3 id="当它终结时还是没有人。"><a href="#当它终结时还是没有人。" class="headerlink" title="当它终结时还是没有人。"></a>当它终结时还是没有人。</h3><h2 id="————克洛德·列维·斯特劳斯"><a href="#————克洛德·列维·斯特劳斯" class="headerlink" title="————克洛德·列维·斯特劳斯"></a>————克洛德·列维·斯特劳斯</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.27</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="昔日我曾如此苍老，"><a href="#昔日我曾如此苍老，" class="headerlink" title="昔日我曾如此苍老，"></a>昔日我曾如此苍老，</h3><h3 id="如今才是风华正茂。"><a href="#如今才是风华正茂。" class="headerlink" title="如今才是风华正茂。"></a>如今才是风华正茂。</h3><h2 id="————鲍勃·迪伦"><a href="#————鲍勃·迪伦" class="headerlink" title="————鲍勃·迪伦"></a>————鲍勃·迪伦</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.26</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="一别都门三改火，"><a href="#一别都门三改火，" class="headerlink" title="一别都门三改火，"></a>一别都门三改火，</h3><h3 id="天涯踏尽红尘。"><a href="#天涯踏尽红尘。" class="headerlink" title="天涯踏尽红尘。"></a>天涯踏尽红尘。</h3><h2 id="————临江仙·送钱穆父"><a href="#————临江仙·送钱穆父" class="headerlink" title="————临江仙·送钱穆父"></a>————临江仙·送钱穆父</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.25</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="醉后不知天在水，"><a href="#醉后不知天在水，" class="headerlink" title="醉后不知天在水，"></a>醉后不知天在水，</h3><h3 id="满船清梦压星河。"><a href="#满船清梦压星河。" class="headerlink" title="满船清梦压星河。"></a>满船清梦压星河。</h3><h2 id="————题龙阳县青草湖"><a href="#————题龙阳县青草湖" class="headerlink" title="————题龙阳县青草湖"></a>————题龙阳县青草湖</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.24</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="事实上，"><a href="#事实上，" class="headerlink" title="事实上，"></a>事实上，</h3><h3 id="忧郁的人会成为最大的瘾君子，"><a href="#忧郁的人会成为最大的瘾君子，" class="headerlink" title="忧郁的人会成为最大的瘾君子，"></a>忧郁的人会成为最大的瘾君子，</h3><h3 id="因为真正上了瘾的体验总是一种孤独的体验。"><a href="#因为真正上了瘾的体验总是一种孤独的体验。" class="headerlink" title="因为真正上了瘾的体验总是一种孤独的体验。"></a>因为真正上了瘾的体验总是一种孤独的体验。</h3><h2 id="————苏珊·桑塔格"><a href="#————苏珊·桑塔格" class="headerlink" title="————苏珊·桑塔格"></a>————苏珊·桑塔格</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.23</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="天下熙熙，"><a href="#天下熙熙，" class="headerlink" title="天下熙熙，"></a>天下熙熙，</h3><h3 id="皆为利来；"><a href="#皆为利来；" class="headerlink" title="皆为利来；"></a>皆为利来；</h3><h3 id="天下攘攘，"><a href="#天下攘攘，" class="headerlink" title="天下攘攘，"></a>天下攘攘，</h3><h3 id="皆为利往。"><a href="#皆为利往。" class="headerlink" title="皆为利往。"></a>皆为利往。</h3><h2 id="————史记·货殖列传"><a href="#————史记·货殖列传" class="headerlink" title="————史记·货殖列传"></a>————史记·货殖列传</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.22  </p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="我的风格就是我唯一能做的好事，"><a href="#我的风格就是我唯一能做的好事，" class="headerlink" title="我的风格就是我唯一能做的好事，"></a>我的风格就是我唯一能做的好事，</h3><h3 id="我不考虑流派，"><a href="#我不考虑流派，" class="headerlink" title="我不考虑流派，"></a>我不考虑流派，</h3><h3 id="我不考虑标签，"><a href="#我不考虑标签，" class="headerlink" title="我不考虑标签，"></a>我不考虑标签，</h3><h3 id="它们没有什么意义"><a href="#它们没有什么意义" class="headerlink" title="它们没有什么意义"></a>它们没有什么意义</h3><h2 id="————穆玄英挂帅"><a href="#————穆玄英挂帅" class="headerlink" title="————穆玄英挂帅"></a>————穆玄英挂帅</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.21  </p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="世间情动，"><a href="#世间情动，" class="headerlink" title="世间情动，"></a>世间情动，</h3><h3 id="不过盛夏白瓷梅子汤，"><a href="#不过盛夏白瓷梅子汤，" class="headerlink" title="不过盛夏白瓷梅子汤，"></a>不过盛夏白瓷梅子汤，</h3><h3 id="碎冰碰壁当啷响。"><a href="#碎冰碰壁当啷响。" class="headerlink" title="碎冰碰壁当啷响。"></a>碎冰碰壁当啷响。</h3><h2 id="————穆玄英挂帅"><a href="#————穆玄英挂帅" class="headerlink" title="————穆玄英挂帅"></a>————穆玄英挂帅</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.20  </p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="我不喜欢“惊人”这个词，"><a href="#我不喜欢“惊人”这个词，" class="headerlink" title="我不喜欢“惊人”这个词，"></a>我不喜欢“惊人”这个词，</h3><h3 id="我在寻找意想不到的东西。"><a href="#我在寻找意想不到的东西。" class="headerlink" title="我在寻找意想不到的东西。"></a>我在寻找意想不到的东西。</h3><h3 id="寻找那些我从来没见过的东西……"><a href="#寻找那些我从来没见过的东西……" class="headerlink" title="寻找那些我从来没见过的东西……"></a>寻找那些我从来没见过的东西……</h3><h3 id="我在拍这些照片，"><a href="#我在拍这些照片，" class="headerlink" title="我在拍这些照片，"></a>我在拍这些照片，</h3><h3 id="我觉得义不容辞。"><a href="#我觉得义不容辞。" class="headerlink" title="我觉得义不容辞。"></a>我觉得义不容辞。</h3><h2 id="————罗伯特·梅普尔索普"><a href="#————罗伯特·梅普尔索普" class="headerlink" title="————罗伯特·梅普尔索普"></a>————罗伯特·梅普尔索普</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.19</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="我的关注永远不是艺术，"><a href="#我的关注永远不是艺术，" class="headerlink" title="我的关注永远不是艺术，"></a>我的关注永远不是艺术，</h3><h3 id="但总是可以使用什么艺术。"><a href="#但总是可以使用什么艺术。" class="headerlink" title="但总是可以使用什么艺术。"></a>但总是可以使用什么艺术。</h3><h2 id="————格哈德·里希特"><a href="#————格哈德·里希特" class="headerlink" title="————格哈德·里希特"></a>————格哈德·里希特</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.18</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="人们理解杜尚花了100年时间，"><a href="#人们理解杜尚花了100年时间，" class="headerlink" title="人们理解杜尚花了100年时间，"></a>人们理解杜尚花了100年时间，</h3><h3 id="理解我估计要更久一点。"><a href="#理解我估计要更久一点。" class="headerlink" title="理解我估计要更久一点。"></a>理解我估计要更久一点。</h3><h2 id="————白南准"><a href="#————白南准" class="headerlink" title="————白南准"></a>————白南准</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.17</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="我肯定，"><a href="#我肯定，" class="headerlink" title="我肯定，"></a>我肯定，</h3><h3 id="在空无的中心，"><a href="#在空无的中心，" class="headerlink" title="在空无的中心，"></a>在空无的中心，</h3><h3 id="如同在人的心脏"><a href="#如同在人的心脏" class="headerlink" title="如同在人的心脏,"></a>如同在人的心脏,</h3><h3 id="有火在燃烧。"><a href="#有火在燃烧。" class="headerlink" title="有火在燃烧。"></a>有火在燃烧。</h3><h2 id="————伊夫·克莱因"><a href="#————伊夫·克莱因" class="headerlink" title="————伊夫·克莱因"></a>————伊夫·克莱因</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.16</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="随着年龄的增长，"><a href="#随着年龄的增长，" class="headerlink" title="随着年龄的增长，"></a>随着年龄的增长，</h3><h3 id="我想起了我们古老的文字、遗产和价值观。"><a href="#我想起了我们古老的文字、遗产和价值观。" class="headerlink" title="我想起了我们古老的文字、遗产和价值观。"></a>我想起了我们古老的文字、遗产和价值观。</h3><h3 id="它们中的任何一个都代表着一种完整的理解"><a href="#它们中的任何一个都代表着一种完整的理解" class="headerlink" title="它们中的任何一个都代表着一种完整的理解,"></a>它们中的任何一个都代表着一种完整的理解,</h3><h3 id="即唯一确定的是不确定。"><a href="#即唯一确定的是不确定。" class="headerlink" title="即唯一确定的是不确定。"></a>即唯一确定的是不确定。</h3><h2 id="————巴克里希纳·多西"><a href="#————巴克里希纳·多西" class="headerlink" title="————巴克里希纳·多西"></a>————巴克里希纳·多西</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.15</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="我们哭着降临世界，"><a href="#我们哭着降临世界，" class="headerlink" title="我们哭着降临世界，"></a>我们哭着降临世界，</h3><h3 id="却可以笑着走向永恒。"><a href="#却可以笑着走向永恒。" class="headerlink" title="却可以笑着走向永恒。"></a>却可以笑着走向永恒。</h3><h2 id="————如果国宝会说话"><a href="#————如果国宝会说话" class="headerlink" title="————如果国宝会说话"></a>————如果国宝会说话</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.14</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="他们说我是这镇子上的万人迷。"><a href="#他们说我是这镇子上的万人迷。" class="headerlink" title="他们说我是这镇子上的万人迷。"></a>他们说我是这镇子上的万人迷。</h3><h2 id="————弗兰克·扎帕"><a href="#————弗兰克·扎帕" class="headerlink" title="————弗兰克·扎帕"></a>————弗兰克·扎帕</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.13</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="风乍起。"><a href="#风乍起。" class="headerlink" title="风乍起。"></a>风乍起。</h3><h3 id="合当奋意向人生。"><a href="#合当奋意向人生。" class="headerlink" title="合当奋意向人生。"></a>合当奋意向人生。</h3><h2 id="————堀辰雄"><a href="#————堀辰雄" class="headerlink" title="————堀辰雄"></a>————堀辰雄</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.12</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="我的作品就是我的肉体和灵魂，"><a href="#我的作品就是我的肉体和灵魂，" class="headerlink" title="我的作品就是我的肉体和灵魂，"></a>我的作品就是我的肉体和灵魂，</h3><h3 id="为了它我甘愿冒失去生命和理智的危险。"><a href="#为了它我甘愿冒失去生命和理智的危险。" class="headerlink" title="为了它我甘愿冒失去生命和理智的危险。"></a>为了它我甘愿冒失去生命和理智的危险。</h3><h2 id="————文森特·威廉·梵·高"><a href="#————文森特·威廉·梵·高" class="headerlink" title="————文森特·威廉·梵·高"></a>————文森特·威廉·梵·高</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.11</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="抱歉，似乎是最难以启齿的话。"><a href="#抱歉，似乎是最难以启齿的话。" class="headerlink" title="抱歉，似乎是最难以启齿的话。"></a>抱歉，似乎是最难以启齿的话。</h3><h2 id="————雷·查尔斯"><a href="#————雷·查尔斯" class="headerlink" title="————雷·查尔斯"></a>————雷·查尔斯</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.10</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="历史学的目标并不是由过去视角出发展望未来。"><a href="#历史学的目标并不是由过去视角出发展望未来。" class="headerlink" title="历史学的目标并不是由过去视角出发展望未来。"></a>历史学的目标并不是由过去视角出发展望未来。</h3><h2 id="————埃里克·霍布斯鲍姆"><a href="#————埃里克·霍布斯鲍姆" class="headerlink" title="————埃里克·霍布斯鲍姆"></a>————埃里克·霍布斯鲍姆</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.9</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="和魔鬼共舞时，"><a href="#和魔鬼共舞时，" class="headerlink" title="和魔鬼共舞时，"></a>和魔鬼共舞时，</h3><h3 id="只能等着音乐结束。"><a href="#只能等着音乐结束。" class="headerlink" title="只能等着音乐结束。"></a>只能等着音乐结束。</h3><h2 id="————盖·里奇"><a href="#————盖·里奇" class="headerlink" title="————盖·里奇"></a>————盖·里奇</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.8</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="你了解星空下万物温馨的生长吗，"><a href="#你了解星空下万物温馨的生长吗，" class="headerlink" title="你了解星空下万物温馨的生长吗，"></a>你了解星空下万物温馨的生长吗，</h3><h3 id="你了解我们的存在吗，"><a href="#你了解我们的存在吗，" class="headerlink" title="你了解我们的存在吗，"></a>你了解我们的存在吗，</h3><h3 id="你已经遗失开启王国的钥匙了吗，"><a href="#你已经遗失开启王国的钥匙了吗，" class="headerlink" title="你已经遗失开启王国的钥匙了吗，"></a>你已经遗失开启王国的钥匙了吗，</h3><h3 id="你在轮回中反复降生一直活着吗，"><a href="#你在轮回中反复降生一直活着吗，" class="headerlink" title="你在轮回中反复降生一直活着吗，"></a>你在轮回中反复降生一直活着吗，</h3><h3 id="让我们彻底改造诸神，"><a href="#让我们彻底改造诸神，" class="headerlink" title="让我们彻底改造诸神，"></a>让我们彻底改造诸神，</h3><h3 id="包括各个时代的神话。"><a href="#包括各个时代的神话。" class="headerlink" title="包括各个时代的神话。"></a>包括各个时代的神话。</h3><h2 id="————吉姆·莫里森"><a href="#————吉姆·莫里森" class="headerlink" title="————吉姆·莫里森"></a>————吉姆·莫里森</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.10.7</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="声音在太空中消逝，"><a href="#声音在太空中消逝，" class="headerlink" title="声音在太空中消逝，"></a>声音在太空中消逝，</h3><h3 id="霞光变得昏暗。"><a href="#霞光变得昏暗。" class="headerlink" title="霞光变得昏暗。"></a>霞光变得昏暗。</h3><h3 id="永远沉默的世界里，"><a href="#永远沉默的世界里，" class="headerlink" title="永远沉默的世界里，"></a>永远沉默的世界里，</h3><h3 id="只有你和我交谈。"><a href="#只有你和我交谈。" class="headerlink" title="只有你和我交谈。"></a>只有你和我交谈。</h3><h2 id="————阿赫马托娃"><a href="#————阿赫马托娃" class="headerlink" title="————阿赫马托娃"></a>————阿赫马托娃</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.9.28</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="这几张脸在人群中幻境般闪现，"><a href="#这几张脸在人群中幻境般闪现，" class="headerlink" title="这几张脸在人群中幻境般闪现，"></a>这几张脸在人群中幻境般闪现，</h3><h3 id="湿漉漉的黑树枝上花瓣数点。"><a href="#湿漉漉的黑树枝上花瓣数点。" class="headerlink" title="湿漉漉的黑树枝上花瓣数点。"></a>湿漉漉的黑树枝上花瓣数点。</h3><h2 id="————埃兹拉·庞德"><a href="#————埃兹拉·庞德" class="headerlink" title="————埃兹拉·庞德"></a>————埃兹拉·庞德</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.9.27</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="热水澡肯定不能包治百病，"><a href="#热水澡肯定不能包治百病，" class="headerlink" title="热水澡肯定不能包治百病，"></a>热水澡肯定不能包治百病，</h3><h3 id="但我想例外也不会太多。"><a href="#但我想例外也不会太多。" class="headerlink" title="但我想例外也不会太多。"></a>但我想例外也不会太多。</h3><h3 id="每当我悲痛欲绝，"><a href="#每当我悲痛欲绝，" class="headerlink" title="每当我悲痛欲绝，"></a>每当我悲痛欲绝，</h3><h3 id="或者神经紧张、夜不成寐，"><a href="#或者神经紧张、夜不成寐，" class="headerlink" title="或者神经紧张、夜不成寐，"></a>或者神经紧张、夜不成寐，</h3><h3 id="意志消沉、萎靡不振，"><a href="#意志消沉、萎靡不振，" class="headerlink" title="意志消沉、萎靡不振，"></a>意志消沉、萎靡不振，</h3><h3 id="这时我就会对自己说："><a href="#这时我就会对自己说：" class="headerlink" title="这时我就会对自己说："></a>这时我就会对自己说：</h3><h3 id="洗个热水澡吧。"><a href="#洗个热水澡吧。" class="headerlink" title="洗个热水澡吧。"></a>洗个热水澡吧。</h3><h2 id="————西尔维娅·普拉斯"><a href="#————西尔维娅·普拉斯" class="headerlink" title="————西尔维娅·普拉斯"></a>————西尔维娅·普拉斯</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.9.26</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="当我回顾人类的历史，"><a href="#当我回顾人类的历史，" class="headerlink" title="当我回顾人类的历史，"></a>当我回顾人类的历史，</h3><h3 id="有时我觉得是一出喜剧，"><a href="#有时我觉得是一出喜剧，" class="headerlink" title="有时我觉得是一出喜剧，"></a>有时我觉得是一出喜剧，</h3><h3 id="但这喜剧让我哭泣；"><a href="#但这喜剧让我哭泣；" class="headerlink" title="但这喜剧让我哭泣；"></a>但这喜剧让我哭泣；</h3><h3 id="有时又觉得它是一出悲剧，"><a href="#有时又觉得它是一出悲剧，" class="headerlink" title="有时又觉得它是一出悲剧，"></a>有时又觉得它是一出悲剧，</h3><h3 id="但这悲剧却让我微笑。"><a href="#但这悲剧却让我微笑。" class="headerlink" title="但这悲剧却让我微笑。"></a>但这悲剧却让我微笑。</h3><h2 id="————特拉斯诺霍尔卡伊·拉斯洛"><a href="#————特拉斯诺霍尔卡伊·拉斯洛" class="headerlink" title="————特拉斯诺霍尔卡伊·拉斯洛"></a>————特拉斯诺霍尔卡伊·拉斯洛</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.9.25</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="就着几盏昏红的灯下，"><a href="#就着几盏昏红的灯下，" class="headerlink" title="就着几盏昏红的灯下，"></a>就着几盏昏红的灯下，</h3><h3 id="靠在几张旧床边，"><a href="#靠在几张旧床边，" class="headerlink" title="靠在几张旧床边，"></a>靠在几张旧床边，</h3><h3 id="我们就在这儿挥洒激情的汗水，"><a href="#我们就在这儿挥洒激情的汗水，" class="headerlink" title="我们就在这儿挥洒激情的汗水，"></a>我们就在这儿挥洒激情的汗水，</h3><h3 id="无论我们能从中收获怎样的音乐，"><a href="#无论我们能从中收获怎样的音乐，" class="headerlink" title="无论我们能从中收获怎样的音乐，"></a>无论我们能从中收获怎样的音乐，</h3><h3 id="我知道我们永不会忘。"><a href="#我知道我们永不会忘。" class="headerlink" title="我知道我们永不会忘。"></a>我知道我们永不会忘。</h3><h2 id="————深紫乐队"><a href="#————深紫乐队" class="headerlink" title="————深紫乐队"></a>————深紫乐队</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.9.24</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="很多人常说我受某某的影响，"><a href="#很多人常说我受某某的影响，" class="headerlink" title="很多人常说我受某某的影响，"></a>很多人常说我受某某的影响，</h3><h3 id="其实并无关连，"><a href="#其实并无关连，" class="headerlink" title="其实并无关连，"></a>其实并无关连，</h3><h3 id="认真说来只有盗窃而已。"><a href="#认真说来只有盗窃而已。" class="headerlink" title="认真说来只有盗窃而已。"></a>认真说来只有盗窃而已。</h3><h3 id="除了盗窃以外，"><a href="#除了盗窃以外，" class="headerlink" title="除了盗窃以外，"></a>除了盗窃以外，</h3><h3 id="别无其他，"><a href="#别无其他，" class="headerlink" title="别无其他，"></a>别无其他，</h3><h3 id="只不过其他人不敢说出来。"><a href="#只不过其他人不敢说出来。" class="headerlink" title="只不过其他人不敢说出来。"></a>只不过其他人不敢说出来。</h3><h2 id="————丸尾末广"><a href="#————丸尾末广" class="headerlink" title="————丸尾末广"></a>————丸尾末广</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.9.23</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="直线属于人类，"><a href="#直线属于人类，" class="headerlink" title="直线属于人类，"></a>直线属于人类，</h3><h3 id="曲线属于上帝。"><a href="#曲线属于上帝。" class="headerlink" title="曲线属于上帝。"></a>曲线属于上帝。</h3><h2 id="————安东尼·高迪"><a href="#————安东尼·高迪" class="headerlink" title="————安东尼·高迪"></a>————安东尼·高迪</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.9.22</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="以前人们似乎总是很明确地知道，"><a href="#以前人们似乎总是很明确地知道，" class="headerlink" title="以前人们似乎总是很明确地知道，"></a>以前人们似乎总是很明确地知道，</h3><h3 id="政府或者谁哪里哪里做得不对，"><a href="#政府或者谁哪里哪里做得不对，" class="headerlink" title="政府或者谁哪里哪里做得不对，"></a>政府或者谁哪里哪里做得不对，</h3><h3 id="于是一起针对问题示威游行。"><a href="#于是一起针对问题示威游行。" class="headerlink" title="于是一起针对问题示威游行。"></a>于是一起针对问题示威游行。</h3><h3 id="但是如今，我们为何愤怒，"><a href="#但是如今，我们为何愤怒，" class="headerlink" title="但是如今，我们为何愤怒，"></a>但是如今，我们为何愤怒，</h3><h3 id="完全是个谜。"><a href="#完全是个谜。" class="headerlink" title="完全是个谜。"></a>完全是个谜。</h3><h2 id="————李沧东"><a href="#————李沧东" class="headerlink" title="————李沧东"></a>————李沧东</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.9.21</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="一个故事之所以吸引我，"><a href="#一个故事之所以吸引我，" class="headerlink" title="一个故事之所以吸引我，"></a>一个故事之所以吸引我，</h3><h3 id="是因为它本身的价值，"><a href="#是因为它本身的价值，" class="headerlink" title="是因为它本身的价值，"></a>是因为它本身的价值，</h3><h3 id="而非我可以顾影自怜。"><a href="#而非我可以顾影自怜。" class="headerlink" title="而非我可以顾影自怜。"></a>而非我可以顾影自怜。</h3><h2 id="————奥逊·威尔斯"><a href="#————奥逊·威尔斯" class="headerlink" title="————奥逊·威尔斯"></a>————奥逊·威尔斯</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.9.20</p>
<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="不要问篝火该不该燃烧，"><a href="#不要问篝火该不该燃烧，" class="headerlink" title="不要问篝火该不该燃烧，"></a>不要问篝火该不该燃烧，</h3><h3 id="先问寒冷黑暗还在不在；"><a href="#先问寒冷黑暗还在不在；" class="headerlink" title="先问寒冷黑暗还在不在；"></a>先问寒冷黑暗还在不在；</h3><h3 id="不要问子弹该不该上膛，"><a href="#不要问子弹该不该上膛，" class="headerlink" title="不要问子弹该不该上膛，"></a>不要问子弹该不该上膛，</h3><h3 id="先问压迫剥削还在不在；"><a href="#先问压迫剥削还在不在；" class="headerlink" title="先问压迫剥削还在不在；"></a>先问压迫剥削还在不在；</h3><h3 id="不要问正义事业有没有明天，"><a href="#不要问正义事业有没有明天，" class="headerlink" title="不要问正义事业有没有明天，"></a>不要问正义事业有没有明天，</h3><h3 id="先问人间不平今天还在不在。"><a href="#先问人间不平今天还在不在。" class="headerlink" title="先问人间不平今天还在不在。"></a>先问人间不平今天还在不在。</h3><h2 id="————切·格瓦拉"><a href="#————切·格瓦拉" class="headerlink" title="————切·格瓦拉"></a>————切·格瓦拉</h2>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<p>2020.9.19</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>格言</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue（1）</title>
    <url>/posts/Vue-1-create/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>b站教程视频：<a href="https://www.bilibili.com/video/BV1Zy4y1K7SH?p=138&amp;spm_id_from=pageDriver&amp;vd_source=1379429d9fdc59cc6f51bb675c08e3ba">Vue实战</a><br>学习笔记：<a href="https://www.yuque.com/cessstudy/kak11d/hfeef2">Vue学习笔记</a></p>
          </div>
<a id="more"></a>
<h1 id="构建Vue项目"><a href="#构建Vue项目" class="headerlink" title="构建Vue项目"></a>构建Vue项目</h1><h2 id="vue-cli构建"><a href="#vue-cli构建" class="headerlink" title="vue cli构建"></a>vue cli构建</h2><h3 id="全局安装-vue-cli。"><a href="#全局安装-vue-cli。" class="headerlink" title="　全局安装@vue/cli。"></a>　全局安装@vue/cli。</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure>
<h3 id="切换到你要创建项目的目录，然后使用命令创建项目"><a href="#切换到你要创建项目的目录，然后使用命令创建项目" class="headerlink" title="切换到你要创建项目的目录，然后使用命令创建项目"></a>切换到你要创建项目的目录，然后使用命令创建项目</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">vue create xxxx</span><br></pre></td></tr></table></figure>
<h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure>
<div class="note ">
            <p>如出现下载缓慢请配置 npm 淘宝镜像：<code>npm config set registryhttps://registry.npm.taobao.org</code></p>
          </div>
<h2 id="Vite构建"><a href="#Vite构建" class="headerlink" title="Vite构建"></a>Vite构建</h2><h3 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm init vite-app &lt;project name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="进入工程目录"><a href="#进入工程目录" class="headerlink" title="进入工程目录"></a>进入工程目录</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;project name&gt;</span><br></pre></td></tr></table></figure>
<h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>
<h1 id="setup使用"><a href="#setup使用" class="headerlink" title="setup使用"></a>setup使用</h1><p>　　定义数据、函数并返回<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setup()&#123;</span><br><span class="line">    <span class="keyword">let</span> name=<span class="string">&quot;pjt&quot;</span></span><br><span class="line">    <span class="keyword">let</span> age=<span class="number">23</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">sayhello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(<span class="string">`我叫<span class="subst">$&#123;name&#125;</span>,我<span class="subst">$&#123;age&#125;</span>岁了`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      name,</span><br><span class="line">      age,</span><br><span class="line">      sayhello</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return ()=&gt; h(&#x27;h1&#x27;,&#x27;pjt&#x27;)</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="ref和reactive方法"><a href="#ref和reactive方法" class="headerlink" title="ref和reactive方法"></a>ref和reactive方法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref,reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;App&#x27;</span>,</span><br><span class="line">  setup()&#123;</span><br><span class="line">    <span class="keyword">let</span> name=ref(<span class="string">&quot;潘江涛&quot;</span>) <span class="comment">//使用ref方法将普通数据变为响应式</span></span><br><span class="line">    <span class="keyword">let</span> age=ref(<span class="number">23</span>)</span><br><span class="line">    <span class="keyword">let</span> job=reactive(&#123; <span class="comment">//使用reactive方法将数组、对象、函数类型数据变为响应式</span></span><br><span class="line">      type : <span class="string">&#x27;学生&#x27;</span>,</span><br><span class="line">      salary: <span class="number">1000</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">changeinfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      age.value = age.value+<span class="number">1</span> <span class="comment">//取出ref数据，需要.value</span></span><br><span class="line">      job.type = <span class="string">&#x27;社会人&#x27;</span>,</span><br><span class="line">      job.salary = job.salary +<span class="number">10000</span> <span class="comment">//取出reactive数据，不需要.value</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">      name,</span><br><span class="line">      age,</span><br><span class="line">      job,</span><br><span class="line">      changeinfo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="computed方法"><a href="#computed方法" class="headerlink" title="computed方法"></a>computed方法</h1><p>　　fullname属性将根据firstname和lastname来计算<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.fullname=computed(&#123;</span><br><span class="line">  get()&#123;</span><br><span class="line">    <span class="keyword">return</span> person.firstname+person.lastname</span><br><span class="line">  &#125;,</span><br><span class="line">  set(value)&#123;</span><br><span class="line">    person.firstname=value[<span class="number">0</span>]</span><br><span class="line">    person.lastname=value.slice(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="监视函数watch和watchEffect"><a href="#监视函数watch和watchEffect" class="headerlink" title="监视函数watch和watchEffect"></a>监视函数watch和watchEffect</h1><p>　　watch只能监视浅层数据，不能监视对象或数组内部数据的变化，而watchEffect能监视所有定义的变量<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">watch(<span class="function">()=&gt;</span>person.firstname,<span class="function">(<span class="params">newvalue,oldvalue</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;姓变了&#x27;</span>,newvalue,oldvalue)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">watchEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a=person.firstname</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;person.firstname数据发生变化&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="hooks"><a href="#hooks" class="headerlink" title="hooks"></a>hooks</h1><p>　　将模块化js代码封装为hook组件，使用时直接import使用,且定义hook函数时使用下述代码包裹<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h1><h2 id="进场-退场效果"><a href="#进场-退场效果" class="headerlink" title="进场/退场效果"></a>进场/退场效果</h2><ol>
<li>template中使用<transition>标签包裹动画内容</transition></li>
<li>style中使用v-enter-active，v-leave-active类描述进场、退场动画<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">    <span class="selector-class">.v-enter-active</span>&#123;</span><br><span class="line">        <span class="attribute">animation</span>: pjt <span class="number">3s</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.v-leave-active</span>&#123;</span><br><span class="line">        <span class="attribute">animation</span>: pjt <span class="number">3s</span> reverse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@keyframes</span> pjt &#123;</span><br><span class="line">        <span class="selector-tag">from</span>&#123;</span><br><span class="line">            <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">2000px</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-tag">to</span>&#123;</span><br><span class="line">            <span class="attribute">transform</span>: <span class="built_in">translateX</span>(<span class="number">0px</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
　　或者使用过渡效果<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;style scoped&gt;</span><br><span class="line">  h1&#123;</span><br><span class="line">      background-color: orange;</span><br><span class="line">  &#125;</span><br><span class="line">  .v-enter-active,.v-leavactive&#123; <span class="comment">//动画效果</span></span><br><span class="line">      transition: <span class="number">0.5</span>s linear;</span><br><span class="line">  &#125; </span><br><span class="line">  .v-enter,.v-enter-to,&#123; <span class="comment">//进入的起点、退出的终点</span></span><br><span class="line">      transform: translateX(<span class="number">-100</span>%); </span><br><span class="line">  &#125;</span><br><span class="line">  .v-enter-to.v-leave&#123; <span class="comment">//进入的终点、退出的起点</span></span><br><span class="line">      transform: translateX(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;&gt;</span><br></pre></td></tr></table></figure>
<div class="note ">
            <ul><li>如出现多个不同动画效果，可给<transition>标记不同的class名，动画类名也改为classname-enter-active和classname-leave-active</transition></li><li>包含多个框体可以使用<transition-group>标签包裹</transition-group></li></ul>
          </div>
</li>
</ol>
<h2 id="集成第三方库"><a href="#集成第三方库" class="headerlink" title="集成第三方库"></a>集成第三方库</h2><p>　　<code>&lt;script&gt;</code>标签中引入第三方库<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;animate.css&#x27;</span></span><br></pre></td></tr></table></figure><br>　　<code>&lt;transition&gt;</code>标签加上属性<code>name</code>及操作属性<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;transition-group </span><br><span class="line">  name=<span class="string">&quot;animate__animated animate__bounce&quot;</span> </span><br><span class="line">  enter-active-<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;animate__rubberBand&quot;</span></span><br><span class="line">  leave-active-<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;animate__backOutUp&quot;</span></span><br><span class="line">  appear</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>frontend</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>多说话人自适应合成</title>
    <url>/posts/TTS-adapitve-TTS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="多说话人自适应合成"><a href="#多说话人自适应合成" class="headerlink" title="多说话人自适应合成"></a>多说话人自适应合成</h2><p>　　本文介绍了三篇自适应多说话人语音合成论文及代码分析。<br><a id="more"></a></p>
<h3 id="1-Transfer-Learning-from-Speaker-Verification-to-Multispeaker-Text-To-Speech-Synthesis"><a href="#1-Transfer-Learning-from-Speaker-Verification-to-Multispeaker-Text-To-Speech-Synthesis" class="headerlink" title="1. Transfer Learning from Speaker Verification to Multispeaker Text-To-Speech Synthesis"></a>1. <a href="https://arxiv.org/pdf/1806.04558">Transfer Learning from Speaker Verification to Multispeaker Text-To-Speech Synthesis</a></h3><div class="note info">
            <p>github源码:<a href="https://github.com/CorentinJ/Real-Time-Voice-Cloning">Real-Time-Voice-Cloning</a><br>demo演示:<a href="http://www.panjiangtao.cn/SV2TTS/">SV2TTS 说话人音色语音合成演示</a></p>
          </div>
<h4 id="1-1-论文内容"><a href="#1-1-论文内容" class="headerlink" title="1.1 论文内容"></a>1.1 论文内容</h4><p>　　在tacotron2中加入d-vector向量进行个性化指定说话人语音合成</p>
<p>　　d-vector：将指定说话人的一句语音输入一个DNN网络，获取其最后一个隐藏层的输出，用在说话人识别领域</p>
<h5 id="推理过程："><a href="#推理过程：" class="headerlink" title="推理过程："></a>推理过程：</h5><p>①选择编码器将语音的文本内容进行编码。得到一个向量。</p>
<p>②将目标人的音色（声音）进行编码或者处理成向量。</p>
<p>③将上面的两种向量在某一种维度上进行拼接得到更长的向量（一般为2倍的长度）在通过解码器进行解码成一个语音信息（并不是最终的），之后经过相应的处理得到真正的语音。整个过程就是模型的推理过程。</p>
<h4 id="1-2-模型结构"><a href="#1-2-模型结构" class="headerlink" title="1.2 模型结构"></a>1.2 模型结构</h4><p><img src="http://pic.panjiangtao.cn/img/image-20220419204452965.png" alt="SV2TTS模型"></p>
<h5 id="1-2-1-说话人编码器网络-提取说话人特征"><a href="#1-2-1-说话人编码器网络-提取说话人特征" class="headerlink" title="1.2.1 说话人编码器网络(提取说话人特征)"></a>1.2.1 说话人编码器网络(提取说话人特征)</h5><p>　　使用独立的噪声语音数据集进行说话人验证任务的训练，从来自目标说话人几秒钟的参考语音中生成固定维度的<strong>嵌入向量</strong>(说话人语音特征)，该向量称为d-vector</p>
<p>　　训练TTS时使用说话人编码器的预训练模型。</p>
<p>　　模型结构如下，使用一个多层LSTM、线性层和ReLU层。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpeakerEncoder</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, device, loss_device</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.loss_device = loss_device</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Network defition</span></span><br><span class="line">        self.lstm = nn.LSTM(input_size=mel_n_channels,</span><br><span class="line">                            hidden_size=model_hidden_size, </span><br><span class="line">                            num_layers=model_num_layers, </span><br><span class="line">                            batch_first=<span class="literal">True</span>).to(device)</span><br><span class="line">        self.linear = nn.Linear(in_features=model_hidden_size, </span><br><span class="line">                                out_features=model_embedding_size).to(device)</span><br><span class="line">        self.relu = torch.nn.ReLU().to(device)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Cosine similarity scaling (with fixed initial parameter values)</span></span><br><span class="line">        self.similarity_weight = nn.Parameter(torch.tensor([<span class="number">10.</span>])).to(loss_device)</span><br><span class="line">        self.similarity_bias = nn.Parameter(torch.tensor([<span class="number">-5.</span>])).to(loss_device)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Loss</span></span><br><span class="line">        self.loss_fn = nn.CrossEntropyLoss().to(loss_device)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_gradient_ops</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># Gradient scale</span></span><br><span class="line">        self.similarity_weight.grad *= <span class="number">0.01</span></span><br><span class="line">        self.similarity_bias.grad *= <span class="number">0.01</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># Gradient clipping</span></span><br><span class="line">        clip_grad_norm_(self.parameters(), <span class="number">3</span>, norm_type=<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, utterances, hidden_init=None</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Computes the embeddings of a batch of utterance spectrograms.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :param utterances: batch of mel-scale filterbanks of same duration as a tensor of shape </span></span><br><span class="line"><span class="string">        (batch_size, n_frames, n_channels) </span></span><br><span class="line"><span class="string">        :param hidden_init: initial hidden state of the LSTM as a tensor of shape (num_layers, </span></span><br><span class="line"><span class="string">        batch_size, hidden_size). Will default to a tensor of zeros if None.</span></span><br><span class="line"><span class="string">        :return: the embeddings as a tensor of shape (batch_size, embedding_size)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Pass the input through the LSTM layers and retrieve all outputs, the final hidden state</span></span><br><span class="line">        <span class="comment"># and the final cell state.</span></span><br><span class="line">        out, (hidden, cell) = self.lstm(utterances, hidden_init)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># We take only the hidden state of the last layer</span></span><br><span class="line">        embeds_raw = self.relu(self.linear(hidden[<span class="number">-1</span>]))</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># L2-normalize it</span></span><br><span class="line">        embeds = embeds_raw / (torch.norm(embeds_raw, dim=<span class="number">1</span>, keepdim=<span class="literal">True</span>) + <span class="number">1e-5</span>)        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> embeds</span><br></pre></td></tr></table></figure>
<h5 id="d-vector聚类效果"><a href="#d-vector聚类效果" class="headerlink" title="d-vector聚类效果"></a>d-vector聚类效果</h5><p>　　预训练模型的聚类效果如下，使用TIMIT数据集进行训练，可能是训练数据较少，效果较差。</p>
<p><img src="http://pic.panjiangtao.cn/img/D-vector说话人聚类.png" alt="D-vector说话人聚类" style="zoom:67%;"></p>
<h5 id="1-2-2-基于Tacotron-2的序列到序列合成网络"><a href="#1-2-2-基于Tacotron-2的序列到序列合成网络" class="headerlink" title="1.2.2 基于Tacotron 2的序列到序列合成网络"></a>1.2.2 基于Tacotron 2的序列到序列合成网络</h5><p>　　只需将说话人嵌入向量传递到注意力层，就可以在不同的说话人之间汇聚。其基于说话者嵌入从文本生成mel谱图；</p>
<p>　　文本编码后加入说话人嵌入向量代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encoder</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, embed_dims, num_chars, encoder_dims, K, num_highways, dropout</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        prenet_dims = (encoder_dims, encoder_dims)</span><br><span class="line">        cbhg_channels = encoder_dims</span><br><span class="line">        self.embedding = nn.Embedding(num_chars, embed_dims)</span><br><span class="line">        self.pre_net = PreNet(embed_dims, fc1_dims=prenet_dims[<span class="number">0</span>], fc2_dims=prenet_dims[<span class="number">1</span>],</span><br><span class="line">                              dropout=dropout)</span><br><span class="line">        <span class="comment">#PreNet表示的是两个全连接层</span></span><br><span class="line">        self.cbhg = CBHG(K=K, in_channels=cbhg_channels, channels=cbhg_channels,</span><br><span class="line">                         proj_channels=[cbhg_channels, cbhg_channels],</span><br><span class="line">                         num_highways=num_highways)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, speaker_embedding=None</span>):</span></span><br><span class="line">        x = self.embedding(x)</span><br><span class="line">        x = self.pre_net(x)</span><br><span class="line">        x.transpose_(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        x = self.cbhg(x)</span><br><span class="line">        <span class="keyword">if</span> speaker_embedding <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 加入说话人嵌入向量</span></span><br><span class="line">            x = self.add_speaker_embedding(x, speaker_embedding)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add_speaker_embedding</span>(<span class="params">self, x, speaker_embedding</span>):</span></span><br><span class="line">        <span class="comment"># SV2TTS的主要贡献</span></span><br><span class="line">        <span class="comment"># The input x is the encoder output and is a 3D tensor with size (batch_size, num_chars, tts_embed_dims)</span></span><br><span class="line">        <span class="comment"># When training, speaker_embedding is also a 2D tensor with size (batch_size, speaker_embedding_size)</span></span><br><span class="line">        <span class="comment">#     (for inference, speaker_embedding is a 1D tensor with size (speaker_embedding_size))</span></span><br><span class="line">        <span class="comment"># This concats the speaker embedding for each char in the encoder output</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># Save the dimensions as human-readable names</span></span><br><span class="line">        batch_size = x.size()[<span class="number">0</span>]</span><br><span class="line">        num_chars = x.size()[<span class="number">1</span>]</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> speaker_embedding.dim() == <span class="number">1</span>:</span><br><span class="line">            idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># Start by making a copy of each speaker embedding to match the input text length</span></span><br><span class="line">        <span class="comment"># The output of this has size (batch_size, num_chars * speaker_embedding_size)</span></span><br><span class="line">        speaker_embedding_size = speaker_embedding.size()[idx]</span><br><span class="line">        e = speaker_embedding.repeat_interleave(num_chars, dim=idx)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># Reshape it and transpose</span></span><br><span class="line">        e = e.reshape(batch_size, speaker_embedding_size, num_chars)</span><br><span class="line">        e = e.transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># Concatenate the tiled speaker embedding with the encoder output</span></span><br><span class="line">        x = torch.cat((x, e), <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<h5 id="1-2-3-自回归声码器waveNet"><a href="#1-2-3-自回归声码器waveNet" class="headerlink" title="1.2.3 自回归声码器waveNet"></a>1.2.3 自回归声码器waveNet</h5><p>　　声码器网络，其将mel频谱图转换成时域波形。</p>
<h3 id="2-ECAPA-TDNN-for-Multi-speaker-Text-to-speech-Synthesis"><a href="#2-ECAPA-TDNN-for-Multi-speaker-Text-to-speech-Synthesis" class="headerlink" title="2. ECAPA-TDNN for Multi-speaker Text-to-speech Synthesis"></a>2. <a href="https://arxiv.org/pdf/2203.10473">ECAPA-TDNN for Multi-speaker Text-to-speech Synthesis</a></h3><h4 id="2-1-论文内容"><a href="#2-1-论文内容" class="headerlink" title="2.1 论文内容"></a>2.1 论文内容</h4><p>　　在FastSpeech2中加入ECAPA-TDNN(进化版x-vector)进行个性化训练</p>
<h4 id="2-2-模型结构"><a href="#2-2-模型结构" class="headerlink" title="2.2 模型结构"></a>2.2 模型结构</h4><p><img src="http://pic.panjiangtao.cn/img/image-20220419204836223.png" alt="ECAPA-TTS模型结构"></p>
<h5 id="2-2-1-多说话人编码—ECAPA网络"><a href="#2-2-1-多说话人编码—ECAPA网络" class="headerlink" title="2.2.1 多说话人编码—ECAPA网络"></a>2.2.1 多说话人编码—ECAPA网络</h5><p>　　使用<a href="https://arxiv.org/pdf/2005.07143">ECAPA模型</a>进行说话人嵌入生成，模型聚类效果如下，使用VoxCeleb2数据集进行训练，取得很好的效果。</p>
<p><img src="http://pic.panjiangtao.cn/img/ecapa说话人聚类.png" alt="ecapa说话人聚类"></p>
<p>　　模型结构：</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220422133618465.png" alt=" ECAPA-TDNN结构" style="zoom: 50%;"></p>
<p>模型框架代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ECAPA_TDNN</span>(<span class="params">torch.nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,input_size,device=<span class="string">&quot;cpu&quot;</span>,lin_neurons=<span class="number">192</span>,activation=torch.nn.ReLU,</span></span></span><br><span class="line"><span class="function"><span class="params">                 channels=[<span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">512</span>, <span class="number">1536</span>],kernel_sizes=[<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>,<span class="number">1</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">                 dilations=[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>],attention_channels=<span class="number">128</span>,res2net_scale=<span class="number">8</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 se_channels=<span class="number">128</span>,global_context=True,groups=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span></span></span><br><span class="line"><span class="function"><span class="params">    </span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        <span class="keyword">assert</span> len(channels) == len(kernel_sizes)</span><br><span class="line">        <span class="keyword">assert</span> len(channels) == len(dilations)</span><br><span class="line">        self.channels = channels</span><br><span class="line">        self.blocks = nn.ModuleList()</span><br><span class="line">        <span class="comment"># The initial TDNN layer</span></span><br><span class="line">        self.blocks.append(TDNNBlock(input_size,channels[<span class="number">0</span>],kernel_sizes[<span class="number">0</span>],</span><br><span class="line">                                     dilations[<span class="number">0</span>],activation,groups[<span class="number">0</span>],))</span><br><span class="line">        <span class="comment"># SE-Res2Net layers</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(channels) - <span class="number">1</span>):</span><br><span class="line">            self.blocks.append(SERes2NetBlock(channels[i - <span class="number">1</span>],channels[i],</span><br><span class="line">                    res2net_scale=res2net_scale,se_channels=se_channels,</span><br><span class="line">                    kernel_size=kernel_sizes[i],dilation=dilations[i],</span><br><span class="line">                    activation=activation,groups=groups[i],))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Multi-layer feature aggregation</span></span><br><span class="line">        self.mfa = TDNNBlock(channels[<span class="number">-1</span>],channels[<span class="number">-1</span>],kernel_sizes[<span class="number">-1</span>],dilations[<span class="number">-1</span>],</span><br><span class="line">            activation,groups=groups[<span class="number">-1</span>],)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Attentive Statistical Pooling</span></span><br><span class="line">        self.asp = AttentiveStatisticsPooling(channels[<span class="number">-1</span>],</span><br><span class="line">            attention_channels=attention_channels,global_context=global_context,)</span><br><span class="line">        self.asp_bn = BatchNorm1d(input_size=channels[<span class="number">-1</span>] * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Final linear transformation</span></span><br><span class="line">        self.fc = Conv1d(in_channels=channels[<span class="number">-1</span>] * <span class="number">2</span>,out_channels=lin_neurons,</span><br><span class="line">            kernel_size=<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x, lengths=None</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Returns the embedding vector.</span></span><br><span class="line"><span class="string">        Arguments</span></span><br><span class="line"><span class="string">        ---------</span></span><br><span class="line"><span class="string">        x : torch.Tensor</span></span><br><span class="line"><span class="string">            Tensor of shape (batch, time, channel).</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># Minimize transpose for efficiency</span></span><br><span class="line">        x = x.transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        xl = []</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.blocks:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                x = layer(x, lengths=lengths)</span><br><span class="line">            <span class="keyword">except</span> TypeError:</span><br><span class="line">                x = layer(x)</span><br><span class="line">            xl.append(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Multi-layer feature aggregation</span></span><br><span class="line">        x = torch.cat(xl[<span class="number">1</span>:], dim=<span class="number">1</span>)</span><br><span class="line">        x = self.mfa(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Attentive Statistical Pooling</span></span><br><span class="line">        x = self.asp(x, lengths=lengths)</span><br><span class="line">        x = self.asp_bn(x)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Final linear transformation</span></span><br><span class="line">        x = self.fc(x)</span><br><span class="line"></span><br><span class="line">        x = x.transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>其中，SE-Res2Block的结构为：</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220422134136052.png" alt="SE-Res2Block" style="zoom: 50%;"></p>
<h5 id="2-2-2-在Fastspeech2中加入说话人嵌入向量"><a href="#2-2-2-在Fastspeech2中加入说话人嵌入向量" class="headerlink" title="2.2.2 在Fastspeech2中加入说话人嵌入向量"></a>2.2.2 在Fastspeech2中加入说话人嵌入向量</h5><p>　　将说话人嵌入向量在音素编码后与其进行叠加，再输入方差适配器中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FastSpeech2</span>(<span class="params">nn.Module</span>):</span>		</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, preprocess_config, model_config</span>):</span></span><br><span class="line">      	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      	&quot;&quot;&quot;</span></span><br><span class="line">        self.speaker_emb = SpeakerEmbedding(model_config)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>()</span></span><br><span class="line"><span class="function">    	&quot;&quot;&quot;</span></span><br><span class="line"><span class="function">    	&quot;&quot;&quot;</span></span><br><span class="line"><span class="function">    	<span class="title">if</span> <span class="title">self</span>.<span class="title">speaker_emb</span> <span class="title">is</span> <span class="title">not</span> <span class="title">None</span>:</span></span><br><span class="line">            spker_embed=self.speaker_emb(spker_embed)</span><br><span class="line">            <span class="comment"># speaker_classifier_output_1 = self.speaker_classifier_1(spker_embed)</span></span><br><span class="line">            output=output+self.add_speaker_embedding(output,spker_embed)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_speaker_embedding</span>(<span class="params">self, x, speaker_embedding</span>):</span></span><br><span class="line">        <span class="comment"># 将speaker_embedding处理后与x相同维度</span></span><br><span class="line">        batch_size = x.size()[<span class="number">0</span>]</span><br><span class="line">        num_chars = x.size()[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> speaker_embedding.dim() == <span class="number">1</span>:</span><br><span class="line">            idx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idx = <span class="number">1</span></span><br><span class="line">        speaker_embedding_size = speaker_embedding.size()[idx]</span><br><span class="line">        e = speaker_embedding.repeat_interleave(num_chars, dim=idx)</span><br><span class="line"></span><br><span class="line">        e = e.reshape(batch_size, speaker_embedding_size, num_chars)</span><br><span class="line">        e = e.transpose(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpeakerEmbedding</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model_config</span>):</span></span><br><span class="line">        super(SpeakerEmbedding, self).__init__()</span><br><span class="line">        <span class="keyword">assert</span> model_config[<span class="string">&quot;multi_speaker&quot;</span>] == <span class="literal">True</span></span><br><span class="line">        self.hidden_size = model_config[<span class="string">&quot;speaker_embedding&quot;</span>][<span class="string">&quot;embedding_model&quot;</span>][<span class="string">&quot;lin_neurons&quot;</span>]</span><br><span class="line">        self.embedding_size = model_config[<span class="string">&quot;speaker_embedding&quot;</span>][<span class="string">&quot;embedding_size&quot;</span>]</span><br><span class="line">        self.speaker_emb = nn.Linear(self.hidden_size,self.embedding_size)     </span><br><span class="line">        self.norm=nn.LayerNorm(self.embedding_size)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, spker_embeds</span>):</span></span><br><span class="line">        speaker_emb = self.speaker_emb(spker_embeds)</span><br><span class="line">        speaker_emb = self.norm(speaker_emb)</span><br><span class="line">        <span class="keyword">return</span> speaker_emb</span><br></pre></td></tr></table></figure>
<h4 id="2-3-模型训练效果"><a href="#2-3-模型训练效果" class="headerlink" title="2.3 模型训练效果"></a>2.3 模型训练效果</h4><p>　　加入预训练说话人嵌入模型后，模型整体训练效果如下图所示：</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220427171316769.png" alt="Fastspeech-ECAPA训练效果" style="zoom:50%;"></p>
<p>　　缺点：对<strong>未可见的说话人</strong>来说个性化合成的效果较差。</p>
<h3 id="3-Meta-TTS-Meta-Learning-for-Few-Shot-Speaker-Adaptive-Text-to-Speech"><a href="#3-Meta-TTS-Meta-Learning-for-Few-Shot-Speaker-Adaptive-Text-to-Speech" class="headerlink" title="3.Meta-TTS: Meta-Learning for Few-Shot Speaker Adaptive Text-to-Speech"></a>3.Meta-TTS: Meta-Learning for Few-Shot Speaker Adaptive Text-to-Speech</h3><div class="note info">
            <p>论文地址：<a href="https://arxiv.org/pdf/2111.04040">Meta-TTS</a><br>代码仓库：<a href="https://github.com/SungFeng-Huang/Meta-TTS/">Meta-TTS</a></p>
          </div>
<h4 id="3-1-论文内容"><a href="#3-1-论文内容" class="headerlink" title="3.1 论文内容"></a>3.1 论文内容</h4><p>　　本文将<strong>元学习</strong>（meta-learning）技术应用到说话人自适应方法当中。提出Model Agnostic Meta-Learning （MAML）算法来训练多说话人TTS模型，使得模型可以找到一个合适的元初始状态（meta-initialization）以便其快速地适应到任意少样本说话人。因此，我们可以将使用元学习算法训练好的TTS模型<strong>对unseen speaker进行高效的适应</strong>。</p>
<h4 id="3-2-模型结构"><a href="#3-2-模型结构" class="headerlink" title="3.2 模型结构"></a>3.2 模型结构</h4><h5 id="3-2-1-基于d-vector的Fastspeech2"><a href="#3-2-1-基于d-vector的Fastspeech2" class="headerlink" title="3.2.1 基于d-vector的Fastspeech2"></a>3.2.1 基于d-vector的Fastspeech2</h5><p>　　本文在Fastspeech2模型的基础上加入d-vector说话人嵌入，将该嵌入分别在音素编码后、梅尔频谱解码前加入到数据中，如下图所示。</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220505191349282.png" alt="多说话人嵌入Fastspeech2模型结构" style="zoom:50%;"></p>
<p>　　修改后的模型代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fastspeech2</span>(<span class="params">nn.module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,batch</span>):</span></span><br><span class="line">    	output = self.encoder(texts, src_masks)</span><br><span class="line">        <span class="keyword">if</span> self.speaker_emb <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            output = output + self.speaker_emb(spker_embed).unsqueeze(<span class="number">1</span>).expand(</span><br><span class="line">                <span class="number">-1</span>, max_src_len, <span class="number">-1</span>)</span><br><span class="line">            </span><br><span class="line">        (output,p_predictions,e_predictions,log_d_predictions,d_rounded,mel_lens,mel_masks) = 			       			self.variance_adaptor(output,src_masks,mel_masks,max_mel_len,p_targets,\</span><br><span class="line">            e_targets,d_targets,p_control,e_control,d_control)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.speaker_emb <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            output = output + self.speaker_emb(spker_embed).unsqueeze(<span class="number">1</span>).expand(</span><br><span class="line">                <span class="number">-1</span>, max(mel_lens), <span class="number">-1</span>)</span><br><span class="line">            </span><br><span class="line">        output, mel_masks = self.decoder(output, mel_masks)</span><br><span class="line">        output = self.mel_linear(output)</span><br><span class="line">        postnet_output = self.postnet(output) + output</span><br></pre></td></tr></table></figure>
<h5 id="3-2-2-模型训练过程"><a href="#3-2-2-模型训练过程" class="headerlink" title="3.2.2 模型训练过程"></a>3.2.2 模型训练过程</h5><p>　　本文研究对象为K-shot语音克隆任务，我们需要从多说话人语音合成数据库中构建一系列的meta-tasks。每一个meta-task的support set和query set均包含相同说话人的K个样本和Q个样本。在训练阶段，我们设置K=Q，在模型推理阶段，我们设置Q=1。</p>
<p>　　为了生成meta-task，我们先从语音合成数据中采用一个说话人，之后针对该说话人随机选择2K个语音样本，其中K个分配到support set，另外K个分配到query set。</p>
<p>　　在使用MAML算法训练多说话人FastSpeech2模型时，在内循环自适应阶段，文本编码器的参数保持固定不变，只微调说话人嵌入、变量适配器和解码器的参数。meta-training训练流程如下图所示。</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220505194827685.png" alt="meta-TTS训练流" style="zoom:50%;"></p>
<h5 id="3-2-3-基于元学习的模型训练"><a href="#3-2-3-基于元学习的模型训练" class="headerlink" title="3.2.3 基于元学习的模型训练"></a>3.2.3 基于元学习的模型训练</h5><p>　　为了加速说话人自适应方法的训练，我们提出了基于meta-learning的说话人自适应训练方法。Model-Agnostic Meta-Learning （MAML）算法是一个经典的meta-learning算法，其目的是为快速自适应找到合适的参数初始化状态。MAML包含两层优化循环操作：外循环（outer loop）和内循环（inner loop）。外循环目的是找到一个元初始化状态（meta-initialization），之后内循环可以在此基础上基于少量样本快速适应到新任务中。</p>
<p><img src="http://pic.panjiangtao.cn/img/640" alt="元学习过程" style="zoom:67%;"></p>
<p>　　假定我们将要在一个K-shot回归下游任务上评价模型效果，MAML会基于训练数据生成一系列K-shot回归训练任务，其中每个任务被称作一个适用于元学习的“meta-task”。每个任务包含一个含有K个样本的supprt set，以及一个含有Q个样本的query set。每个任务的学习目标都是基于support set学习任务相关的模型参数（内循环，inner loop）。MAML的目标就是学习meta-initialization参数，每个meta-task都可以基于该参数得到表现不错的任务自适应参数（外循环，outer loop）。这一优化过程称为“meta-update”。</p>
<h4 id="3-3-模型效果"><a href="#3-3-模型效果" class="headerlink" title="3.3 模型效果"></a>3.3 模型效果</h4><h5 id="3-3-1-训练损失效果"><a href="#3-3-1-训练损失效果" class="headerlink" title="3.3.1 训练损失效果"></a>3.3.1 训练损失效果</h5><p>　　加入预训练说话人嵌入模型后，模型整体训练效果如下图所示，由于加入两段说话人嵌入，因此损失波动较大：</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220505192410237.png" alt="训练效果" style="zoom:40%;"></p>
<h5 id="3-3-2-模型合成效果"><a href="#3-3-2-模型合成效果" class="headerlink" title="3.3.2 模型合成效果"></a>3.3.2 模型合成效果</h5><p>　　模型训练2000步至2000000步后，合成后的mel频谱图变化如下两张图所示</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220505193143278.png" alt="step-2000" style="zoom: 50%;"><img src="http://pic.panjiangtao.cn/img/image-20220505193056377.png" alt="step-2000000" style="zoom:56%;"></p>
]]></content>
      <categories>
        <category>TTS</category>
        <category>Adaptive TTS</category>
      </categories>
      <tags>
        <tag>TTS</tag>
      </tags>
  </entry>
  <entry>
    <title>语音合成模型Fastspeech2技术报告</title>
    <url>/posts/Fastspeech2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="语音合成模型Fastspeech2技术报告"><a href="#语音合成模型Fastspeech2技术报告" class="headerlink" title="语音合成模型Fastspeech2技术报告"></a>语音合成模型Fastspeech2技术报告</h1><div class="note info">
            <p>论文：<a href="https://arxiv.org/abs/2006.04558v1">FastSpeech 2: Fast and High-Quality End-to-End Text to Speech</a><br>开源项目：<a href="https://github.com/ming024/FastSpeech2">Fastspeech2 Github开源项目</a><br>合成demo：<a href="http://www.panjiangtao.cn/fastspeech2/">FastSpeech 2 语音合成演示</a></p>
          </div>
<a id="more"></a>
<h2 id="服务器部署演示"><a href="#服务器部署演示" class="headerlink" title="服务器部署演示"></a>服务器部署演示</h2><video src="http://file.panjiangtao.cn/fastspeech2_server.mp4" type="video/mp4" poster="http://pic.panjiangtao.cn/img/image-20220408160721138.png" controls="controls">
    <p>你的浏览器不支持video标签.</p>
</video>

<h2 id="1-语音质量评估"><a href="#1-语音质量评估" class="headerlink" title="1 语音质量评估"></a>1 语音质量评估</h2><h3 id="1-1-主观评价"><a href="#1-1-主观评价" class="headerlink" title="1.1 主观评价"></a>1.1 主观评价</h3><p>　　主观评价是通过人类对语音进行打分，比如平均意见得分（Mean Opinion Score，MOS）、众包平均意见得分（CrowdMOS，CMOS）和ABX 测试。主观评价中的MOS 评测是一种较为宽泛的说法，由于给出评测分数的主体是人类，因此可以灵活测试语音的不同方面。比如在语音合成领域，主要有自然度MOS（MOS of Naturalness）和相似度MOS（MOS of Similarity）。<br>　　但是人类给出的评分结果受到的干扰因素较多，谷歌对合成语音的主观评估方法进行了比较，在评估较长语音中的单个句子时，音频样本的呈现形式会显著影响参与人员给出的结果。比如仅提供单个句子而不提供上下文，与相同句子给出语境相比，被测人员给出的评分差异显著。国际电信联盟（International Telecommunication Union，ITU）将MOS 评测规范化为ITU-T P.800，其中绝对等级评分（Absolute Category Rating，ACR）应用最为广泛，ACR 的详细评估标准如下表所示。</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220329115941800.png" alt="ACR评分表"></p>
<p>　　在使用ACR 方法对语音质量进行评价时，参与评测的人员（简称被试）对语音整体质量进行打分，分值范围为1 5 分，分数越大表示语音质量越好。MOS 大于4 时，可以认为该音质受到大部分被试的认可，音质较好；若MOS 低于3，则该语音有比较大的缺陷，大部分被试并不满意该音质。</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>　　MOS是一种主观量度，它的优点是显而易见的，但它的缺点也很多。首先，为了保证MOS的可信度足够高，一般来说需要雇佣大量的评价者进行评价，这就导致成本很高；另外，MOS的大小依赖于评价者，有的评价者很苛刻，那么她给的分数就会偏低，而有的评价者却是相反的。除此之外，MOS还会受到听语音时的环境，评价者的状态等多种因素的影响。</p>
<p>　　下图展示了一次评价中评价者给出的MOS分数的均值和标准差的分布，我们可以看到，标准差最大达到了2，这就说明评价者在某些语音的质量上有很大的分歧。</p>
<p><img src="http://pic.panjiangtao.cn/img/v2-909d9159b4b4a7c9c43ce8dd23c23d1d_720w.jpg" alt="MOS分数均值、标准差" style="zoom: 67%;"></p>
<h3 id="1-2-客观评价"><a href="#1-2-客观评价" class="headerlink" title="1.2 客观评价"></a>1.2 客观评价</h3><h4 id="1-2-1-MOSNet（开源）"><a href="#1-2-1-MOSNet（开源）" class="headerlink" title="1.2.1 MOSNet（开源）"></a>1.2.1 MOSNet（开源）</h4><p>　　下图为MOSNet的网络结构，就是LSTM、CNN以及它们的组合。注意这里模型输出两种MOS分数，一是frame-level的分数，另一个是utterance-level的分数。</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220329120657195.png" alt="MOSNet结构图" style="zoom:67%;"></p>
<p>　　损失函数为：</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220329120853312.png" alt="image-20220329120853312" style="zoom:50%;"></p>
<p>　　上式第一项是utterance-level的MSE，第二项是frame-level的MSE。</p>
<h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>　　首先不同工作所做的MOS评测所得到的数据是很难合并在一起的，因为不同MOS评测的分数分布都是不同的。所以像VCC 2018这样的大量且统一评价的情况是比较少的，因此简而言之，数据量还是不足。</p>
<p>　　另外，如何增加模型的泛化性也是一个重要的问题，举例来说，我们在VCC 2018上训练的模型是否能够预测其它的MOS评测，比如VCC 2019的分数呢？实际上这被证明是很难的。</p>
<h4 id="1-2-2-SESQA（未开源）"><a href="#1-2-2-SESQA（未开源）" class="headerlink" title="1.2.2 SESQA（未开源）"></a>1.2.2 SESQA（未开源）</h4><p>　　下图为SESQA模型结构，实际上是一个multi-task模型。模型接受一个语音的输入x，然后利用神经网络生成x的隐表示z，之后通过计算各种loss来学习到好的数据表示。</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220329121351363.png" alt="SESQA模型结构" style="zoom:50%;"></p>
<p>　　SESQA中包含8种loss，但是在ablation experiment中很多loss被证明是没什么用的，因此这里我将介绍最重要的几种loss，对没有介绍到的loss感兴趣的读者可以参考原论文。</p>
<p>　　首先是MOS loss，这个loss是针对有标注的数据设计的：</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220329121709812.png" alt="MOS loss" style="zoom: 67%;"></p>
<p>　　然后是pairwise ranking loss：</p>
<p><img src="http://pic.panjiangtao.cn/img/v2-ba26d4f46e9e8e542a381f77f0bc0d33_720w.png" alt="pairwise ranking loss" style="zoom: 67%;"></p>
<p>　　这个loss中$s_i$代表原语音$x_i$的分数，而$s_i$是在原语音$x_i$中加入一些噪声之后的语音$x_i$的分数，这样从直觉上来说一定有$s_i&gt;s_j$，这个loss会对不符合这个限制的输出进行惩罚，$\alpha$是margin参数。</p>
<p>　　最后是score consistency loss：</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220329121732291.png" alt="score consistency loss" style="zoom:50%;"></p>
<p>这个loss中，$s_k$和$s_l$是两个类似的语音$x_k$和$x_l$的分数，因此有$s_k\approx s_l$；相反$s_i$和$s_j$是品质明显差别的两个语音$x_i$和$x_j$的分数，因此有$|s_i-s_j|&gt;\beta$。loss的中间一项拓展了这两个关系，假设语音分别是语音$x_{ik}$和$x_{il}$的劣化版，且$x_{ik}$和$x_{il}$的品质类似，那么有：$s_{ik}-s_{jk}=s_{il}-s_{jl}$</p>
<h2 id="2-语音信号特征"><a href="#2-语音信号特征" class="headerlink" title="2 语音信号特征"></a>2 语音信号特征</h2><h3 id="2-1-短时能量"><a href="#2-1-短时能量" class="headerlink" title="2.1 短时能量"></a>2.1 短时能量</h3><p>　　短时能量体现的是信号在不同时刻的强弱程度。设第n 帧语音信号的短时能量用𝐸𝑛 表示，则其计算公式为：</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220329161118385.png" alt="短时能量公式" style="zoom: 67%;"></p>
<p>　　上式中，𝑀 为帧长，$𝑥_𝑛(𝑚)$为该帧中的样本点。</p>
<h3 id="2-2-基频和基音周期"><a href="#2-2-基频和基音周期" class="headerlink" title="2.2 基频和基音周期"></a>2.2 基频和基音周期</h3><p>　　基音周期反映了声门相邻两次开闭之间的时间间隔，基频（fundamental frequency，F0）则是基音周期的倒数，对应着声带振动的频率，代表声音的音高，声带振动越快，基频越高。它是语音激励源的一个重要特征，比如可以通过基频区分性别。一般来说，成年男性基频在100-250Hz 左右，成年女性基频在150-350Hz 左右，女声的音高一般比男声稍高。</p>
<p>　　人类可感知声音的频率大致在20-20000Hz 之间，人类对于基频的感知遵循对数律，也就是说，人们会感觉100Hz 到200Hz 的差距，与200Hz 到400Hz 的差距相同。因此，音高常常用基频的对数来表示。在音乐上，把相差一倍的两个基频的差距称为一个八度（octave）；把一个八度12 等分，每一份称为一个半音（semitone）；把一个半音再100 等分，每一份称为一个音分（cent）。</p>
<p>　　基频是语音的重要特征，在包括语音合成的语音处理中有着广泛的应用，比如语音转换（Voice Conversion，VC）和语音合成中基频是一个强特征。基频的提取可以分为时域法和频域法。时域法以波形为输入，基本原理是寻找波形的最小正周期；频域法则会先对信号进行傅里叶变换，得到频谱，频谱在基频的整倍数处有尖峰，频域法的基本原理就是求出这些尖峰频率的最大公约数。但是考虑到基频并非每一帧都有，因此在提取基频前后，都需要判断有无基频，称之为清浊音判断（Unvoiced/Voiced Decision，U/V Decision）。语音的基频往往随着时间变化，在提取基频之前往往要进行分帧，逐帧提取的基频常常含有错误，其中常见的错误就是倍频错误和半频错误，也就是提取出来的基频是真实基频的两倍或者一半，因此基频提取后要进行平滑操作。常见的基频提取算法有基于信号处理时域法的 YIN1，基于信号处理频域法的 SWIPE2，基于机器学习时域法的 CREPE3和基于机器学习频域法的SPICE4。常用的基频提取工具有pyWORLD，Parselmouth，CREPE，YIN等。参见基频提取算法综述。</p>
<h3 id="2-3-音高"><a href="#2-3-音高" class="headerlink" title="2.3 音高"></a>2.3 音高</h3><p>　　音高（pitch）是由声音的基频决定的，音高和基频常常混用。可以这样认为，音高（pitch）是稀疏离散化的基频（F0）。由规律振动产生的声音一般都会有基频，比如语音中的元音和浊辅音；也有些声音没有基频，比如人类通过口腔挤压气流的清辅音。在汉语中，元音有a/e/i/o/u，浊辅音有y/w/v，其余音素比如b/p/q/x 等均为清辅音，在发音时，可以通过触摸喉咙感受和判断发音所属音素的种类。</p>
<h3 id="2-4-MFCC和语谱图"><a href="#2-4-MFCC和语谱图" class="headerlink" title="2.4 MFCC和语谱图"></a>2.4 MFCC和语谱图</h3><p>　　对语音进行分析和处理时，部分信息在时域上难以分析，因此往往会提取频谱特征。在语音合成中，通常将频谱作为中间声学特征：首先将文本转换为频谱，再将频谱转换为波形；在语音识别中，则将频谱或者MFCC作为中间声学特征。语音通过预加重、分帧、加窗、傅里叶变换之后，取功率谱的幅度平方，进行梅尔滤波取对数之后，就得到了梅尔频谱（或称FilterBank/FBank），如果再进行离散余弦变换，就能够获得MFCC。语音通常是一个短时平稳信号，在进行傅里叶变换之前，一般要进行分帧，取音频的一个小片段进行短时傅里叶变换（STFT）。STFT 的结果是一个复数，包括幅度和相位信息，将该复数中的频率作为横轴，幅度作为纵轴，如图2.3所示，就组成了频谱图，将频谱图中的尖峰点连接起来，就形成了频谱包络。注意到，频谱图反映一个语音帧的频域情况，没有时间信息。因此，将每个帧对应的频谱图连接起来，以时间作为横轴，频率作为纵轴，颜色深浅表示幅度，如图2.4下面红图所示，就组成了语谱图。语谱图实际上是一个三维图，横轴时间，纵轴频率，颜色深浅表示幅度大小，一般来说，颜色越深，表示幅度值越大。</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220329161609642.png" alt="图2.3: 频谱图" style="zoom: 50%;"></p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220329161653885.png" alt="图2.4: 波形和对应的语谱图" style="zoom:67%;"></p>
<h2 id="3-数据预处理"><a href="#3-数据预处理" class="headerlink" title="3 数据预处理"></a>3 数据预处理</h2><h3 id="3-1-将中文转化为拼音"><a href="#3-1-将中文转化为拼音" class="headerlink" title="3.1 将中文转化为拼音"></a>3.1 将中文转化为拼音</h3><p>　　首先准备好音频数据和对应的文字，如果文字是中文需要转化为拼音，我使用了pypinyin进行转化，每个中文汉字对应一个拼音，脚本如下，将中文字转为拼音：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> pypinyin <span class="keyword">import</span> pinyin, lazy_pinyin, Style</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">root_dir = <span class="string">&quot;../train/&quot;</span></span><br><span class="line">pattern = re.compile(<span class="string">r&#x27;(.*)\.txt$&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> root, dir, files <span class="keyword">in</span> os.walk(root_dir):</span><br><span class="line">	<span class="keyword">for</span> filename <span class="keyword">in</span> files:</span><br><span class="line">		<span class="comment">#print(filename)</span></span><br><span class="line">		output = pattern.match(filename)</span><br><span class="line">		<span class="keyword">if</span> output <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">			print(root, filename)</span><br><span class="line">			text_file = open(root+<span class="string">&quot;/&quot;</span>+filename)</span><br><span class="line">			line = text_file.read().strip()</span><br><span class="line">			line = line.replace(<span class="string">&quot;，&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">			pinyin =  lazy_pinyin(line, style=Style.TONE3, neutral_tone_with_five=<span class="literal">True</span>)</span><br><span class="line">			pinyinline = <span class="string">&#x27; &#x27;</span>.join(pinyin)</span><br><span class="line">			print(line)</span><br><span class="line">			target_text_file = open(root+<span class="string">&quot;/&quot;</span>+output.group(<span class="number">1</span>)+<span class="string">&quot;.lab&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">			target_text_file.write(pinyinline)</span><br><span class="line">			target_text_file.close()</span><br></pre></td></tr></table></figure>
<p>　　保证音频文件的名字和脚本的文件名仅仅后缀不同：</p>
<p>　　例如：T0055G0002S0001.wav 和 T0055G0002S0001.lab</p>
<p>　　其中lab文件内容：yi3 hou4 ni3 shi4 nan2 hai2 zi5 原来的中文为：“以后你是男孩子”</p>
<h3 id="3-2-MFA"><a href="#3-2-MFA" class="headerlink" title="3.2 MFA"></a>3.2 MFA</h3><p>　　<a href="https://github.com/MontrealCorpusTools/Montreal-Forced-Aligner/">Montreal Forced Aligner</a> (MFA)，一种forced alignment工具。如果你熟悉有关工具的话，你可能会知道Prosodylab-Aligner这个forced alignment工具，而MFA正是它的升级版，拥有更好的性能。另外MFA使用了Kaldi而不是HTK，因此可以作为单独的package来使用。作者在英语数据上测试了MFA在单词和音素alignment上的表现，并和两个之前的工作进行了对比，实验结果显示MFA有更好的表现。</p>
<p>　　Forced alignment （以下简称FA，不过请注意这个简称不常用）是一个在speech processing中常见的任务。给定一段语音和它的文本，FA需要找到每个单词或是音素对应的时间段。FA中我们一般假设文本和语音的alignment是对角线型的，也就是说如果在text中某个音素出现在另一个音素的后面，那么在语音中这个关系也是成立的，反之亦同。</p>
<h4 id="3-2-1-MFA安装"><a href="#3-2-1-MFA安装" class="headerlink" title="3.2.1 MFA安装"></a>3.2.1 MFA安装</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pip install montreal-forced-aligner</span><br><span class="line">mfa thirdparty download</span><br><span class="line">pip install montreal-forced-aligner -U</span><br></pre></td></tr></table></figure>
<h4 id="3-2-2-使用前准备"><a href="#3-2-2-使用前准备" class="headerlink" title="3.2.2 使用前准备"></a>3.2.2 使用前准备</h4><ul>
<li>语言对应的发音词典，对于我们常用的英文、中文，都有比较好的可用的词典。</li>
<li>语音数据（<code>.wav</code>如果你没安装sox）</li>
<li>文本数据，注意文本数据的文件名中除了扩展名之外其他的部分要和对应的语音数据一一对应。</li>
</ul>
<h4 id="3-2-3-使用"><a href="#3-2-3-使用" class="headerlink" title="3.2.3 使用"></a>3.2.3 使用</h4><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mfa model download acoustic english  <span class="comment">#下载English acoustic model</span></span><br><span class="line">mfa align /path/to/dataset /path/to/lexicon.txt english /output/path  <span class="comment"># 使用预训练模型来进行alignment：</span></span><br></pre></td></tr></table></figure>
<p>　　经过MFA处理后，生成一个包含所有音频的对齐文件.TextGrid</p>
<h3 id="3-3-提取能量、音高、梅尔频谱和音素时长信息"><a href="#3-3-提取能量、音高、梅尔频谱和音素时长信息" class="headerlink" title="3.3 提取能量、音高、梅尔频谱和音素时长信息"></a>3.3 提取能量、音高、梅尔频谱和音素时长信息</h3><p>　　预处理代码中下面有 6个functions,作用如下述所示，把语音数据，对应的textgrid数据和.lab 文本数据进行整合，提取出需要的energy, pitch, mel spectrogram, duration等信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, config</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;加载configs中配置，按照预设路径读入数据&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_from_path</span>(<span class="params">self</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">主要程序，主要作用是：</span></span><br><span class="line"><span class="string">     1.加载从precess_utterance这个function里获得的信息</span></span><br><span class="line"><span class="string">     2.对信息进行normalize,</span></span><br><span class="line"><span class="string">     3.最后按照指定路径写入文件</span></span><br><span class="line"><span class="string">      （speaker.json, stats.json, train.txt, val.txt)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_utterance</span>(<span class="params">self, speaker, basename</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">被build_from_path这个function调用</span></span><br><span class="line"><span class="string">主要作用是</span></span><br><span class="line"><span class="string">        1.通过get_alignment这个function获取textgrid files里的duration信息</span></span><br><span class="line"><span class="string">        2.计算出wav files里的pitch</span></span><br><span class="line"><span class="string">        3.通过stft（短时傅里叶变换）把声音文件转成mel频谱</span></span><br><span class="line"><span class="string">        4.计算出wav files里的energy</span></span><br><span class="line"><span class="string">        5.将获得的pitch, energy, mel，duration信息分别写入以.npy为后缀的文件</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_alignment</span>(<span class="params">self, tier</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">被process_utterance这个function调用</span></span><br><span class="line"><span class="string">主要作用是提取textgrid files里的phone,duration,start_time, end_time等信息</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_outlier</span>(<span class="params">self, values</span>):</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span>(<span class="params">self, in_dir, mean, std</span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这两个function都是用来normalize data的</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-合成模型结构"><a href="#4-合成模型结构" class="headerlink" title="4 合成模型结构"></a>4 合成模型结构</h2><h3 id="4-1-总体结构"><a href="#4-1-总体结构" class="headerlink" title="4.1 总体结构"></a>4.1 总体结构</h3><p>　　FastSpeech 2 的模型架构下图(a)所示，它沿用 FastSpeech 中提出的 Feed-Forward Transformer（FFT）架构，编解码器的输入首先进行位置编码，之后进入FFT 块。FFT 块主要包括多头注意力模块和位置前馈网络，位置前馈网络可以由若干层Conv1d、LayerNorm 和Dropout 组成。在音素编码器和梅尔频谱解码器中加入了一个可变信息适配器（Variance Adaptor），从而支持在 FastSpeech 2 和 2s 中引入更多语音中变化的信息，例如时长、音高、音量（频谱能量）等，来解决语音合成中的一对多映射问题（文本到语音合成中，一条文本可以对应到多条可变的语音，这些可变信息包括语音时长、音高、音量等。FastSpeech 通过知识蒸馏降低语音训练目标的变化性来缓解一对多映射问题，但也造成了训练目标的信息损失。FastSpeech 2 通过引入对应的可变信息作为解码器输入，使输入输出信息尽量匹配，来解决这个问题），最终得到的输出为梅尔频谱图，而后交给声码器生成音频。</p>
<p><img src="http://pic.panjiangtao.cn/img/image-20220329204107873.png" alt="FastSpeech 2 和 2s 模型框架。图（b）中的 LR 表示 FastSpeech 中的序列长度适配操作，图（c）中的 LN 表示层归一化，可变信息预测器（variance predictor）包括时长、音高和能量预测器。" style="zoom:67%;"></p>
<h3 id="4-2-FFT（feed-forward-Transformer，前馈Transformer）"><a href="#4-2-FFT（feed-forward-Transformer，前馈Transformer）" class="headerlink" title="4.2 FFT（feed-forward Transformer，前馈Transformer）"></a>4.2 FFT（feed-forward Transformer，前馈Transformer）</h3><p>采用了Attention机制和1D卷积，其中多头注意力结构如下图所示：</p>
<p><img src="http://pic.panjiangtao.cn/img/202111181632_987.png" style="zoom:50%;"></p>
<p><img src="http://pic.panjiangtao.cn/img/202111181633_144.png" style="zoom: 50%;"></p>
<p><img src="http://pic.panjiangtao.cn/img/202111181635_901.png" style="zoom:50%;"></p>
<p>Attention 机制实质上就是一个寻址过程，通过给定一个任务相关的查询 Query 向量 Q，通过计算与 Key 的注意力分布并附加在 Value 上，从而计算 Attention Value</p>
<ol>
<li><p>Q，K，V 三个矩阵都来自同一个输入，通过线性变换得到 Q，K，V 三个向量。</p>
</li>
<li><p>计算自注意力得分，计算每个单词的自注意力，和这个单词对句子中其他单词的评分，通过矩阵Q、K相乘计算</p>
</li>
<li><p>第二步计算的分数进行缩放，这里通过除以 根号dk ( 论文中 <img src="http://pic.panjiangtao.cn/img/equation" alt="[公式]">，这可以让模型有更稳定的梯度，默认值是 64，也可以是其它值 )，将结果进行softmax 归一化。</p>
</li>
<li><p>最后乘以V</p>
</li>
<li><p>上面过程做 H 次，再把输出合并起来</p>
</li>
</ol>
<h3 id="4-3-变量适配器（Variance-Adaptor）"><a href="#4-3-变量适配器（Variance-Adaptor）" class="headerlink" title="4.3 变量适配器（Variance Adaptor）"></a>4.3 变量适配器（Variance Adaptor）</h3><p><img src="http://pic.panjiangtao.cn/img/image-20220330192940582.png" alt="Variance Adaptor" style="zoom:50%;"></p>
<p>　　在对时长、基频和能量单独建模时，所使用的网络结构实际是相似的，在论文中称这种语音属性建模网络为变量适配器（Variance Adaptor）。时长预测的输出也作为基频和能量预测的输入。最后，基频预测和能量预测的输出，以及依靠时长信息展开的编码器输入元素加起来，作为下游网络的输入。变量适配器主要是由2 层卷积和1 层线性映射层组成，每层卷积后加ReLU 激活、LayerNorm 和Dropout。</p>
<h4 id="4-3-1-基本结构Variance-Predictor"><a href="#4-3-1-基本结构Variance-Predictor" class="headerlink" title="4.3.1 基本结构Variance Predictor"></a>4.3.1 基本结构Variance Predictor</h4><p>　　对时长、基频和能量建模的基本结构为Variance Predictor，其代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VariancePredictor</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Duration, Pitch and Energy Predictor&quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, model_config</span>):</span></span><br><span class="line">        super(VariancePredictor, self).__init__()</span><br><span class="line"></span><br><span class="line">        self.input_size = model_config[<span class="string">&quot;transformer&quot;</span>][<span class="string">&quot;encoder_hidden&quot;</span>]</span><br><span class="line">        self.filter_size = model_config[<span class="string">&quot;variance_predictor&quot;</span>][<span class="string">&quot;filter_size&quot;</span>]</span><br><span class="line">        self.kernel = model_config[<span class="string">&quot;variance_predictor&quot;</span>][<span class="string">&quot;kernel_size&quot;</span>]</span><br><span class="line">        self.conv_output_size = model_config[<span class="string">&quot;variance_predictor&quot;</span>][<span class="string">&quot;filter_size&quot;</span>]</span><br><span class="line">        self.dropout = model_config[<span class="string">&quot;variance_predictor&quot;</span>][<span class="string">&quot;dropout&quot;</span>]</span><br><span class="line"></span><br><span class="line">        self.conv_layer = nn.Sequential(OrderedDict([</span><br><span class="line">                    (<span class="string">&quot;conv1d_1&quot;</span>,Conv(self.input_size,</span><br><span class="line">                            		self.filter_size,</span><br><span class="line">                            		kernel_size=self.kernel,</span><br><span class="line">                            		padding=(self.kernel - <span class="number">1</span>) // <span class="number">2</span>,),),</span><br><span class="line">                    (<span class="string">&quot;relu_1&quot;</span>, nn.ReLU()),</span><br><span class="line">                    (<span class="string">&quot;layer_norm_1&quot;</span>, nn.LayerNorm(self.filter_size)),</span><br><span class="line">                    (<span class="string">&quot;dropout_1&quot;</span>, nn.Dropout(self.dropout)),</span><br><span class="line">                    (<span class="string">&quot;conv1d_2&quot;</span>,Conv(self.filter_size,</span><br><span class="line">                            		self.filter_size,</span><br><span class="line">                            		kernel_size=self.kernel,</span><br><span class="line">                            		padding=<span class="number">1</span>,),),</span><br><span class="line">                    (<span class="string">&quot;relu_2&quot;</span>, nn.ReLU()),</span><br><span class="line">                    (<span class="string">&quot;layer_norm_2&quot;</span>, nn.LayerNorm(self.filter_size)),</span><br><span class="line">                    (<span class="string">&quot;dropout_2&quot;</span>, nn.Dropout(self.dropout)),</span><br><span class="line">              ]))</span><br><span class="line"></span><br><span class="line">        self.linear_layer = nn.Linear(self.conv_output_size, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, encoder_output, mask</span>):</span></span><br><span class="line">        out = self.conv_layer(encoder_output)</span><br><span class="line">        out = self.linear_layer(out)</span><br><span class="line">        out = out.squeeze(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            out = out.masked_fill(mask, <span class="number">0.0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>
<h4 id="4-3-2-Variance-Adaptor实现"><a href="#4-3-2-Variance-Adaptor实现" class="headerlink" title="4.3.2 Variance Adaptor实现"></a>4.3.2 Variance Adaptor实现</h4><p>　　利用该变量适配器对时长、基频和能量进行建模。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VarianceAdaptor</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Variance Adaptor&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, preprocess_config, model_config</span>):</span></span><br><span class="line">        super(VarianceAdaptor, self).__init__()</span><br><span class="line">        self.duration_predictor = VariancePredictor(model_config)</span><br><span class="line">        self.length_regulator = LengthRegulator()</span><br><span class="line">        self.pitch_predictor = VariancePredictor(model_config)</span><br><span class="line">        self.energy_predictor = VariancePredictor(model_config)</span><br><span class="line">        </span><br><span class="line">        self.pitch_bins =nn.Parameter(torch.exp(torch.linspace(</span><br><span class="line">            np.log(pitch_min), np.log(pitch_max), n_bins - <span class="number">1</span>)),requires_grad=<span class="literal">False</span>,)</span><br><span class="line">        self.energy_bins = nn.Parameter(torch.exp(torch.linspace(</span><br><span class="line">            np.log(energy_min), np.log(energy_max), n_bins - <span class="number">1</span>)),requires_grad=<span class="literal">False</span>,)</span><br><span class="line">		self.pitch_embedding = nn.Embedding(</span><br><span class="line">            n_bins, model_config[<span class="string">&quot;transformer&quot;</span>][<span class="string">&quot;encoder_hidden&quot;</span>])</span><br><span class="line">        self.energy_embedding = nn.Embedding(</span><br><span class="line">            n_bins, model_config[<span class="string">&quot;transformer&quot;</span>][<span class="string">&quot;encoder_hidden&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self,x,src_mask,mel_mask=None,max_len=None,pitch_target=None,</span></span></span><br><span class="line"><span class="function"><span class="params">        energy_target=None,duration_target=None,p_control=<span class="number">1.0</span>,e_control=<span class="number">1.0</span>,d_control=<span class="number">1.0</span></span>):</span></span><br><span class="line"></span><br><span class="line">        log_duration_prediction = self.duration_predictor(x, src_mask)</span><br><span class="line">		<span class="keyword">if</span> duration_target <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            x, mel_len = self.length_regulator(x, duration_target, max_len)</span><br><span class="line">            duration_rounded = duration_target</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            duration_rounded = torch.clamp(</span><br><span class="line">                (torch.round(torch.exp(log_duration_prediction) - <span class="number">1</span>) * d_control),min=<span class="number">0</span>)</span><br><span class="line">            x, mel_len = self.length_regulator(x, duration_rounded, max_len)</span><br><span class="line">            mel_mask = get_mask_from_lengths(mel_len)</span><br><span class="line"></span><br><span class="line">        pitch_prediction, pitch_embedding = self.get_pitch_embedding(</span><br><span class="line">            x, pitch_target, mel_mask, p_control)</span><br><span class="line">            x = x + pitch_embedding</span><br><span class="line">        energy_prediction, energy_embedding = self.get_energy_embedding(</span><br><span class="line">            x, energy_target, mel_mask, p_control</span><br><span class="line">            x = x + energy_embedding</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> x,pitch_prediction,energy_prediction,log_duration_prediction,</span><br><span class="line">            duration_rounded,mel_len,mel_mask</span><br></pre></td></tr></table></figure>
<h2 id="5-声码器"><a href="#5-声码器" class="headerlink" title="5 声码器"></a>5 声码器</h2><h3 id="5-1-MelGan"><a href="#5-1-MelGan" class="headerlink" title="5.1 MelGan"></a>5.1 MelGan</h3><p>论文链接： <a href="http://arxiv.org/abs/1910.06711">MelGAN: Generative Adversarial Networks for Conditional Waveform Synthesis</a></p>
<p>开源项目：<a href="https://github.com/rishikksh20/melgan">Multi-band MelGAN and Full band MelGAN</a></p>
<p>演示demo：<a href="http://www.panjiangtao.cn/melgan/">MelGan声码器效果演示</a></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>MelGAN是一种非自回归前馈卷积架构，是第一个由GAN去实现原始音频的生成，在没有额外的蒸馏和感知损失的引入下仍能产生高质量的语音合成模型。</li>
<li>MelGAN解码器可替代自回归模型，以生成原始音频。</li>
<li>MelGAN的速度明显快于其他Mel谱图转换到音频的方法，在保证音频质量没有明显下降的情况下比迄今为止最快的可用模型快10倍。</li>
</ul>
<p>模型包括两部分: Generator（生成器） 和 Discriminator（判别器）。</p>
<h4 id="5-1-1-生成器"><a href="#5-1-1-生成器" class="headerlink" title="5.1.1 生成器"></a>5.1.1 生成器</h4><p>　　输入为mel-spectrogram，输出为raw waveform. 从 mel-spectrogram到 audio的过程很显然是一个上采样的过程。</p>
<p>　　这里的上采样是由一维反卷积(transpose1d)实现的，上采样的倍数如何确定呢？</p>
<p>　　需要注意一下，上采样的倍数是由hop_size来决定的，为什么呢？</p>
<p>　　需要明白一点，mel帧数 * 帧移 = 音频长度（采样点个数，可换算为音频时长，具体怎么做不用说了吧）</p>
<p>　　因此，对于22050采样率， hopsize大小设置为256， 那么对应的mel-spectrogram需要上采样 256倍</p>
<p>　　如果是16000采样率呢？ 使用帧长是50ms,帧移 12.5ms 那么hopsize就是200啦，所以上采样倍数就是200倍啦.</p>
<p>　　搞清楚了这些，那么Generator Upsampling层中的上采样倍数也就好理解了，22050的采样倍数为 8 X 8 X 2 X 2 = 256</p>
<h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p><img src="http://pic.panjiangtao.cn/img/20200310123249936.png" alt="MelGAN生成器结构" style="zoom: 50%;"></p>
<p>其中残差块结构：</p>
<p><img src="http://pic.panjiangtao.cn/img/2020031012332078.png" alt="MelGAN生成器残差快结构" style="zoom: 33%;"></p>
<p>　　经过一层Conv层后送到上采样网络块，上采样网络块一共有4个，依次为8x,8x,2x,2x，每个上采样网络块中嵌套残差块，每个残差块有三层，依次dilation为1,3,9，最后经过一层conv层得到音频输出，由于音频的channel表示为1，所以最后一层的channel设为1。</p>
<h5 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h5><ol>
<li><p>Mel频谱图的时间分辨率比原始音频低256倍，所以使用了堆叠的反卷积层进行unsample。</p>
</li>
<li><p>条件信息足够的情况下，在输入处增加噪声是不必要的。所以与传统GAN不同，并没有增加noise input</p>
</li>
<li><p>使用残差块解决梯度消散的问题，空洞卷积层的感受野随层数的增加而指数增加，能够有效地增加每个输出时间步长的感应野。</p>
</li>
<li><p>反卷积层的k-size和stride仔细选择决定的，可以减少artifacts的出现。</p>
</li>
<li><p>归一化选择Weight Norm，因为不会限制判别器的空间，也不会对激活进行归一化</p>
</li>
</ol>
<h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对一维卷积层进行Weight Norm</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WNConv1d</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">return</span> weight_norm(nn.Conv1d(*args, **kwargs))</span><br><span class="line"><span class="comment">#对一维反卷积层进行Weight Norm</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WNConvTranspose1d</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">return</span> weight_norm(nn.ConvTranspose1d(*args, **kwargs))</span><br><span class="line"><span class="comment">#残差块中一层的结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResnetBlock</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dim, dilation=<span class="number">1</span></span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        <span class="comment">#依次为两层卷积层</span></span><br><span class="line">        self.block = nn.Sequential(</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.ReflectionPad1d(dilation),</span><br><span class="line">            WNConv1d(dim, dim, kernel_size=<span class="number">3</span>, dilation=dilation),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            WNConv1d(dim, dim, kernel_size=<span class="number">1</span>),</span><br><span class="line">        )</span><br><span class="line">        self.shortcut = WNConv1d(dim, dim, kernel_size=<span class="number">1</span>) </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.shortcut(x) + self.block(x) <span class="comment">#残差连接</span></span><br><span class="line"><span class="comment">#生成器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Generator</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, input_size, ngf, n_residual_layers</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        ratios = [<span class="number">8</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">        self.hop_length = np.prod(ratios)</span><br><span class="line">        mult = int(<span class="number">2</span> ** len(ratios))</span><br><span class="line">		<span class="comment">#第一层卷积</span></span><br><span class="line">        model = [</span><br><span class="line">            nn.ReflectionPad1d(<span class="number">3</span>),</span><br><span class="line">            WNConv1d(input_size, mult * ngf, kernel_size=<span class="number">7</span>, padding=<span class="number">0</span>),</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 上采样阶段，共4个，依次为8x,8x,2x,2x的UpSampling layer</span></span><br><span class="line">        <span class="keyword">for</span> i, r <span class="keyword">in</span> enumerate(ratios):</span><br><span class="line">            model += [</span><br><span class="line">                nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">                WNConvTranspose1d(</span><br><span class="line">                    mult * ngf,</span><br><span class="line">                    mult * ngf // <span class="number">2</span>,</span><br><span class="line">                    kernel_size=r * <span class="number">2</span>,</span><br><span class="line">                    stride=r,</span><br><span class="line">                    padding=r // <span class="number">2</span> + r % <span class="number">2</span>,</span><br><span class="line">                    output_padding=r % <span class="number">2</span>,</span><br><span class="line">                ),</span><br><span class="line">            ]</span><br><span class="line">			<span class="comment">#加入残差块，每个残差块中有3层，dilation分别为1,3,9</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n_residual_layers):</span><br><span class="line">                model += [ResnetBlock(mult * ngf // <span class="number">2</span>, dilation=<span class="number">3</span> ** j)]</span><br><span class="line"></span><br><span class="line">            mult //= <span class="number">2</span></span><br><span class="line">		<span class="comment">#最后一层卷积层</span></span><br><span class="line">        model += [</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>),</span><br><span class="line">            nn.ReflectionPad1d(<span class="number">3</span>),</span><br><span class="line">            WNConv1d(ngf, <span class="number">1</span>, kernel_size=<span class="number">7</span>, padding=<span class="number">0</span>),</span><br><span class="line">            nn.Tanh(),</span><br><span class="line">        ]</span><br><span class="line">        self.model = nn.Sequential(*model)</span><br><span class="line">        self.apply(weights_init)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.model(x)</span><br></pre></td></tr></table></figure>
<h4 id="5-1-2-判别器"><a href="#5-1-2-判别器" class="headerlink" title="5.1.2 判别器"></a>5.1.2 判别器</h4><p>　　论文提出了multi-scale的discriminator, 基于的假设是每个scale的discriminator可以学习到不同频率段的音频的特征。</p>
<p>　　每个discriminator的网络结构是由前后各一层1维卷积 和 4层分组卷积构成的downsampling layer构成. discriminator输入是由ground truth的音频和gererator生成的fake音频两部分构成的。 输入维度为[B, T, 1]， 输出维度也是[B,T,1], 中间变换的只是通道数的变化， 最后一层的输出和倒数第二层卷积网络的输出被分别用来计算 featuremap 和 feature_score, 这两部分被用来计算 generator的<em>feature_matching_loss</em>(L1_loss) 和discriminator的<em>mse_loss</em></p>
<p>　　上面我们知道了Generator输入mel-spectrogram,生成音频audio, 这个音频可以表示为G （s）, s为mel-spectrogram. 判别器要判断生成器生成音频的真假，这里就涉及到Gan模型的原理啦，</p>
<p>　　Generator输入mel-spectrogram生成音频(fake), Discriminator输入真(real)音频和假(fake)音频，学习一个二分类器（可以这么理解），这里使用的是mse损失来最小化real与1的差异，fake与0的差异。</p>
<p>　　通过对抗学习，使得generator生成的音频达到判别器无法判断真假的效果(loss接近0.5)。</p>
<h5 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h5><p><img src="https://img-blog.csdnimg.cn/20200310123441481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNTYyNzA0,size_16,color_FFFFFF,t_70#pic_center" alt="melgan判别器模型" style="zoom:50%;"></p>
<h5 id="损失函数："><a href="#损失函数：" class="headerlink" title="损失函数："></a>损失函数：</h5><p><img src="http://pic.panjiangtao.cn/img/image-20220331174705235.png" alt="melgan判别器损失函数" style="zoom: 67%;"></p>
<p>x表示音频，s表示mel谱图，z表示高斯噪声</p>
<h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#对一维卷积层进行Weight Norm</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WNConv1d</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">return</span> weight_norm(nn.Conv1d(*args, **kwargs))</span><br><span class="line"><span class="comment">#对一维反卷积层进行Weight Norm</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">WNConvTranspose1d</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">return</span> weight_norm(nn.ConvTranspose1d(*args, **kwargs))</span><br><span class="line"><span class="comment">#Discriminator Block结构</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NLayerDiscriminator</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ndf, n_layers, downsampling_factor</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        model = nn.ModuleDict()</span><br><span class="line">        <span class="comment">#第一层卷积</span></span><br><span class="line">        model[<span class="string">&quot;layer_0&quot;</span>] = nn.Sequential(</span><br><span class="line">            nn.ReflectionPad1d(<span class="number">7</span>),</span><br><span class="line">            WNConv1d(<span class="number">1</span>, ndf, kernel_size=<span class="number">15</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>, <span class="literal">True</span>),</span><br><span class="line">        )</span><br><span class="line">        nf = ndf</span><br><span class="line">        stride = downsampling_factor</span><br><span class="line">        <span class="comment">#4层4x Downsampling Layer</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, n_layers + <span class="number">1</span>):</span><br><span class="line">            nf_prev = nf</span><br><span class="line">            nf = min(nf * stride, <span class="number">1024</span>)</span><br><span class="line">            model[<span class="string">&quot;layer_%d&quot;</span> % n] = nn.Sequential(</span><br><span class="line">                WNConv1d(</span><br><span class="line">                    nf_prev,</span><br><span class="line">                    nf,</span><br><span class="line">                    kernel_size=stride * <span class="number">10</span> + <span class="number">1</span>,</span><br><span class="line">                    stride=stride,</span><br><span class="line">                    padding=stride * <span class="number">5</span>,</span><br><span class="line">                    groups=nf_prev // <span class="number">4</span>,</span><br><span class="line">                ),</span><br><span class="line">                nn.LeakyReLU(<span class="number">0.2</span>, <span class="literal">True</span>),</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        nf = min(nf * <span class="number">2</span>, <span class="number">1024</span>)</span><br><span class="line">        <span class="comment">#第2层卷积层</span></span><br><span class="line">        model[<span class="string">&quot;layer_%d&quot;</span> % (n_layers + <span class="number">1</span>)] = nn.Sequential(</span><br><span class="line">            WNConv1d(nf_prev, nf, kernel_size=<span class="number">5</span>, stride=<span class="number">1</span>, padding=<span class="number">2</span>),</span><br><span class="line">            nn.LeakyReLU(<span class="number">0.2</span>, <span class="literal">True</span>),</span><br><span class="line">        )</span><br><span class="line">        <span class="comment">#第3层卷积层</span></span><br><span class="line">        model[<span class="string">&quot;layer_%d&quot;</span> % (n_layers + <span class="number">2</span>)] = WNConv1d(</span><br><span class="line">            nf, <span class="number">1</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        self.model = model</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        results = [] <span class="comment">#存放每层输出的feature map</span></span><br><span class="line">        <span class="keyword">for</span> key, layer <span class="keyword">in</span> self.model.items():</span><br><span class="line">            x = layer(x)</span><br><span class="line">            results.append(x)</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line"><span class="comment">#完整的判别器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_D, ndf, n_layers, downsampling_factor</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.model = nn.ModuleDict()</span><br><span class="line">        <span class="comment">#3个Discriminator Block</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num_D):</span><br><span class="line">            self.model[<span class="string">f&quot;disc_<span class="subst">&#123;i&#125;</span>&quot;</span>] = NLayerDiscriminator(</span><br><span class="line">                ndf, n_layers, downsampling_factor</span><br><span class="line">            )</span><br><span class="line">		<span class="comment">#downsample函数</span></span><br><span class="line">        self.downsample = nn.AvgPool1d(<span class="number">4</span>, stride=<span class="number">2</span>, padding=<span class="number">1</span>, count_include_pad=<span class="literal">False</span>)</span><br><span class="line">        self.apply(weights_init)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        results = []</span><br><span class="line">        <span class="keyword">for</span> key, disc <span class="keyword">in</span> self.model.items():</span><br><span class="line">            results.append(disc(x)) <span class="comment">#每次降频处理得到的结果依次存放到result</span></span><br><span class="line">            x = self.downsample(x) <span class="comment">#对输入x进行降频处理</span></span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>TTS</category>
        <category>Fastspeech2</category>
      </categories>
      <tags>
        <tag>TTS</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记-AdaSpeech 2： Adaptive Text to Speech with Untranscribed Data</title>
    <url>/posts/speech-synthesis1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="AdaSpeech-2-Adaptive-Text-to-Speech-with-Untranscribed-Data"><a href="#AdaSpeech-2-Adaptive-Text-to-Speech-with-Untranscribed-Data" class="headerlink" title="AdaSpeech 2: Adaptive Text to Speech with Untranscribed Data"></a>AdaSpeech 2: Adaptive Text to Speech with Untranscribed Data</h2><div class="note info">
            <p>论文链接：<a href="https://arxiv.org/pdf/2104.09715">AdaSpeech 2: Adaptive Text to Speech with Untranscribed Data</a><br>源码：<a href="https://github.com/rishikksh20/AdaSpeech2"></a></p>
          </div>
<h3 id="一-关注问题"><a href="#一-关注问题" class="headerlink" title="一. 关注问题"></a>一. 关注问题</h3><p>​        由于AdaSpeech在合成语音时仅能适配已转录的语音数据，许多场景需要对未转录（无文本标注）的语音数据进行适配，为了扩大自适应TTS的应用场景，因此开发对未转录语音数据进行自适应的TTS系统。<br><a id="more"></a></p>
<h3 id="二-AdaSpeech"><a href="#二-AdaSpeech" class="headerlink" title="二. AdaSpeech"></a>二. AdaSpeech</h3><h4 id="1-模型结构"><a href="#1-模型结构" class="headerlink" title="1. 模型结构"></a>1. 模型结构</h4><p><img src="http://pic.panjiangtao.cn/202111031711_378.png" alt></p>
<p><img src="http://pic.panjiangtao.cn/202111032215_966.png" alt></p>
<p>​        非自回归模型并行生成序列的所有标记，非线性，与自回归(AR)模型相比，生成速度更快，但代价是准确性较低。（引入隐变量z）</p>
<p>​        以非自回归的FastSpeech2作为模型主体框架，包括一个音素编码器、梅尔频谱解码器和一个给音素隐藏序列（phoneme hidden sequence）提供时长、能量、音高等变化信息的方差适配器。在FastSpeech2基础上，增加了两个模块来实现音色定制：</p>
<ol>
<li><p>声学状态建模，捕获适配声音中的丰富声学特征</p>
</li>
<li><p>条件层归一化，用在解码器中降低适配参数量</p>
<p><img src="http://pic.panjiangtao.cn/202111032114_122.png" alt></p>
</li>
</ol>
<ul>
<li><p>scale $\gamma$：尺度向量</p>
</li>
<li><p>bias $\beta$：偏差向量</p>
</li>
<li><p>mean、var：隐藏序列x的均值和方差</p>
<p><img src="http://pic.panjiangtao.cn/202111032132_25.png" alt></p>
</li>
</ul>
<p>W 两个简单线性层，E 说话人嵌入</p>
<p>​        s是说话人ID，c为解码器需要条件归一化的层数。</p>
<p>​        只用到两个简单的线性层，输入是speaker embedding，输出预测γ和β</p>
<h4 id="2-定制语音过程：预训练、微调、推理"><a href="#2-定制语音过程：预训练、微调、推理" class="headerlink" title="2. 定制语音过程：预训练、微调、推理"></a>2. 定制语音过程：预训练、微调、推理</h4><ul>
<li>在预训练阶段，TTS模型在大规模的多扬声器数据集上培训，这可以确保TTS模型涵盖各种文本和讲台有助于适应的声音。</li>
<li>在微调阶段，源TTS模型通过在具有不同声学条件的有限自适应数据上的微调（部分）的微调（一部分）上的新语音。</li>
<li>在推理阶段期间，非适配的参数（由所有自定义语音共享的参数）和TTS模型的适配参数（每个自定义语音具有特定的调整参数）用于推理请求。</li>
</ul>
<h3 id="三、AdaSpeech-2"><a href="#三、AdaSpeech-2" class="headerlink" title="三、AdaSpeech 2"></a>三、AdaSpeech 2</h3><p>​        在AdaSpeech的基本结构（①音素编码器、梅尔频谱解码器）的基础上，加入②梅尔频谱编码器进行语言重建。适配过程：①源模型的训练，预训练一个多说话人TTS模型 ②限制梅尔编码器的输出序列接近音素编码器的输出序列与L2损失，用L2 loss训练一个梅尔编码器让它的输出空间分布接近音素编码器的输出。③训练完梅尔编码器后，用其对未转录语音数据重建语音，并微调梅尔解码器的模型参数。④使用音素编码器和梅尔解码器构造TTS系统合成语音。</p>
<h4 id="1-模型结构-1"><a href="#1-模型结构-1" class="headerlink" title="1. 模型结构"></a>1. 模型结构</h4><p><img src="http://pic.panjiangtao.cn/202110301030_190.jpg" alt="AdaSpeech2结构"></p>
<p> 1）音素编码器（由4个前馈转换器构成）、梅尔频谱解码器（由4个前馈转换器构成）构成TTS管道</p>
<p> 2）单独设立的梅尔频谱编码器，由4个前馈转换器构成</p>
<h4 id="2-适配过程"><a href="#2-适配过程" class="headerlink" title="2. 适配过程"></a>2. 适配过程</h4><p><img src="http://pic.panjiangtao.cn/202110301031_731.jpg" alt="适配步骤"></p>
<p>1）源模型训练过程</p>
<ul>
<li>音素编码器，将音素序列转换为隐藏序列</li>
<li>将隐藏序列根据每个音素的持续时间进行展开，使其匹配梅尔频谱序列长度</li>
<li>将展开后的隐藏序列输入到梅尔解码器</li>
</ul>
<p>2）<strong>梅尔编码器对齐</strong>（本文核心工作，设计一个梅尔频谱编码器在自适应时可以使用无标注的语音数据，并且不影响TTS）</p>
<ul>
<li><p>将使用源转录的语音数据通过梅尔编码器生成隐藏序列</p>
</li>
<li><p>使用长度相同的梅尔编码器生成的隐藏序列，和音素编码器生成的展开隐藏序列，计算L2损失进行训练(有稳定解且只有一个)</p>
<p>$D_{L2}=\sum_{i=1}^n (y_i-f(x_i))^2$</p>
</li>
<li><p>对齐训练时，只训练梅尔编码器的参数，保持TTS管道的参数不变，保证能够可插拔</p>
</li>
</ul>
<p>3）未转录语音自适应</p>
<ul>
<li>未转录数据通过使用梅尔编码器和梅尔解码器进行语音重建，得到预测梅尔频谱，根据该重建的损失来微调模型，使模型加入使用者语音特征</li>
<li>在AdaSpeech中，为了既保证自适应质量同时使微调参数尽可能少，只对和条件层归一化（CLN）有关的参数进行优化</li>
</ul>
<p>4）推理</p>
<ul>
<li>使用原始的未适配音素编码器和部分适配的梅尔解码器形成个性化的 TTS 系统，为每个特定的说话者生成语音</li>
</ul>
]]></content>
      <categories>
        <category>语音合成</category>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>语音合成</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记-Federated Learning： Strategies for Improving Communication Efficiency</title>
    <url>/posts/Federated-Learning2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Federated-Learning-Strategies-for-Improving-Communication-Efficiency"><a href="#Federated-Learning-Strategies-for-Improving-Communication-Efficiency" class="headerlink" title="Federated Learning: Strategies for Improving Communication Efficiency"></a>Federated Learning: Strategies for Improving Communication Efficiency</h2><div class="note info">
            <p>论文链接：<a href="https://arxiv.org/pdf/1610.05492.pdf">Federated Learning: Strategies for Improving Communication Efficiency</a></p>
          </div>
<h3 id="一、本文关注的问题"><a href="#一、本文关注的问题" class="headerlink" title="一、本文关注的问题"></a>一、本文关注的问题</h3><p>在典型的联邦学习案例中，由于更新体量较大且上传速率普遍较低，客户端向中央服务器上传更新成为瓶颈，所以需要降低更新$H_t^i$的上行通信成本。<br><a id="more"></a></p>
<h3 id="二、提出的方法"><a href="#二、提出的方法" class="headerlink" title="二、提出的方法"></a>二、提出的方法</h3><ol>
<li><p>结构化更新：将每个客户端的更新$H_t^i$限制为具有预先指定的结构，分别为低秩和随机掩码。</p>
<ul>
<li>低秩：将每个更新$H_t^i\in\R^{d_1×d_2}$强制为秩至多为k的矩阵，因此将$H_i$拆分为两个矩阵乘积$H_t^i=A_t^iB_t^i$，其中$A_t^i\in R^{d_1×k}$，$B_t^i\in R^{k×d_2}$。在本地训练时，为每个客户端独立随机生成$A_t^i$并看作常量，只优化$B_t^i$并上传，使通讯成本降低$\frac{d_1}k$倍。</li>
<li>随机掩码：使用预定义随机稀疏规则通过每个客户端独立的随机种子将更新$H_t^i$转换为稀疏矩阵，并向服务器发送$H_t^i$的非零条目和种子。</li>
</ul>
</li>
<li><p>草图更新：无限制地完成完整本地训练得到更新$H_t^i$，在上传服务器前对其编码以压缩格式，在服务器聚合前解码。使用下列工具进行草图绘制：</p>
<ul>
<li><p>子采样：客户端发送更新$H_t^i$的随机子集$\hat H_t^i$，服务器对子采样更新进行平均，得到全局更新$\hat H_t$。这样做可以使采样更新的平均值是真实平均值的无偏估计量：$\Bbb E [\hat H_t] = H_t$。</p>
</li>
<li><p>概率量化：将更新$H_t^i$展开成一位向量（也可以是b位向量），即$h=(h_1,…,h_{d_1×d_2})=vec(H_t^i)$，设$h_{max}=max_j(h_j),h_{min}=min_j(h_j)$，h的压缩表示为$\hat h$，公式如下：</p>
<script type="math/tex; mode=display">
\hat h_j=
\left \{
\begin{array}{c}
h_{max},\ with\ probability \frac{h_j-h_{min}}{h_{max-h_{min}}}\\
h_{min},\ with\ probability \frac{h_{max}-h_j}{h_{max-h_{min}}}
\end{array}
\right.</script><p>该方法在$H_t^i$不同维度上规模相近时效果最佳</p>
</li>
<li><p>结构化随机旋转改进量化：上述概率量化方法在max=1和min=-1且大部分值为0时误差较大，可以在量化前对h应用一次随机旋转（将h乘以随机正交矩阵）。</p>
</li>
</ul>
</li>
</ol>
<h3 id="三、取得的结果"><a href="#三、取得的结果" class="headerlink" title="三、取得的结果"></a>三、取得的结果</h3><ol>
<li>利用CNN和人工区分数据集对CIFAR-10图像分类任务进行实验。<ul>
<li>对比两种结构化更新方法，即低秩和随机掩码。图中显示降低更新矩阵的秩时，低秩方法通信效率提高不明显；而增加随机掩码生成的稀疏矩阵的稀疏性时，可以达到较好的降低更新的效果。</li>
<li>对比随机掩码和草图更新，使用草图更新可以更快地获得一个适度的准确率(85%)，但是使用随机掩码可以收敛到更高的准确率。</li>
<li>对比草图更新的三种形式，即子采样、概率量化和随机旋转。随机旋转可以提高算法的稳定性和性能，使用2比特量化可以获得更好的收敛效果和准确率。</li>
</ul>
</li>
<li>使用指定草图的各种参数对Reddit帖子数据运行联邦平均算法进行下一词预测实验。<ul>
<li>每次随机抽取50个用户的数据进行2000轮训练，子采样比例设为0.1或1。随机旋转可以提高预测准确性，且随机化的阿达玛变换与2比特量化不会损失性能。</li>
<li>固定训练轮数为500和2500轮，只改变单轮客户端数量，使用1比特量化，子采样率分别为1%和10%，运行联邦平均算法。可以看到，每轮客户端数量足够多时，子采样率降低对准确性下降的影响几乎可忽略。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>联邦学习</category>
      </categories>
      <tags>
        <tag>联邦学习</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记-Measuring the Effects of Non-Identical Data Distribution for Federated Visual Classification</title>
    <url>/posts/Federated-Learning3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Measuring-the-Effects-of-Non-Identical-Data-Distribution-for-Federated-Visual-Classification"><a href="#Measuring-the-Effects-of-Non-Identical-Data-Distribution-for-Federated-Visual-Classification" class="headerlink" title="Measuring the Effects of Non-Identical Data Distribution for Federated Visual Classification"></a>Measuring the Effects of Non-Identical Data Distribution for Federated Visual Classification</h2><div class="note info">
            <p>论文链接：<a href="https://arxiv.org/pdf/1909.06335.pdf">Measuring the Effects of Non-Identical Data Distribution for Federated Visual Classification</a></p>
          </div>
<h3 id="一、本文关注的问题"><a href="#一、本文关注的问题" class="headerlink" title="一、本文关注的问题"></a>一、本文关注的问题</h3><p>非同分布的数据对联邦学习模型的准确性可能有较大影响，需要对其进行优化。<br><a id="more"></a></p>
<h3 id="二、提出的方法"><a href="#二、提出的方法" class="headerlink" title="二、提出的方法"></a>二、提出的方法</h3><ol>
<li><p>合成非同分布客户端数据：由一个向量<strong>q</strong>将所有数据参数化为N个类，(其中$q_i\ge0$,$i\in[1,N]$ 且 $||\mathtt q||_1=1$)。从狄利克雷分布中得到<strong>q</strong>~Dir($\alpha$<strong>p</strong>)，其中<strong>p</strong>表示N个类上的先验类分布，$\alpha&gt;0$是控制客户端数据同一性的参数。$\alpha \to \infty$时所有客户端的类分布相同；$\alpha \to 0$时，每个客户端只有一个随机类的样本。随机生成30个客户端，N为10，给定不同的$\alpha$值对<strong>q</strong>进行采样，得到下图分布情况。</p>
<p><img src="http://pic.panjiangtao.cn/202110301020_281.jpg" alt="生成数据"></p>
</li>
<li><p>FedAvgM算法：联邦平均算法中，通过$w\leftarrow w-\Delta w$更新梯度，其中$\Delta w=\sum_{k-1}^K\frac{n_k}n\Delta w_k$，$\Delta w_k$是第k个客户端的梯度更新。将动量加入算法以抑制震荡，改为计算$v\leftarrow \beta v+\Delta w$，其中$\beta \in \{0,0.7,0.9,0.97,0.99,0.997\}$，模型更新变为$w\leftarrow w-v$。称该算法为基于服务器动量的联邦平均算法。</p>
</li>
</ol>
<h3 id="三、取得的结果"><a href="#三、取得的结果" class="headerlink" title="三、取得的结果"></a>三、取得的结果</h3><ol>
<li>$\alpha$较小时其变化对模型准确度影响较大，报告比例C和同步频率对性能影响不大。$\alpha$较小时，训练错误的波动性更大，且很难收敛。</li>
<li>C和$\alpha$较小时训练对超参数更敏感。</li>
<li>$\alpha$较小时，使用基于动量的联邦平均算法使得模型准确性具有显著提高。</li>
<li>定义有效学习率$\eta_{eff}=\eta/(1-\beta)$，报告比例C较大时$\eta_{eff}$的可选范围更大，降低学习率$\eta$提高动量$\beta$以降低$\eta_{eff}$可以防止客户端更新偏离。</li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>联邦学习</category>
      </categories>
      <tags>
        <tag>联邦学习</tag>
      </tags>
  </entry>
  <entry>
    <title>论文笔记-Communication-Efficient Learning of Deep Networks from Decentralized Data</title>
    <url>/posts/Federated-Learning1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="Communication-Efficient-Learning-of-Deep-Networks-from-Decentralized-Data"><a href="#Communication-Efficient-Learning-of-Deep-Networks-from-Decentralized-Data" class="headerlink" title="Communication-Efficient Learning of Deep Networks from Decentralized Data"></a>Communication-Efficient Learning of Deep Networks from Decentralized Data</h2><div class="note info">
            <p>论文链接：<a href="https://arxiv.org/abs/1602.05629">Communication-Efficient Learning of Deep Networks from Decentralized Data</a></p>
          </div>
<h3 id="一、本文关注的问题"><a href="#一、本文关注的问题" class="headerlink" title="一、本文关注的问题"></a>一、本文关注的问题</h3><ol>
<li>移动设备上的数据由于隐私问题、数据量大的原因无法作为模型训练集</li>
<li>参与优化的数据具有非独立同分布、数量不平衡、大规模、通信受限的问题<a id="more"></a>
</li>
</ol>
<h3 id="二、提出的方法"><a href="#二、提出的方法" class="headerlink" title="二、提出的方法"></a>二、提出的方法</h3><p>联邦学习：将训练数据分布在移动设备上，由中央服务器协调聚合每台设备本地数据计算的更新来学习共享模型，无需直接访问原始数据。</p>
<ol>
<li><p>通过下述方法减小通信轮数</p>
<ul>
<li><p>增加并行性，使用更多的客户端在每个通信轮之间独立工作</p>
</li>
<li><p>增加了每个客户端的计算量</p>
</li>
</ul>
</li>
<li><p>使用联邦平均算法进行优化：将每个客户端上的局部随机梯度下降 (SGD) 与执行模型平均的服务器相结合，得到FedAvg方法，以FedSGD作为基线进行对比</p>
<ul>
<li><p>联邦优化：对于机器学习任务，我们取$ f_i(w)=l(x_i,y_i;w)$,代表模型参数w对实例$(x_i,y_i)$的预测损失，假设有K个包含不同数据的客户端，有数据点的索引集$P_k$,设$N_k=|P_k|$,则联邦平均算法适用于以下形式的任何有限和目标：</p>
<p><script type="math/tex">f(w)=\sum_{K=1}^K{\frac{n_k}nF_k(w)}</script>            where           $F_k(w)=\frac1{n_k}\sum_{i\in{P_k}}f_i(w)$</p>
</li>
<li><p>FedAvg算法：</p>
<ul>
<li><p>流程：对于每个客户端k，全选数据且固定学习率为$\eta$，计算本地数据在当前模型$w_t$上的平均梯度$g_k=\nabla{F_k(w_t)}$，中央服务器接收这些梯度且应用更新$w_{t+1}\leftarrow w_t-\eta\sum_{k-1}^K\frac{n_k}ng_k$，其中$\sum_{k-1}^K\frac{n_k}ng_k=\nabla{f(w_t)}$。这等效于以下更新：$\forall k,w_{t-1}^k\leftarrow w_t-\eta g_k$和$w_{t+1}\leftarrow \sum_{k-1}^K\frac{n_k}n w_{t+1}^k$。每个客户端可以使用本地数据进行多次迭代更新$w_k\leftarrow w_k−η\nabla F_k(w_k)$后交由服务器进行加权平均。计算量由三个关键参数控制:C，每轮执行计算的客户端比例;E，每轮每个客户端通过其本地数据集的训练次数;B，用于客户端更新的本地迷你批处理大小。</p>
</li>
<li><p>伪代码：其中K个服务器的索引为k，B为本地批大小，E为本地训练次数，$\eta$为学习率</p>
<hr>
<p><strong>Server executes</strong>:</p>
<pre><code>initialize $w_0$
**for** each round t= 1,2, . . .**do**
    $m←max(C·K,1)$
    $S_t←$ (random set of $m$ clients)
    **for** each client $k∈S_t$ **in parallel do**
        $w^k_&#123;t+1&#125;$←ClientUpdate$(k, w_t)$
    $w_&#123;t+1&#125;\leftarrow \sum_&#123;k-1&#125;^K\frac&#123;n_k&#125;n w_&#123;t+1&#125;^k$
</code></pre><p><strong>ClientUpdate</strong>$(k, w)$://Run on clientk</p>
<pre><code>B ←(split $P_k$ into batches of size B)
**for** each local epoch $i$ from 1 to E**do**
    **for** batch b∈ B do
        $w←w−η\nabla l(w;b)$
return $w$ to server
</code></pre><hr>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="三、取得的结果"><a href="#三、取得的结果" class="headerlink" title="三、取得的结果"></a>三、取得的结果</h3><ol>
<li>图像识别中，增加并行性对减小通讯次数提升不明显，只能加速10倍以内</li>
<li>语言建模中，在莎士比亚合集中使用FedAvg算法增加客户端计算量对于非IID和不平衡数据具有较大的通信轮次下降，加速95倍</li>
<li>在CIFAR数据集中使用FedAvg算法相较于基线SGD算法只需1/99的通信轮数就可达到相同的准确率</li>
<li>在大规模下一词预测任务中，FedAvg算法相较于基线FedSGD算法只需1/23的通信轮数就可达到相同的准确率</li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
        <category>联邦学习</category>
      </categories>
      <tags>
        <tag>联邦学习</tag>
      </tags>
  </entry>
  <entry>
    <title>网络货运优惠政策</title>
    <url>/posts/net-freight/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="网络货运优惠政策"><a href="#网络货运优惠政策" class="headerlink" title="网络货运优惠政策"></a>网络货运优惠政策</h1><p>　　网络货运是在利用互联网技术开发的车货匹配平台的基础上发展起来的，通过互联网平台加数字化技术引用，在大数据的介入下，促使货运全网互联互通，借助智慧物流模式进行行业升级。<br>　　交通部重点强调全面贯彻、坚持发展的“互联网+”高效物流，通过发展网络货运，推动解决道路货运行业多年来积累的深层次矛盾和问题，有效解决货运经营者在配货理货方面的操心事、运费结算方面的烦心事、税收保险方面的揪心事。<br>　　从事网络货运经营的，是指经营者依托互联网平台整合配置运输资源，以承运人身份与托运人签订运输合同，委托实际承运人完成道路货物运输，承担承运人责任的道路货物运输经营活动<br><a id="more"></a></p>
<h2 id="1-甘肃金昌"><a href="#1-甘肃金昌" class="headerlink" title="1.甘肃金昌"></a>1.甘肃金昌</h2><p>　　近日，甘肃省印发了<strong>《网络平台道路货物运输经营管理实施细则（暂行）》</strong>（以下简称《细则》），对网络货运经营许可的准入和退出程序、管理部门的监督检查等提出了明确要求，给新业态规范健康发展创造良好的制度环境。</p>
<p>　　此前全国已有18省2市相继出台了网络货运相关政策，各地为抢抓机遇，不少地方政府出台了很多前所未有的支持政策，比如贵州省将网络货运列为“交通强国”的试点项目重点扶持；甘肃省金昌市专门建设了网络货运线上数字产业园；天津市为网络货运上线了一个税务合规平台……</p>
<p>　　值得关注的是，金昌在甘肃省《细则》出台之前就已启动了线上网络货运数字产业园建设，针对网络货运企业的优惠扶持力度也已出台，以其优质的服务和扶持政策，拉开了西部地区网络货运的大幕。</p>
<p>　　金昌市位于甘肃省河西走廊东段，处于西部五省的核心位置，是甘肃省发展物流产业的重要节点和连接国家东、西部重要物流通道，地理位置优越。另外，金昌市地质灾害少，气候低温少雨，有适合大数据产业和网络货运新业态发展的先天优势。</p>
<p>　　而金昌早在2017年就已经开始大数据产业布局，建设了紫金云大数据中心，近期又与阿帕数字共同建设了线上数字产业园项目。</p>
<p>　　金昌作为资源型城市，有着巨大的运输需求的同时，也存在着运输“出多进少”的不均衡问题，而通过网络货运不但可以解决这个问题，同时还把数字产业引入了金昌，将来可依托数字产业园，实现“车在线上、货在云中”。</p>
<p>　　<strong>金昌市投巨资建设了“骠骑网络货运管理系统”，免费提供给入驻企业使用。</strong>同时，应用区块链技术研发的“星水大数据监管平台”，打通了市场监管、交通、税务、财政等系统数据，对接省部级监管平台，缩短企业单独对接时长，实现税款的缴纳、统计与返还，对相关信息进行查询追踪、设立风险指标监控风险情况，可以极大地优化申报流程、减少对接时长、提高办理效率、节约申报成本，为企业省心、省力、更省钱！</p>
<p>　　根据网络货运管理办法，一家物流企业想要正式转型网络货运平台，从系统开发、技术储备、资料整理、与政府部门沟通对接到获得网络货运许可证，完全按此流程跑一遍，时间大约需要3-6个月，投入一般在50万-100万。</p>
<p><img src="https://pic3.zhimg.com/80/v2-313531c847e1c07f96173cdf45280d4a_720w.jpg" alt="img">网络货运办理流程</p>
<p>　　金昌数字产业园把等保认证企业、ICP办理企业都联系入园，实现在线服务，入驻企业3个工作日便可以拿到营业执照，30天就能拿到网络货运许可证。更值得一提的是，园区对年营业额超亿元的网络货运企业给予ICP、等保三级最高补贴100%的优惠政策。</p>
<p>　　同时，所有办公场所、设备、桌椅等全部免费为企业提供，这对企业来说，金昌可谓是为其准备了“一桌大餐”。</p>
<p>　　财税合规物流企业在网络货运上最敏感的神经还是在财税方面：如何实现财税合规？最终企业实际税负是多少？</p>
<p>　　<strong>金昌市对于入园企业给予5年培育期，发展数字产业，实行增值税、企业及个人所得税返还市区两级财政留存部分最高可达98%，司机个人所得税按照国家最低税率0.25%征收。</strong></p>
<p>　　同时，公司财务记账、发票代开、税务处理等日常财务代理，园区更是提供一站式服务。</p>
<h3 id="运营支持"><a href="#运营支持" class="headerlink" title="运营支持"></a>运营支持</h3><p>　　为方便前期项目接洽，<strong>金昌数字产业园在北京成立了招商中心，成立专业的招商服务队伍，针对网络货运企业定向服务，实行一套班子两个职能，面对企业进行招商，面对人才提供服务。</strong></p>
<p>　　截止目前，已成功举办了两次金昌网络货运招商视频会议，参会企业达到152家，十余家企业正在积极洽谈沟通。</p>
<p>　　在我国，制约物流企业做大做强的重要因素之一在于绝大多数民营物流企业普遍存在资金链偏紧，特别是上游押款严重、账期越来越长，而下游又需要即时支付甚至提前支付，这使得资金链紧张的局面又进一步加剧。</p>
<p>　　与此同时，与制造企业相比，中小民营物流企业又因为固定资产少、可抵（质）押物受限、经营风险高、信用低且征信难等特性难以获得金融机构融资，导致最需要周转资金的中小物流企业反而最难获取周转资金融。</p>
<p>　　<strong>对此，金昌数字产业园联合蚂蚁金服、普洛斯金融以及当地金融机构通过区块链监管平台帮助物流企业进行运费垫付、运费保理、ETC垫资、油费垫资。</strong></p>
<p>　　目前可为每家物流企业最高授信额度运费保理2亿元、运费垫付500万、过路费垫付50万、ETC垫资50万、油气垫资20万，可有效解决物流企业融资难、融资贵的问题。</p>
<p>　　不得不说，金昌市为了推动网络货运新业态的发展，可谓下足了功夫、用足了真心。毕竟，政府只有搭好了“梧桐树”，才能留得住“金凤凰”。</p>
<h2 id="２-湖北"><a href="#２-湖北" class="headerlink" title="２.湖北"></a>２.湖北</h2><p>　　从湖北省运管局获悉，目前，湖北省普通货运车辆超过40万辆，道路货运是综合交通运输体系的重要组成部分，在国民经济发展中起着重要的基础服务作用。近日（18.12.04），湖北省运管局制定出台了<strong>《关于促进道路货运行业健康发展的八条意见》</strong>，以切实减轻道路货运经营者负担，改善从业环境，促进降本增效，努力推动道路货运行业健康稳定发展。</p>
<p>　　一是优化货运行政许可。实行“三取消一限时”：从2019年1月1日起，取消道路货运站场经营许可、取消总质量4.5吨及以下普通货物运输车辆《道路运输证》、取消总质量4.5吨及以下普通货物运输车辆驾驶员《从业资格证》，普通货物运输经营许可审批在15个工作日内限时办结。</p>
<p>　　二是优化货运车辆管理。全面实施本省籍道路货物运输车辆安检、综检、环保检“三检合一”；全面推进本省籍普通货物运输车辆省内异地年审。</p>
<p>　　三是优化货运从业人员管理。推行普通货运道路运输驾驶员从业线上线下及异地考试；全面推进本省籍货运道路运输驾驶员异地考核；全面公开普通货运道路运输驾驶员从业考试题库；鼓励社会化平台开展从业人员继续教育服务。</p>
<p>　　四是落实货运企业主体责任。督促道路货运企业建立健全企业管理制度，规范相关合同，强化车辆、人员等日常管理，落实安全生产主体责任，落实从业人员的管理与服务责任，落实规范经营行为、保障合法权益的社会责任。充分发挥道路运输行业社会中介组织的行业自律作用。</p>
<p>　　<strong>五是支持无车承运人发展。支持国内无车承运人平台落户本省。鼓励本省普通货物运输经营者加入无车承运人平台。支持无车承运人平台为普货运输经营者提供货源、仓储、线路等大数据信息和全链条服务。</strong></p>
<p>　　六是鼓励应用智能视频监控技术。鼓励货运企业应用4G视频监控、高级驾驶辅助、驾驶行为分析等车载新技术、新设备，加强对车辆运行状况、驾驶员驾驶行为、承运货物在途情况的监督管理，为社会提供更加优质、安全的货运服务。</p>
<p>　　七是推进诚信体系建设。结合“信用交通省”创建工作,推进道路货运行业诚信建设，实行道路运输行业信用红黑名单制度，形成“守信时时便利、失信处处受限”的良好经营环境。</p>
<p>　　八是自觉接受社会监督。加强道路货运行业政策法规宣传，全面公开道路货运经营许可政策、行业管理政策，主动公示审批程序、受理条件和办理时限，全面推行网上办事、实行限时办结、主动做好服务、接受社会监督。构建亲清新型政商关系，严禁运管机构私设门槛、引导个体司机挂靠经营、隐性变相“吃拿卡要”等行为，严肃问责相关责任人，维护公平公正市场环境。</p>
<p>　　省运管局要求，全省各级运管机构提高思想认识、加强政策宣传、切实履行职责，及时将八条意见传达到货运企业和广大驾驶员，做好服务指导，确保执行到位。</p>
<h2 id="3-湖南长沙"><a href="#3-湖南长沙" class="headerlink" title="3. 湖南长沙"></a>3. 湖南长沙</h2><p>　　湖南日报·新湖南客户端2月20日讯（记者 陈新）为支持长沙市道路货运企业复工复产，促进网络货运业发展壮大，记者今天从长沙市交通运输局获悉，近日长沙市交通运输局会同该市财政局、市税务局联合制发了<strong><a href="http://jtt.hunan.gov.cn/xxgk/gzdt/szdt1/202002/t20200224_11189518.html">《支持网络货运业发展的财税奖补政策实施办法》</a></strong>，支持长沙市网络货运经营企业规模化发展，提升货物运输组织效率，降低物流成本，促进货运物流行业转型升级，提升道路货运业对经济增长的支撑作用，服务货运物流畅通和稳岗经济发展大局。</p>
<p>　　《办法》规定，支持网络货运经营企业开展代开增值税发票试点。指导企业申报和获得“互联网物流平台企业代开增值税专用发票”资质。根据企业网络货运经营业务实缴税收规模情况，实施奖励，支持企业扩大再生产和规模化经营。同时，支持网络货运经营企业为小规模纳税人代缴税收。为网络货运经营企业提供实际货物运输服务的会员（小规模纳税人），鼓励网络货运经营企业代其向主管税务机关缴纳运输业务增值税，申请代开专用发票，并据以抵扣相应运输业务的进项税额。根据代缴税收情况，实施奖励，支持小规模货运经营业户稳定发展。</p>
<p>　　另外，《办法》支持网络货运经营企业规模化发展。针对取得网络货运经营许可资质的原部省“无车承运人”试点企业等给予10万元至30万元的奖励。针对取得交通运输部门颁发的经营范围为“网络货运”的道路运输经营许可企业，经年度考核合格，且综合监测评估排名进入国家、省、市前列的，给予5万元至30万元的奖励。</p>
<h2 id="4-陕西西安"><a href="#4-陕西西安" class="headerlink" title="4.陕西西安"></a>4.陕西西安</h2><p>　　3月11日，市发改委印发《西安市大力发展“三个经济”支持政策实施细则》的通知（以下简称细则），包括21条支持政策</p>
<p>　　<strong>第5条：对在西安市注册且接入省道路货物运输监管平台的无车承运人试点企业(网络平台道路货物运输经营者)，给予其所缴纳增值税35%的等额资金奖励。(牵头单位：市交通局配合单位：市商务局、市财政局)</strong></p>
<p>　</p>
]]></content>
      <categories>
        <category>物流管理</category>
        <category>网络货运</category>
      </categories>
      <tags>
        <tag>网络货运</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark基本架构和原理</title>
    <url>/posts/spark1-basic/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>参考资料：<a href="https://www.jianshu.com/p/e41b18a7e202">Spark基本概念快速入门</a>，<a href="https://zhuanlan.zhihu.com/p/95622176">Spark基础知识（一）—-常用组建和RDD</a>，<a href="https://www.cnblogs.com/cxxjohnson/p/8909578.html">Spark(一): 基本架构及原理</a>，<a href="https://blog.csdn.net/c391183914/article/details/78672555#12-spark%E7%89%B9%E7%82%B9">Spark 入门和使用</a></p>
          </div>
<p>　　目前，Spark生态系统已经发展成为一个包含多个子项目的集合，其中包含Spark SQL、Spark Streaming、GraphX、MLib、SparkR等子项目，Spark是基于内存计算的大数据并行计算框架。除了<strong>扩展了广泛使用的 MapReduce 计算模型</strong>，而且高效地支持更多计算模式，包括<strong>交互式查询和流处理</strong>。<br><a id="more"></a></p>
<p>　　<strong>适用场景</strong>：Spark 适用于各种各样原先需要多种不同的分布式平台的场景，包括<strong>批处理、迭代算法、交互式查询、流处理</strong>。通过在一个统一的框架下支持这些不同的计算，Spark 使我们可以简单而低耗地把各种处理流程整合在一起。而这样的组合，在实际的数据分析 过程中是很有意义的。不仅如此，Spark 的这种特性还大大减轻了原先需要对各种平台分 别管理的负担。</p>
<h3 id="一、基本架构"><a href="#一、基本架构" class="headerlink" title="一、基本架构"></a>一、基本架构</h3><p><img src="http://pic.panjiangtao.cn/202110271945_212.png" alt></p>
<h4 id="1-Spark-Core核心和弹性分布式资料集（RDD）"><a href="#1-Spark-Core核心和弹性分布式资料集（RDD）" class="headerlink" title="1. Spark Core核心和弹性分布式资料集（RDD）"></a>1. Spark Core核心和弹性分布式资料集（RDD）</h4><p>　　Spark Core是整个项目的基础，提供了分布式任务调度，调度和基本的I／O功能，<strong>包含任务调度、内存管理、错误恢复、与存储系统交互</strong>等模块。而其基础的程序抽象则称为弹性分布式资料集（RDD），是一个可以<strong>并行操作、有容错机制的资料集合</strong>。 Spark Core定义RDD的API、操作以及这两者上的动作。RDD可以透过引用外部存储系统的资料集创建（例如：共享文件系统、HDFS、HBase或其他 Hadoop 资料格式的数据源）。或者是通过在现有RDD的转换而创建（比如：map、filter、reduce、join等等）。</p>
<h4 id="2-Spark-SQL"><a href="#2-Spark-SQL" class="headerlink" title="2. Spark SQL"></a>2. Spark SQL</h4><p>　　Spark SQL在Spark核心上带出一种名为<strong>SchemaRDD</strong>的资料抽象化概念，提供结构化和半结构化资料相关的支持。Spark SQL提供了领域特定语言，可使用<strong>Scala、Java或Python</strong>来操纵SchemaRDD。它还支持使用使用命令行界面和<strong>ODBC／JDBC</strong>服务器操作SQL语言。在Spark 1.3版本，SchemaRDD被重命名为DataFrame。</p>
<h4 id="3-Spark-Streaming"><a href="#3-Spark-Streaming" class="headerlink" title="3. Spark Streaming"></a>3. Spark Streaming</h4><p>　　Spark Streaming充分利用Spark核心的快速调度能力来运行<strong>流分析</strong>。它截取小批量的资料并对之运行RDD转换。这种设计使流分析可在同一个引擎内使用同一组为批量分析编写而撰写的应用程序代码。</p>
<h4 id="4-MLlib"><a href="#4-MLlib" class="headerlink" title="4. MLlib"></a>4. MLlib</h4><p>　　MLlib是Spark上的<strong>分布式机器学习框架</strong>。Spark分布式存储器式的架构比Hadoop磁盘式的Apache Mahout快上10倍，扩展性甚至比Vowpal Wabbit要好。MLlib可使用许多常见的机器学习和统计算法，简化大规模机器学习时间，其中包括：</p>
<ul>
<li>汇总统计、相关性、分层抽样、假设检定、随机数据生成</li>
<li>分类与回归：支持向量机、回归、线性回归、逻辑回归、决策树、朴素贝叶斯</li>
<li>协同过滤：ALS</li>
<li>分群：k-平均算法</li>
<li>维度约减：奇异值分解（SVD），主成分分析（PCA）</li>
<li>特征提取和转换：TF-IDF、Word2Vec、StandardScaler</li>
<li>最优化：随机梯度下降法（SGD）、L-BFGS</li>
</ul>
<h4 id="5-GraphX"><a href="#5-GraphX" class="headerlink" title="5. GraphX"></a>5. GraphX</h4><p>　　GraphX是Spark上的<strong>分布式图形处理框架</strong>。它提供了一组API，可用于表达图表计算并可以模拟Pregel抽象化。GraphX还对这种抽象化提供了优化运行。</p>
<h4 id="6-集群管理器"><a href="#6-集群管理器" class="headerlink" title="6. 集群管理器"></a>6. 集群管理器</h4><p>　　Spark 设计为可以高效地在一个计算节点到数千个计算节点之间<strong>伸缩计算</strong>。为了实现这样的要求，同时获得最大灵活性，Spark 支持在各种集群管理器(cluster manager)上运行，包括 <strong>Hadoop YARN、Apache Mesos</strong>，以及 Spark 自带的一个简易调度器，叫作<strong>独立调度器</strong>。</p>
<ol>
<li>Standalone : spark原生的资源管理，由Master负责资源的分配</li>
<li>Apache Mesos:与hadoop MR兼容性良好的一种资源调度框架</li>
<li>Hadoop Yarn: 主要是指Yarn中的ResourceManager</li>
</ol>
<h3 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h3><h4 id="1-Spark集群"><a href="#1-Spark集群" class="headerlink" title="1. Spark集群"></a>1. Spark集群</h4><p>　　一组计算机的集合，每个计算机节点作为独立的计算资源，又可以虚拟出多个具备计算能力的虚拟机，这些虚拟机是集群中的计算单元。Spark的核心模块专注于调度和管理虚拟机之上分布式计算任务的执行，集群中的计算资源则交给Cluster Manager这个角色来管理，Cluster Manager可以为自带的Standalone、或第三方的Yarn和Mesos。<br>　　Cluster Manager一般采用Master-Slave结构。以Yarn为例，部署ResourceManager服务的节点为<strong>Master</strong>，负责集群中所有计算资源的统一管理和分配；部署NodeManager服务的节点为<strong>Slave</strong>，负责在当前节点创建一个或多个具备独立计算能力的JVM（Java虚拟机）实例，在Spark中，这些节点也叫做<strong>Worker</strong>。<br>　　另外还有一个<strong>Client</strong>节点的概念，是指用户提交Spark Application时所在的节点。</p>
<h4 id="2-Application"><a href="#2-Application" class="headerlink" title="2. Application"></a>2. Application</h4><p>　　用户<strong>自己写的Spark应用程序</strong>，批处理作业的集合。Application的main方法为应用程序的入口，用户通过Spark的API，定义了RDD和对RDD的操作。</p>
<h4 id="3-SparkContext"><a href="#3-SparkContext" class="headerlink" title="3. SparkContext"></a>3. SparkContext</h4><p>　　Spark最重要的API，<strong>用户逻辑与Spark集群主要的交互接口</strong>，它会和Cluster Master交互，包括向它申请计算资源等。</p>
<h4 id="4-Driver和Executor"><a href="#4-Driver和Executor" class="headerlink" title="4. Driver和Executor"></a>4. Driver和Executor</h4><p><img src="http://pic.panjiangtao.cn/202110281440_941.png" alt></p>
<p>Spark在执行每个Application的过程中会启动<strong>Driver和Executor</strong>两种JVM进程：</p>
<ul>
<li>Driver进程为主控进程，负责执行用户Application中的main方法，提交Job，并将Job转化为Task，在各个Executor进程间协调Task的调度。</li>
<li>运行在Worker上的Executor进程负责执行Task，并将结果返回给Driver，同时为需要缓存的RDD提供存储功能。</li>
<li>Cluster Manager：在standalone模式中即为Master主节点，控制整个集群，监控worker。在YARN模式中为资源管理器。</li>
<li>Worker节点：从节点，负责控制计算节点，启动Executor或者Driver。</li>
</ul>
<h4 id="5-RDD"><a href="#5-RDD" class="headerlink" title="5. RDD"></a>5. RDD</h4><p>　　<strong>RDD</strong>（Resilient Distributed Dataset）叫做弹性分布式数据集，是Spark中最基本的数据抽象，它代表一个<strong>不可变、可分区、里面的元素可并行计算</strong>的集合。RDD具有数据流模型的特点：<strong>自动容错、位置感知性调度和可伸缩性</strong>。RDD允许用户在执行多个查询时显式地将工作集缓存在内存中，后续的查询能够重用工作集，这极大地提升了查询速度。RDD的原理和组成如下图：</p>
<p><img src="http://pic.panjiangtao.cn/202110271956_606.png" alt></p>
<p>（1）<strong>一组分区（Partition</strong>），即数据集的基本组成单位。对于RDD来说，每个分片都会被一个计算任务处理，并决定并行计算的粒度。用户可以在创建RDD时<strong>指定RDD的分片个数</strong>，如果没有指定，那么就会采用默认值。默认值就是程序所分配到的CPU Core的数目。<u>图中指数据集中的每句话经过第二个函数被分割为单词（由第一个RDD到第二个RDD完成分割）</u>。</p>
<p>（2）一个计算每个分区的函数。Spark中RDD的计算是以分片为单位的，<strong>每个RDD都会实现compute函数以达到这个目的</strong>。compute函数会对迭代器进行复合，不需要保存每次计算的结果。<u>图中表示为上方红色的处理函数</u>。Spark中的计算可以简单抽象为对RDD的<strong>创建、转换和返回操作结果</strong>的过程：</p>
<ul>
<li>创建<br>通过<strong>加载外部</strong>物理存储（如HDFS）中的<strong>数据集</strong>，或Application中<strong>定义的对象集合</strong>（如List）来创建。RDD在创建后不可被改变，只可以对其执行下面两种操作。</li>
</ul>
<ul>
<li>转换（Transformation）<br>对已有的RDD中的数据执行计算进行转换，而<strong>产生新的RDD</strong>，在这个过程中有时会产生中间RDD。Spark对于Transformation采用惰性计算机制，遇到Transformation时并不会立即计算结果，而是要等遇到Action时一起执行。</li>
<li>行动（Action）<br>对已有的RDD中的数据执行计算产生结果，<strong>将结果返回Driver程序</strong>或写入到外部物理存储。在Action过程中同样有可能生成中间RDD。</li>
</ul>
<p>（3）RDD之间的依赖关系(Dependency)。<strong>RDD的每次转换都会生成一个新的RDD，所以RDD之间就会形成类似于流水线一样的前后依赖关系</strong>。在部分分区数据丢失时，Spark可以通过这个依赖关系重新计算丢失的分区数据，而不是对RDD的所有分区进行重新计算。<u>图中每个RDD经过函数的计算产生新的RDD</u>。</p>
<p>对RDD的Transformation或Action操作，让RDD产生了<strong>父子依赖关系</strong>（事实上，Transformation或Action操作生成的中间RDD也存在依赖关系），这种依赖分为宽依赖和窄依赖两种：</p>
<ul>
<li>NarrowDependency (窄依赖)<br>parent RDD中的<strong>每个Partition最多被</strong>child RDD中的<strong>一个Partition使用</strong>。让RDD产生窄依赖的操作可以称为窄依赖操作，如map、union。</li>
<li>WideDependency (或ShuffleDependency，宽依赖）<br>parent RDD中的每个Partition被child RDD中的<strong>多个Partition使用</strong>，这时会依据Record的key进行<strong>数据重组</strong>，这个过程即为<strong>Shuffle</strong>（洗牌）。让RDD产生宽依赖的操作可以称为宽依赖操作，如reduceByKey, groupByKey。</li>
</ul>
<p>（4）一个<strong>Partitioner</strong>，即RDD的分区函数。当前Spark中实现了<strong>两种类型的分区函数，一个是基于哈希的HashPartitioner，另外一个是基于范围的RangePartitioner。</strong>只有对于key-value的RDD，才会有Partitioner，非key-value的RDD的Parititioner的值是None。Partitioner函数不但决定了RDD本身的分区数量，也决定了parent RDD Shuffle输出时的分片区。<u>图中第二个函数就为分区函数</u>。</p>
<p>（5）一个列表，<strong>存储存取每个Partition的优先位置</strong>（preferred location）。对于一个HDFS文件来说，这个列表保存的就是每个Partition所在的块的位置。按照“移动数据不如移动计算”的理念，Spark在进行任务调度的时候，会尽可能地将计算任务分配到其所要处理数据块的存储位置。</p>
<h4 id="5-1-RDD的两个方法"><a href="#5-1-RDD的两个方法" class="headerlink" title="5.1 RDD的两个方法"></a>5.1 RDD的两个方法</h4><ul>
<li><p><strong>Persist</strong></p>
<p>　　通过RDD的<code>persist</code>方法，可以将RDD的分区数据<strong>持久化在内存或硬盘中</strong>，通过<code>cache</code>方法则是<strong>缓存到内存</strong>。这里的persist和cache是一样的机制，只不过cache是使用默认的<code>MEMORY_ONLY</code>的存储级别对RDD进行persist，故“缓存”也就是一种“持久化”。<br> 前面提到，只有触发了一个Action之后，Spark才会提交Job进行真正的计算。所以<strong>RDD只有经过一次Action之后，才能将RDD持久化</strong>，然后在Job间共享，即如果两个Job用到了相同的RDD，那么可以在第一个Job中对这个RDD进行缓存，在第二个Job中就避免了RDD的重新计算。持久化机制使需要访问重复数据的Application运行地更快，是能够<strong>提升Spark运算速度</strong>的一个重要功能。</p>
</li>
<li><p><strong>Checkpoint</strong></p>
<p>　　调用RDD的<code>checkpoint</code>方法，可以将RDD保存到<strong>外部存储中，如硬盘或HDFS</strong>。Spark引入checkpoint机制，是因为持久化的RDD的数据有可能丢失或被替换，checkpoint可以在这时候发挥作用，避免重新计算。<br>　　创建checkpoint是在当前Job完成后，由另外一个专门的Job完成：也就是说需要checkpoint的RDD会被计算两次。因此，在使用rdd.checkpoint()的时候，建议加上rdd.cache(),这样第二次运行的Job久不用再去计算该RDD了。</p>
<p>　　一个Job在开始处理RDD的Partition时，或者更准确点说，在Executor中运行的任务在获取Partition数据时，会<strong>先判断是否被持久化</strong>，在没有命中时<strong>再判断是否保存了checkpoint</strong>，如果没有读取到则会重新计算该Partition。</p>
</li>
</ul>
<h4 id="6-Job"><a href="#6-Job" class="headerlink" title="6. Job"></a>6. Job</h4><p>　　在一个Application中，<strong>以Action为划分边界的Spark批处理作业</strong>。前面提到，Spark采用惰性机制，对RDD的创建和转换并不会立即执行，只有在<strong>遇到第一个Action时才会生成一个Job</strong>，然后统一调度执行。一个Job包含N个Transformation和1个Action。</p>
<h4 id="7-Stage"><a href="#7-Stage" class="headerlink" title="7. Stage"></a>7. Stage</h4><p>　　一个Job中，<strong>以Shuffle为边界划分出的不同阶段</strong>。每个阶段包含一组可以被串行执行的窄依赖或宽依赖操作：用户提交的计算任务是一个由RDD构成的DAG(有向无环图)，如果RDD在转换的时候需要做Shuffle，那么这个Shuffle的过程就将这个DAG分为了不同的阶段（即Stage）。由于Shuffle的存在，不同的Stage是不能并行计算的，因为后面Stage的计算需要前面Stage的Shuffle的结果。<br>　　在对Job中的所有操作<strong>划分Stage时，一般会按照倒序进行</strong>，即从Action开始，遇到窄依赖操作，则划分到同一个执行阶段，遇到宽依赖操作，则划分一个新的执行阶段，且新的阶段为之前阶段的parent，然后依次类推递归执行。child Stage需要等待所有的parent Stage执行完之后才可以执行，这时Stage之间根据依赖关系构成了一个大粒度的DAG。<br>　　在一个Stage内，所有的操作以<strong>串行的Pipeline的方式</strong>，由一组Task完成计算。</p>
<ul>
<li><p>DAGScheduler: 根据Job<strong>构建基于Stage的DAG</strong>（Directed Acyclic Graph有向无环图)，并<strong>提交Stage给TASkScheduler</strong>。 其划分Stage的依据是RDD之间的依赖的关系找出开销最小的调度方法，如下图</p>
<p><img src="http://pic.panjiangtao.cn/202110272106_289.png" alt></p>
</li>
</ul>
<h4 id="8-Task"><a href="#8-Task" class="headerlink" title="8. Task"></a>8. Task</h4><p>　　对一个Stage之内的RDD进行串行操作的计算任务。<strong>每个Stage由一组并发的Task组成</strong>（即TaskSet），这些Task的<strong>执行逻辑完全相同</strong>，只是<strong>作用于不同的Partition</strong>。一个Stage的总Task的个数由Stage中最后的一个RDD的Partition的个数决定。</p>
<p>　　Spark Driver会根据数据所在的位置分配计算任务，即把所有Task根据其Partition所在的位置分配给相应的Executor，以尽量减少数据的网络传输（这也就是所谓的移动数据不如移动计算）。一个Executor内同一时刻可以并行执行的Task数由<code>总CPU数／每个Task占用的CPU数</code>决定，即<code>spark.executor.cores / spark.task.cpus</code>。</p>
<p>　　Task分为ShuffleMapTask和ResultTask两种，位于最后一个Stage的Task为ResultTask，其他阶段的属于ShuffleMapTask。</p>
<ul>
<li><p>TaskSedulter: 将TaskSET提交给worker运行，<strong>每个Executor运行什么Task</strong>就是在此处分配的. TaskScheduler维护所有TaskSet，当Executor向Driver发生心跳时，TaskScheduler会根据资源剩余情况分配相应的Task。另外TaskScheduler还维护着所有Task的运行标签，重试失败的Task。下图展示了TaskScheduler的作用</p>
<p><img src="http://pic.panjiangtao.cn/202110272104_734.png" alt></p>
</li>
</ul>
<h4 id="上述概念间的层次关系"><a href="#上述概念间的层次关系" class="headerlink" title="上述概念间的层次关系"></a>上述概念间的层次关系</h4><p>Job=多个stage，Stage=多个同种task</p>
<p><img src="http://pic.panjiangtao.cn/202110272107_230.png" alt></p>
<h3 id="三、Spark基本运行流程"><a href="#三、Spark基本运行流程" class="headerlink" title="三、Spark基本运行流程"></a>三、Spark基本运行流程</h3><p><img src="http://pic.panjiangtao.cn/202110281417_711.png" alt></p>
<ol>
<li>构建Spark Application的运行环境，<strong>启动SparkContext</strong></li>
<li><strong>SparkContext</strong>向<strong>资源管理器</strong>（可以是Standalone，Mesos，Yarn）<strong>申请运行Executor资源</strong>，并启动StandaloneExecutorbackend，</li>
<li><strong>Executor</strong>向<strong>SparkContext申请Task</strong></li>
<li>SparkContext将<strong>应用程序分发给Executor</strong></li>
<li>SparkContext<strong>构建成DAG图</strong>，将<strong>DAG图分解成Stage</strong>、将<strong>Taskset发送给Task Scheduler</strong>，最后由Task Scheduler<strong>将Task发送给Executor运行</strong></li>
<li><strong>Task</strong>在Executor上<strong>运行</strong>，运行完释放所有资源</li>
</ol>
<h4 id="Spark运行特点："><a href="#Spark运行特点：" class="headerlink" title="Spark运行特点："></a>Spark运行特点：</h4><ol>
<li><strong>每个Application获取专属的executor进程</strong>，该进程在Application期间一直驻留，并以多线程方式运行Task。这种Application隔离机制是有优势的，无论是从调度角度看（每个Driver调度他自己的任务），还是从运行角度看（来自不同Application的Task运行在不同JVM中），当然这样意味着Spark Application不能跨应用程序共享数据，除非将数据写入外部存储系统</li>
<li>Spark<strong>与资源管理器无关</strong>，只要能够获取executor进程，并能保持相互通信就可以了</li>
<li>提交SparkContext的<strong>Client应该靠近Worker节点</strong>（运行Executor的节点），最好是在同一个Rack里，因为Spark Application运行过程中SparkContext和Executor之间有大量的信息交换</li>
<li>Task采用了<strong>数据本地性和推测执行</strong>的优化机制</li>
</ol>
<h3 id="四、运行模式"><a href="#四、运行模式" class="headerlink" title="四、运行模式"></a>四、运行模式</h3><ul>
<li>部署在单机上时，既可以用本地模式运行，也可以用伪分布模式运行，而当以分布式集群的方式部署时，也有众多的运行模式可供选择，这取决于集群的实际情况，底层的资源调度即可以依赖外部资源调度框架，也可以使用Spark内建的<strong>Standalone</strong>模式。</li>
<li>对于外部资源调度框架的支持，目前的实现包括相对稳定的<strong>Mesos</strong>模式，以及<strong>hadoop YARN</strong>模式</li>
<li><strong>本地模式</strong>：常用于本地开发测试的local cluster模式</li>
</ul>
<h4 id="1-standalone-独立集群运行模式"><a href="#1-standalone-独立集群运行模式" class="headerlink" title="1. standalone: 独立集群运行模式"></a>1. standalone: 独立集群运行模式</h4><h5 id="（1）结构关系："><a href="#（1）结构关系：" class="headerlink" title="（1）结构关系："></a>（1）结构关系：</h5><p><img src="http://pic.panjiangtao.cn/202110281050_53.png" alt></p>
<ul>
<li>Standalone模式使用Spark<strong>自带的资源调度框架</strong></li>
<li>采用Master/Slaves的典型架构，选用ZooKeeper来实现Master的HA（Highly Available，双机集群系统）</li>
<li>该模式主要的节点有Client节点、Master节点和Worker节点。其中<strong>Driver既可以运行在Master节点上中，也可以运行在本地Client端</strong>。当用spark-shell交互式工具提交Spark的Job时，Driver在Master节点上运行；当使用spark-submit工具提交Job或者在Eclips、IDEA等开发平台上使用”new SparkConf.setManager(“spark://master:7077”)”方式运行Spark任务时，Driver是运行在本地Client端上的</li>
</ul>
<h5 id="（2）运行过程"><a href="#（2）运行过程" class="headerlink" title="（2）运行过程"></a>（2）运行过程</h5><p><img src="http://pic.panjiangtao.cn/202110281058_435.png" alt></p>
<ol>
<li>SparkContext连接到Master，向<strong>Master注册并申请资源</strong>（CPU Core 和Memory）</li>
<li>Master根据SparkContext的资源申请要求和Worker心跳周期内报告的信息决定在哪个Worker上分配资源，然后<strong>在该Worker上获取资源</strong>，然后启动StandaloneExecutorBackend；</li>
<li>StandaloneExecutorBackend向<strong>SparkContext注册</strong>；</li>
<li>SparkContext将Applicaiton代码发送给StandaloneExecutorBackend；并且SparkContext解析Applicaiton代码，<strong>构建DAG图</strong>，并提交给DAG Scheduler分解成Stage（当碰到Action操作时，就会催生Job；每个Job中含有1个或多个Stage，Stage一般在获取外部数据和shuffle之前产生），然后以Stage（或者称为TaskSet）提交给Task Scheduler，Task Scheduler负责<strong>将Task分配到相应的Worker</strong>，最后提交给StandaloneExecutorBackend执行；</li>
<li>StandaloneExecutorBackend会建立Executor线程池，开始执行Task，并向SparkContext<strong>报告Task状态</strong>，直至Task完成</li>
<li>所有Task完成后，SparkContext向Master<strong>注销，释放资源</strong></li>
</ol>
<h4 id="2-hadoop-YARN模式"><a href="#2-hadoop-YARN模式" class="headerlink" title="2. hadoop YARN模式"></a>2. hadoop YARN模式</h4><p>hadoop YARN模式根据Driver在集群中的位置分为两种模式：一种是YARN-Client模式，另一种是YARN-Cluster模式.</p>
<h5 id="1-Yarn框架流程"><a href="#1-Yarn框架流程" class="headerlink" title="(1)Yarn框架流程"></a>(1)Yarn框架流程</h5><p>　　任何框架与<em>YARN</em>的结合，都必须遵循<em>YARN</em>的开发模式。在分析<em>Spark on YARN</em>的实现细节之前，有必要先分析一下<em>YARN</em>框架的一些基本原理。Yarn框架的基本流程如下:</p>
<p><img src="http://pic.panjiangtao.cn/202110281120_36.png" alt></p>
<p>　　其中，ResourceManager负责将集群的<strong>资源分配</strong>给各个应用使用，而<strong>资源分配和调度的基本单位是Container</strong>，其中封装了机器资源，如内存、CPU、磁盘和网络等，每个任务会被分配一个Container，该任务只能在该Container中执行，并使用该Container封装的资源。<strong>NodeManager</strong>是一个个的计算节点，主要<strong>负责启动Application所需的Container，监控资源</strong>（内存、CPU、磁盘和网络等）的使用情况并将之汇报给ResourceManager。ResourceManager与NodeManagers共同组成整个数据计算框架，ApplicationMaster与具体的Application相关，主要负责同ResourceManager协商以获取合适的Container，并跟踪这些Container的状态和监控其进度。</p>
<h5 id="2-YARN-Client模式"><a href="#2-YARN-Client模式" class="headerlink" title="(2)YARN-Client模式"></a>(2)YARN-Client模式</h5><p>　　Driver在客户端本地运行，这种模式可以使得Spark Application和客户端进行交互，因为Driver在客户端，所以可以通过webUI访问Driver的状态，默认是<a href="http://hadoop1:4040访问，而YARN通过http://">http://hadoop1:4040访问，而YARN通过http://</a> hadoop1:8088访问。工作流程：</p>
<p><img src="http://pic.panjiangtao.cn/202110281115_159.png" alt></p>
<ol>
<li>Spark Yarn Client向YARN的ResourceManager<strong>申请启动Application Master</strong>。同时在<strong>SparkContent初始化</strong>中将创建DAGScheduler和TASKScheduler等，由于我们选择的是Yarn-Client模式，程序会选择YarnClientClusterScheduler和YarnClientSchedulerBackend</li>
<li>ResourceManager收到请求后，在集群中选择一个NodeManager，<strong>为该应用程序分配第一个Container</strong>，要求它在这个Container中<strong>启动应用程序的ApplicationMaster</strong>，与YARN-Cluster区别的是在该ApplicationMaster不运行SparkContext，只与SparkContext进行联系进行资源的分派</li>
<li>Client中的SparkContext初始化完毕后，与ApplicationMaster建立通讯，向ResourceManager注册，根据任务信息向ResourceManager<strong>申请资源（Container）</strong></li>
<li>一旦ApplicationMaster申请到资源（也就是Container）后，便与对应的NodeManager通信，要求它在获得的Container中<strong>启动CoarseGrainedExecutorBackend</strong>，CoarseGrainedExecutorBackend启动后会向Client中的SparkContext<strong>注册并申请Task</strong></li>
<li>client中的SparkContext<strong>分配Task给CoarseGrainedExecutorBackend执行</strong>，CoarseGrainedExecutorBackend<strong>运行Task并向Driver汇报运行的状态和进度</strong>，以让Client随时掌握各个任务的运行状态，从而可以在任务失败时重新启动任务</li>
<li>应用程序运行完成后，Client的SparkContext向ResourceManager申请<strong>注销并关闭自己</strong></li>
</ol>
<h5 id="3-YARN-Cluster模式"><a href="#3-YARN-Cluster模式" class="headerlink" title="(3)YARN-Cluster模式"></a>(3)YARN-Cluster模式</h5><p>　　在YARN-Cluster模式中，当用户向YARN中提交一个应用程序后，YARN将分两个阶段运行该应用程序：第一个阶段是把Spark的Driver作为一个ApplicationMaster在YARN集群中先启动；第二个阶段是由ApplicationMaster创建应用程序，然后为它向ResourceManager申请资源，并启动Executor来运行Task，同时监控它的整个运行过程，直到运行完成。</p>
<p><img src="http://pic.panjiangtao.cn/202110281140_69.png" alt></p>
<ol>
<li>Spark Yarn Client向YARN中<strong>提交应用程序</strong>，包括ApplicationMaster程序、启动ApplicationMaster的命令、需要在Executor中运行的程序等</li>
<li>ResourceManager收到请求后，在集群中选择一个NodeManager，为该应用程序分配第一个Container，要求它在这个Container中<strong>启动应用程序的ApplicationMaster</strong>，其中ApplicationMaster进行SparkContext等的初始化</li>
<li>ApplicationMaster向ResourceManager注册，这样用户可以直接通过ResourceManage查看应用程序的运行状态，然后它将采用轮询的方式通过RPC协议<strong>为各个任务申请资源（也就是Container）</strong>，并监控它们的运行状态直到运行结束</li>
<li>一旦ApplicationMaster申请到资源后，便与对应的NodeManager通信，要求它在获得的Container中<strong>启动CoarseGrainedExecutorBackend</strong>，CoarseGrainedExecutorBackend启动后会向ApplicationMaster中的SparkContext<strong>注册并申请Task</strong>。这一点和Standalone模式一样，只不过SparkContext在Spark Application中初始化时，使用CoarseGrainedSchedulerBackend配合YarnClusterScheduler<strong>进行任务的调度</strong>，其中YarnClusterScheduler只是对TaskSchedulerImpl的一个简单包装，增加了对Executor的等待逻辑等</li>
<li>ApplicationMaster中的SparkContext分配Task给CoarseGrainedExecutorBackend执行，CoarseGrainedExecutorBackend运行Task并向ApplicationMaster汇报运行的状态和进度，以让<strong>ApplicationMaster随时掌握各个任务的运行状态</strong>，从而可以在任务失败时重新启动任务</li>
<li>应用程序运行完成后，<strong>ApplicationMaster</strong>向ResourceManager<strong>申请注销并关闭自己</strong>。</li>
</ol>
<h5 id="4-SYARN-Client模式和YARN-Cluster模式区别"><a href="#4-SYARN-Client模式和YARN-Cluster模式区别" class="headerlink" title="(4)SYARN-Client模式和YARN-Cluster模式区别"></a>(4)SYARN-Client模式和YARN-Cluster模式区别</h5><p>　　理解YARN-Client和YARN-Cluster深层次的区别之前先清楚一个概念：Application Master。在YARN中，每个Application实例都有一个ApplicationMaster进程，它是Application启动的第一个容器。它负责和ResourceManager打交道并请求资源，获取资源之后告诉NodeManager为其启动Container。从深层次的含义讲YARN-Cluster和YARN-Client模式的区别其实就是ApplicationMaster进程的区别。</p>
<ul>
<li>YARN-Cluster模式下，<strong>Driver</strong>运行在AM(Application Master)中，它负责<strong>向YARN申请资源</strong>，并监督作业的运行状况。<strong>当用户提交了作业之后，就可以关掉Client</strong>，作业会继续在YARN上运行，因而YARN-Cluster模式不适合运行交互类型的作业；</li>
<li>YARN-Client模式下，Application Master仅仅向YARN请求Executor，<strong>Client会和请求的Container通信来调度他们工作</strong>，也就是说Client不能离开。</li>
</ul>
<h4 id="3-Mesos模式"><a href="#3-Mesos模式" class="headerlink" title="3.Mesos模式"></a>3.Mesos模式</h4><p>　　这是很多公司采用的模式，官方推荐这种模式（当然，原因之一是血缘关系）。正是由于Spark开发之初就考虑到支持Mesos，因此，目前而言，Spark运行在Mesos上会比运行在YARN上更加灵活，更加自然。目前在Spark On Mesos环境中，用户可选择两种调度模式之一运行自己的应用程序（可参考Andrew Xia的“Mesos Scheduling Mode on Spark”）：</p>
<p><img src="http://pic.panjiangtao.cn/202110281428_718.png" alt></p>
<h5 id="1-粗粒度模式（Coarse-grained-Mode）"><a href="#1-粗粒度模式（Coarse-grained-Mode）" class="headerlink" title="1. 粗粒度模式（Coarse-grained Mode）"></a>1. 粗粒度模式（Coarse-grained Mode）</h5><p>​        每个应用程序的运行环境由一个Dirver和若干个Executor组成，其中，每个Executor占用若干资源，内部可运行多个Task（对应多少个“slot”）。应用程序的各个任务正式运行之前，需要将运行环境中的资源全部申请好，且运行过程中要一直占用这些资源，即使不用，最后程序运行结束后，回收这些资源。举个例子，比如你提交应用程序时，指定使用5个executor运行你的应用程序，每个executor占用5GB内存和5个CPU，每个executor内部设置了5个slot，则Mesos需要先为executor分配资源并启动它们，之后开始调度任务。另外，在程序运行过程中，mesos的master和slave并不知道executor内部各个task的运行情况，executor直接将任务状态通过内部的通信机制汇报给Driver，从一定程度上可以认为，每个应用程序利用mesos搭建了一个虚拟集群自己使用。</p>
<h5 id="2-细粒度模式（Fine-grained-Mode）"><a href="#2-细粒度模式（Fine-grained-Mode）" class="headerlink" title="2. 细粒度模式（Fine-grained Mode）"></a>2. 细粒度模式（Fine-grained Mode）</h5><p>​        鉴于粗粒度模式会造成大量资源浪费，Spark On Mesos还提供了另外一种调度模式：细粒度模式，这种模式类似于现在的云计算，思想是按需分配。与粗粒度模式一样，应用程序启动时，先会启动executor，但每个executor占用资源仅仅是自己运行所需的资源，不需要考虑将来要运行的任务，之后，mesos会为每个executor动态分配资源，每分配一些，便可以运行一个新任务，单个Task运行完之后可以马上释放对应的资源。每个Task会汇报状态给Mesos slave和Mesos Master，便于更加细粒度管理和容错，这种调度模式类似于MapReduce调度模式，每个Task完全独立，优点是便于资源控制和隔离，但缺点也很明显，短作业运行延迟大。</p>
]]></content>
      <categories>
        <category>大数据</category>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>spring3.1-pet-user</title>
    <url>/posts/spring3-1-pet-user/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Pet类"><a href="#Pet类" class="headerlink" title="Pet类"></a>Pet类</h1><a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pet</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;<span class="keyword">this</span>.name=name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Pet&#123;&quot;</span>+<span class="string">&quot;name=&#x27;&quot;</span>+name+<span class="string">&#x27;\&#x27;&#x27;</span>+<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="User类"><a href="#User类" class="headerlink" title="User类"></a>User类</h1><ul>
<li>注释部分为后续User类需要依赖Pet类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private Pet pet;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public Pet getPet()&#123;</span></span><br><span class="line">    <span class="comment">//     return pet;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public void setPet(Pet pet)&#123;</span></span><br><span class="line">    <span class="comment">//     this.pet=pet;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, Integer age)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;<span class="keyword">this</span>.name=name;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> age;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;<span class="keyword">this</span>.age=age;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span>+<span class="string">&quot;name=&#x27;&quot;</span>+name+<span class="string">&#x27;\&#x27;&#x27;</span>+<span class="string">&quot;,age=&quot;</span>+age+<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        <span class="comment">// return &quot;User&#123;&quot;+&quot;name=&#x27;&quot;+name+&#x27;\&#x27;&#x27;+&quot;,age=&quot;+age+&quot;,pet=&quot;+pet+&#x27;&#125;&#x27;;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>for babe</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot中的容器与自动配置</title>
    <url>/posts/spring3-autoConfiguration-and-Bean/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、依赖管理与自动配置"><a href="#一、依赖管理与自动配置" class="headerlink" title="一、依赖管理与自动配置"></a>一、依赖管理与自动配置</h1><h2 id="导入父项目进行版本配置"><a href="#导入父项目进行版本配置" class="headerlink" title="导入父项目进行版本配置"></a>导入父项目进行版本配置</h2><p>　　只需导入父项目spring-boot-starter-parent及其版本号2.3.4.RELEASE就可以实现对需要的包进行版本控制。<br><a id="more"></a><br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="导入需要的starter场景启动器"><a href="#导入需要的starter场景启动器" class="headerlink" title="导入需要的starter场景启动器"></a>导入需要的starter场景启动器</h2><p>　　1. spring-boot-starter-*中的*指某种场景。</p>
<p>　　2. *-spring-boot-starter-*是第三方为我们提供的简化开发的场景启动器。</p>
<p>　　3. spring-boot-starter-web中包含了Tomcat启动器和webmvc，不需要再次引入。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-*<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="修改某个版本号"><a href="#修改某个版本号" class="headerlink" title="修改某个版本号"></a>修改某个版本号</h2><p>　　在项目的pom.xml文件中重写某个包的版本,如将mysql版本设定为5.1.43：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.43<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="修改扫描路径"><a href="#修改扫描路径" class="headerlink" title="修改扫描路径"></a>修改扫描路径</h2><p>　　程序默认只扫描主程序所在包及其子包，需要改变扫描路径，下述两种方法等同</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一种，简单方便</span></span><br><span class="line"><span class="comment">//不加括号为默认扫描，加括号为指定路径</span></span><br><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages=&quot;com.pjt&quot;)</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.pjt.boot&quot;)</span> <span class="comment">//括号内为需要扫描的根目录</span></span><br></pre></td></tr></table></figure>
<h1 id="二、容器"><a href="#二、容器" class="headerlink" title="二、容器"></a>二、容器</h1><h2 id="组件添加"><a href="#组件添加" class="headerlink" title="组件添加"></a>组件添加</h2><h3 id="1-Configuration"><a href="#1-Configuration" class="headerlink" title="1. @Configuration"></a>1. @Configuration</h3><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><p>　　<br>　　在boot目录下添加config.MyConfig类作为配置类，代码如下,其中，<a href="http://www.panjiangtao.cn/posts/spring3-1-pet-user/">Pet和User</a>为两个不同的类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span> <span class="comment">//声明这是一个配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">//给容器中添加组件(也就是加入一个对象)，下述方法名user01默认为组件id，</span></span><br><span class="line">        <span class="comment">//返回类型为组件类型，返回的对象为组件在容器中实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试组件依赖时替换</span></span><br><span class="line">    <span class="comment">// public User user01()&#123;</span></span><br><span class="line">    <span class="comment">//     User zhangsan=new User(&quot;zhangsan&quot;,18);</span></span><br><span class="line">    <span class="comment">//     zhangsan.setPet(tomcatPet());</span></span><br><span class="line">    <span class="comment">//     return zhangsan;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;Tom&quot;)</span> <span class="comment">//加参数修改组件id为Tom</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　注意啦！</p>
<ul>
<li><ol>
<li>在配置类中使用@Bean标注在方法上给容器注册组件，组件默认单实例</li>
</ol>
</li>
<li><ol>
<li>配置类本身也是组件</li>
</ol>
</li>
<li><ol>
<li>proxyBeanMethods：指bean的代理对象调用方法。为true时使用配置类调用组件时只创建单实例，如组件已有实例则不再创建；为false时会创建同一组件的新实例，一般用于组件依赖时。</li>
</ol>
</li>
</ul>
<h4 id="主程序进行测试"><a href="#主程序进行测试" class="headerlink" title="主程序进行测试"></a>主程序进行测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 从容器获得组件,多次获取为同一实例</span></span><br><span class="line">        Pet tom01 = run.getBean(<span class="string">&quot;Tom&quot;</span>, Pet.class);</span><br><span class="line">        Pet tom02 = run.getBean(<span class="string">&quot;Tom&quot;</span>, Pet.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;组件：&quot;</span>+(tom01==tom02));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2. 配置类也为组件，获取到的bean对象为代理对象</span></span><br><span class="line">        MyConfig bean = run.getBean(MyConfig.class);</span><br><span class="line">        System.out.println(bean);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.1 proxyBeanMethods为true时调用多次组件获得相同实例</span></span><br><span class="line">        User user = bean.user01();</span><br><span class="line">        User user1 = bean.user01();</span><br><span class="line">        System.out.println(user==user1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.2 proxyBeanMethods为false时调用多次组件时创建新实例</span></span><br><span class="line">        User user01 = run.getBean(<span class="string">&quot;user01&quot;</span>, User.class);</span><br><span class="line">        Pet Tom=run.getBean(<span class="string">&quot;Tom&quot;</span>,Pet.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;用户的宠物:&quot;</span>+(user01.getPet()==Tom));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　</p>
<h3 id="2-Import"><a href="#2-Import" class="headerlink" title="2. @Import"></a>2. @Import</h3><p>　　在主函数目录下的类中使用，加在类定义之前。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Import给容器中自动创建这两个类型的组件,默认组件名字为全类名</span></span><br><span class="line"><span class="meta">@Import(&#123;User.class, DBHelper.class&#125;)</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-Conditional"><a href="#3-Conditional" class="headerlink" title="3. @Conditional"></a>3. @Conditional</h3><p>　　写在类名之上对整个类有效，写在方法名之上对该方法有效。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@ConditionalOnMissingBean(name = &quot;tom&quot;) //不存在tom组件时注入组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ConditionalOnBean(name=&quot;tom22&quot;)</span> <span class="comment">//存在tom组件时才注入组件,由于此时tom22还未注入，因此user01无法注入</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        User zhangsan = <span class="keyword">new</span> User(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        <span class="comment">//user组件依赖了Pet组件</span></span><br><span class="line">        zhangsan.setPet(tomcatPet());</span><br><span class="line">        <span class="keyword">return</span> zhangsan;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;tom22&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Pet <span class="title">tomcatPet</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pet(<span class="string">&quot;tomcat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　主函数测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//返回IOC容器</span></span><br><span class="line">        ConfigurableApplicationContext run = SpringApplication.run(MainApplication.class, args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> tom = run.containsBean(<span class="string">&quot;tom&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容器中Tom组件：&quot;</span>+tom);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> user01 = run.containsBean(<span class="string">&quot;user01&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容器中user01组件：&quot;</span>+user01);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> tom22 = run.containsBean(<span class="string">&quot;tom22&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;容器中tom22组件：&quot;</span>+tom22);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-ImportResource"><a href="#4-ImportResource" class="headerlink" title="4. @ImportResource"></a>4. @ImportResource</h3><p>　　xml文件中进行组件注入:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;haha&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pjt.boot.bean.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;hehe&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.pjt.boot.bean.Pet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;tomcat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　从xml配置文件中读入组件注入过程，已经将组件放入容器:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ImportResource(&quot;classpath:beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-配置绑定"><a href="#5-配置绑定" class="headerlink" title="5.配置绑定"></a>5.配置绑定</h3><p>　　使用Java读取到properties文件中的内容，并且把它封装到JavaBean中，以供随时使用。</p>
<h4 id="方法1、-ConfigurationProperties"><a href="#方法1、-ConfigurationProperties" class="headerlink" title="方法1、@ConfigurationProperties"></a>方法1、@ConfigurationProperties</h4><p>　　在需要导入类的默认属性值时使用，需要先将类装进容器。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>  <span class="comment">//必须将组件加入容器中才能拥有以下功能</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;mycar&quot;)</span>  <span class="comment">//需要导入的配置文件中的对象名</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　然后在配置文件application.properties中添加属性值：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mycar.brand=BMW</span><br><span class="line">mycar.price=<span class="number">100</span></span><br></pre></td></tr></table></figure></p>
<h4 id="方法2、-EnableConfigurationProperties"><a href="#方法2、-EnableConfigurationProperties" class="headerlink" title="方法2、@EnableConfigurationProperties"></a>方法2、@EnableConfigurationProperties</h4><p>　　在使用第三方包时，无法在其通过@Component标签注入容器，因此使用EnableConfigurationProperties方法。<br>　　配置文件写法与方法１相同。<br>　　在配置类前加入下述代码，完成配置绑定。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties(Car.class)</span></span><br><span class="line"><span class="comment">//1、开启Car配置绑定功能</span></span><br><span class="line"><span class="comment">//2、把这个Car这个组件自动注册到容器中</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConfig</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note warning">
            <p>注意：该方法需要加入方法1的@ConfigurationProperties(prefix = “mycar”)</p>
          </div></p>
<h4 id="方法3、-EnableConfigurationProperties"><a href="#方法3、-EnableConfigurationProperties" class="headerlink" title="方法3、@EnableConfigurationProperties"></a>方法3、@EnableConfigurationProperties</h4>]]></content>
      <categories>
        <category>for babe</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot之helloworld(环境配置)</title>
    <url>/posts/spring2-helloworld/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>这一节讲的是使用IDEA工具进行Spring Boot搭建的方法</p>
          </div>
<a id="more"></a>
<h1 id="一、安装Maven"><a href="#一、安装Maven" class="headerlink" title="一、安装Maven"></a>一、安装Maven</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>　　1. 点击<a href="https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.8.1/binaries/apache-maven-3.8.1-bin.zip">Maven下载地址</a>进行下载<br>　　2. 下载、解压完，在环境变量path中添加apache-maven-3.8.1\bin文件夹<br>　　3. 命令行输入<code>mvn -v</code>检查是否正确安装</p>
<h2 id="maven环境配置"><a href="#maven环境配置" class="headerlink" title="maven环境配置"></a>maven环境配置</h2><p>　　在apache-maven-3.8.1\conf文件夹中找到settings.xml文件，其中任意位置插入下述代码：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>nexus-aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>Nexus aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-1.8<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="二、IDEA配置"><a href="#二、IDEA配置" class="headerlink" title="二、IDEA配置"></a>二、IDEA配置</h1><h2 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h2><p><img src="/posts/spring2-helloworld/1.jpg" alt="新建maven工程"><br><img src="/posts/spring2-helloworld/2.jpg" alt="给项目取名，再取一个组名，比如com.lyt"></p>
<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><div class="note warning">
            <p>在打开IDEA时右下角会跳出弹框，选择always download，否则不会自动下载依赖哦贝贝。</p>
          </div>
<p>　　在pom.xml文件中加入下述代码：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果左边External Libraries没有下面这些包，就在pom.xml里右键Maven-&gt;Reload Project<br><img src="/posts/spring2-helloworld/4.jpg" alt="导入依赖后的各种包"></li>
</ul>
<h2 id="编写主程序"><a href="#编写主程序" class="headerlink" title="编写主程序"></a>编写主程序</h2><p>　　1. 在main/java下新建class，类名可以像下面这样com.pjt.boot.MainApplication<br>　　<img src="/posts/spring2-helloworld/3.jpg" alt="新建主程序"><br>　　2. 在主程序函数上添加<code>@SpringBootApplication</code>,表示这是一个SpringBoot应用。<br>　　3. 主程序完整代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pjt.boot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="编写控制器"><a href="#编写控制器" class="headerlink" title="编写控制器"></a>编写控制器</h2><p>　　1. 在com.pjt.boot下创建controller<br><img src="/posts/spring2-helloworld/5.jpg" alt="创建controller控制器"><br>　　2. 在函数HelloController上方添加<code>@RestController</code><br>　　3. 控制器代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.pjt.boot.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handle01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="三、运行项目"><a href="#三、运行项目" class="headerlink" title="三、运行项目"></a>三、运行项目</h1><h2 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h2><p>　　在resources文件夹下添加file，名为<code>application.properties</code><br><img src="/posts/spring2-helloworld/6.jpg" alt="添加配置文件"><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">server.port=<span class="number">8080</span> <span class="comment">//默认端口为8080，可以修改</span></span><br></pre></td></tr></table></figure></p>
<h2 id="运行Main函数"><a href="#运行Main函数" class="headerlink" title="运行Main函数"></a>运行Main函数</h2><p>　　在浏览器中输入<code>localhost:8080/hello</code>,即可获得下图结果。<br><img src="/posts/spring2-helloworld/7.jpg" alt="Hello World!!!"></p>
]]></content>
      <categories>
        <category>for babe</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中的IoC</title>
    <url>/posts/spring1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>Spring的主要特点是IoC和AOP，IoC是指Spring可以借助一个第三方容器，帮助用户进行多个对象之间依赖的控制。<br>AOP指面向切片编程，简单来说就是在代码运行时，将多个地方都需要的相同代码动态地插入到类的指定方法、指定位置上，从而减少代码之间的耦合和重复。</p>
          </div>
<a id="more"></a>
<h1 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h1><h2 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h2><h3 id="耦合的意思"><a href="#耦合的意思" class="headerlink" title="耦合的意思"></a>耦合的意思</h3><p>　　耦合就是模块之间互相调用、控制、传递数据，比如调用接口、两个模块引用同一个全局数据等，代码中要尽量避免耦合。</p>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>　　两种不同方法调用数据库驱动类，第一种就是耦合的，第二种就是不耦合的。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//耦合方法，通过构造函数来创建驱动类，调用了函数接口</span></span><br><span class="line">DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());</span><br><span class="line"><span class="comment">//不耦合方法，通过字符串创建驱动类</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>　　在应用加载时，创建一个Map，用于存放三层对象，这个map就是一个容器。</p>
<h3 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h3><p>　　开发时我们常把对象用配置文件进行保存，工厂就是读取配置文件、创建和获取三层对象的类。<br>　　需要获取对象时，向工厂要，工厂从容器中查找或创建。<br><img src="/posts/spring1/3.jpg" alt="使用IoC容器将对象联系"></p>
<h3 id="解耦过程示例"><a href="#解耦过程示例" class="headerlink" title="解耦过程示例"></a>解耦过程示例</h3><p>　　1. 对象之间依靠第三方容器进行联系、耦合<br><img src="/posts/spring1/1.png" alt="使用IoC容器将对象联系"><br>　　2. 去掉容器后，对象自动解耦，没有丝毫联系<br><img src="/posts/spring1/2.png" alt="删除IoC容器后对象解耦"></p>
]]></content>
      <categories>
        <category>for babe</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>序列模型之语言辨识</title>
    <url>/posts/dl-13speech-recognition/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>课程名称：<a href="https://www.bilibili.com/video/BV1F4411y7BA">吴恩达深度学习课程</a><br>学习资料：<a href="http://file.panjiangtao.cn/Deeplearning%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0v5.71.pdf">深度学习教程中文笔记</a></p>
          </div>
<p>　　传统语音识别的第一步是用一段音频生成一个声谱图，如下图所示，横轴是时间，纵轴是声音的频率（<strong>frequencies</strong>），而图中不同的颜色，显示了声波能量的大小（<strong>the amount of energy</strong>）。有一段时间，语音识别系统是用音位（<strong>phonemes</strong>）来构建的，也就是人工设计的基本单元（<strong>hand-engineered basic units of cells</strong>），如果用音位来表示”<strong>the quick brown fox</strong>“，我这里稍微简化一些，”<strong>the</strong>“含有”<strong>th</strong>“和”<strong>e</strong>“的音，而”<strong>quick</strong>“有”<strong>k</strong>“ “<strong>w</strong>“ “<strong>i</strong>“ “<strong>k</strong>“的音。<br><a id="more"></a><br><img src="/posts/dl-13speech-recognition/8da3e9cf049139a8e4a78503bd72e7fd.png" alt="语音识别问题"><br>　　而在<strong>end-to-end</strong>模型中，我们发现这种音位表示法（<strong>phonemes representations</strong>）已经不再必要了，而是可以构建一个系统，通过向系统中输入音频片段（<strong>audio clip</strong>），然后直接输出音频的文本（<strong>a transcript</strong>），而不需要使用这种人工设计的表示方法。</p>
<h1 id="CTC损失函数"><a href="#CTC损失函数" class="headerlink" title="CTC损失函数"></a>CTC损失函数</h1><p>　　通常,我们将语音音频划分为多个时间步,比如你有一段10秒的音频，并且特征（<strong>features</strong>）是100赫兹的，即每秒有100个样本，于是这段10秒的音频片段就会有1000个输入。而我们需要的输出往往没有这么多字母，因此将表示相同字母的音频输出为重复字母，没有意义的音频输出为空白符”_”，还可能有表示空格的音频输出” “。最后将重复的部分合并，就得到了我们希望的输出。<br><img src="/posts/dl-13speech-recognition/8f409fc3980b0be00dca49bf4fac2659.png" alt="CTC损失函数过程"></p>
<h1 id="触发字检测"><a href="#触发字检测" class="headerlink" title="触发字检测"></a>触发字检测</h1><p>　　随着语音识别的发展，越来越多的设备可以通过你的声音来唤醒，这有时被叫做触发字检测系统（<strong>rigger word detection systems</strong>）<br>　　现在有一个这样的<strong>RNN</strong>结构，<strong>我们要做的就是把一个音频片段（an audio clip）计算出它的声谱图特征（spectrogram features）得到特征向量</strong>$x^{<1>}$, $x^{<2>}$, $x^{<3>}$..，然后把它放到<strong>RNN</strong>中，最后要做的，就是定义我们的目标标签$y$。假如音频片段中的这一点是某人刚刚说完一个触发字，比如”<strong>Alexa</strong>“，或者”小度你好” 或者”<strong>Okay Google</strong>“，那么在这一点之前，你就可以在训练集中把目标标签都设为0，然后在这个点之后把目标标签设为1。</3></2></1></p>
]]></content>
      <categories>
        <category>毕设准备</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>毕设准备</tag>
      </tags>
  </entry>
  <entry>
    <title>GRU单元和LSTM</title>
    <url>/posts/dl-12GRU-and-LSTM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>课程名称：<a href="https://www.bilibili.com/video/BV1F4411y7BA">吴恩达深度学习课程</a><br>学习资料：<a href="http://file.panjiangtao.cn/Deeplearning%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0v5.71.pdf">深度学习教程中文笔记</a></p>
          </div>
<h1 id="GRU-门控循环单元"><a href="#GRU-门控循环单元" class="headerlink" title="GRU(门控循环单元)"></a>GRU(门控循环单元)</h1><h2 id="GRU推导过程"><a href="#GRU推导过程" class="headerlink" title="GRU推导过程"></a>GRU推导过程</h2><p>　　GRU单元中包含记忆细胞$c^{<t>}=a^{<t>}$用来记住序列的前后联系。<br>　　<br>　　在每个时间步，我们将用一个候选值重写记忆细胞，即${\tilde{c}}^{<t>}$的值，所以它就是个候选值，替代了$c^{<t>}$的值。然后我们用<strong>tanh</strong>激活函数来计算，${\tilde{c}}^{<t>} =tanh(W_{c}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{c})$，所以${\tilde{c}}^{<t>}$的值就是个替代值，代替表示$c^{<t>}$的值。</t></t></t></t-1></t></t></t></t></t></p>
<a id="more"></a>
<p>　　$\Gamma_{u}= \sigma(W_{u}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack +b_{u})$</t></t-1></p>
<p>　　这是个下标为$u$的大写希腊字母$\Gamma$，$u$代表更新门，这是一个0到1之间的值。我们刚才写出来的用$\tilde{c}$更新$c$的等式。然后门决定是否要真的更新它，按照下述式子进行计算。</p>
<p>　　$c^{<t>} = \Gamma_{u}<em>{\tilde{c}}^{<t>} +\left( 1- \Gamma_{u} \right)</t></em>c^{<t-1>}$</t-1></t></p>
<h2 id="完整GRU"><a href="#完整GRU" class="headerlink" title="完整GRU"></a>完整GRU</h2><p><img src="/posts/dl-12GRU-and-LSTM/523650730db3f0d5c05a7192da02f878.png" alt="GRU完整过程"><br>　　添加一个门$\Gamma_{r}$，你可以认为$r$代表相关性（<strong>relevance</strong>）。这个$\Gamma_{r}$门告诉你计算出的下一个$c^{<t>}$的候选值${\tilde{c}}^{<t>}$跟$c^{<t-1>}$有多大的相关性。计算这个门$\Gamma_{r}$需要参数，正如你看到的这个，一个新的参数矩阵$W_{r}$，$\Gamma_{r}= \sigma(W_{r}\left\lbrack c^{<t-1>},x^{<t>} \right\rbrack + b_{r})$。</t></t-1></t-1></t></t></p>
<h1 id="LSTM-长短时记忆网络"><a href="#LSTM-长短时记忆网络" class="headerlink" title="LSTM(长短时记忆网络)"></a>LSTM(长短时记忆网络)</h1><h2 id="LSTM正向传播"><a href="#LSTM正向传播" class="headerlink" title="LSTM正向传播"></a>LSTM正向传播</h2><p>　　LATM中不再使用$\Gamma_{r}$，也不直接将$c^{<t>}$作为$a^{<t>}$输出，其主要式子如下：</t></t></p>
<p>${\tilde{c}}^{<t>} = tanh(W_{c}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +b_{c}$</t></t-1></t></p>
<p>更新门：$\Gamma_{u}= \sigma(W_{u}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +b_{u})$</t></t-1></p>
<p>遗忘门：$\Gamma_{f} =\sigma(W_{f}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +b_{f})$</t></t-1></p>
<p>输出门：$\Gamma_{o} =\sigma(W_{o}\left\lbrack a^{<t-1>},x^{<t>} \right\rbrack +&gt;b_{o})$</t></t-1></p>
<p>$c^{<t>} =\Gamma_{u}<em>{\tilde{c}}^{<t>} + \Gamma_{f}</t></em>c^{<t-1>}$</t-1></t></p>
<p>$a^{<t>} = \Gamma_{o}*c^{<t>}$</t></t></p>
<h2 id="LSTM反向传播计算："><a href="#LSTM反向传播计算：" class="headerlink" title="LSTM反向传播计算："></a><strong>LSTM</strong>反向传播计算：</h2><h3 id="门求偏导："><a href="#门求偏导：" class="headerlink" title="　门求偏导："></a>　<strong>门求偏导：</strong></h3><p>$d \Gamma_o^{\langle t \rangle} = da_{next}<em>\tanh(c_{next}) </em> \Gamma_o^{\langle t \rangle}*(1-\Gamma_o^{\langle t \rangle})\tag{1}$</p>
<p>$d\tilde c^{\langle t \rangle} = dc_{next}<em>\Gamma_i^{\langle t \rangle}+ \Gamma_o^{\langle t \rangle} (1-\tanh(c_{next})^2) </em> i_t <em> da_{next} </em> \tilde c^{\langle t \rangle} * (1-\tanh(\tilde c)^2) \tag{2}$</p>
<p>$d\Gamma_u^{\langle t \rangle} = dc_{next}<em>\tilde c^{\langle t \rangle} + \Gamma_o^{\langle t \rangle} (1-\tanh(c_{next})^2) </em> \tilde c^{\langle t \rangle} <em> da_{next}</em>\Gamma_u^{\langle t \rangle}*(1-\Gamma_u^{\langle t \rangle})\tag{3}$</p>
<p>$d\Gamma_f^{\langle t \rangle} = dc_{next}<em>\tilde c_{prev} + \Gamma_o^{\langle t \rangle} (1-\tanh(c_{next})^2) </em> c_{prev} <em> da_{next}</em>\Gamma_f^{\langle t \rangle}*(1-\Gamma_f^{\langle t \rangle})\tag{4}$</p>
<h3 id="参数求偏导-："><a href="#参数求偏导-：" class="headerlink" title="参数求偏导 ："></a><strong>参数求偏导 ：</strong></h3><p>$ dW_f = d\Gamma_f^{\langle t \rangle} * \begin{pmatrix} a_{prev} \\ x_t\end{pmatrix}^T \tag{5} $</p>
<p>$ dW_u = d\Gamma_u^{\langle t \rangle} * \begin{pmatrix} a_{prev} \\ x_t\end{pmatrix}^T \tag{6} $</p>
<p> $ dW_c = d\tilde c^{\langle t \rangle} * \begin{pmatrix} a_{prev} \\ x_t\end{pmatrix}^T \tag{7} $</p>
<p>$ dW_o = d\Gamma_o^{\langle t \rangle} * \begin{pmatrix} a_{prev} \\ x_t\end{pmatrix}^T \tag{8}$</p>
<p>为了计算$db_f, db_u, db_c, db_o$ 需要各自对$d\Gamma_f^{\langle t \rangle}, d\Gamma_u^{\langle t \rangle}, d\tilde c^{\langle t \rangle}, d\Gamma_o^{\langle t \rangle}$ 求和。</p>
<h3 id="最后，计算隐藏状态、记忆状态和输入的偏导数："><a href="#最后，计算隐藏状态、记忆状态和输入的偏导数：" class="headerlink" title="最后，计算隐藏状态、记忆状态和输入的偏导数："></a>最后，计算隐藏状态、记忆状态和输入的偏导数：</h3><p>$ da_{prev} = W_f^T<em>d\Gamma_f^{\langle t \rangle} + W_u^T </em> d\Gamma_u^{\langle t \rangle}+ W_c^T <em> d\tilde c^{\langle t \rangle} + W_o^T </em> d\Gamma_o^{\langle t \rangle} \tag{9}$</p>
<p>$ dc_{prev} = dc_{next}\Gamma_f^{\langle t \rangle} + \Gamma_o^{\langle t \rangle} <em> (1- \tanh(c_{next})^2)</em>\Gamma_f^{\langle t \rangle}*da_{next} \tag{10}$</p>
<p>$ dx^{\langle t \rangle} = W_f^T<em>d\Gamma_f^{\langle t \rangle} + W_u^T </em> d\Gamma_u^{\langle t \rangle}+ W_c^T <em> d\tilde c_t + W_o^T </em> d\Gamma_o^{\langle t \rangle} \tag{11} $</p>
]]></content>
      <categories>
        <category>毕设准备</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>毕设准备</tag>
      </tags>
  </entry>
  <entry>
    <title>语音模型训练和序列生成</title>
    <url>/posts/dl-11Language-model-and-Sample/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>课程名称：<a href="https://www.bilibili.com/video/BV1F4411y7BA">吴恩达深度学习课程</a><br>学习资料：<a href="http://file.panjiangtao.cn/Deeplearning%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0v5.71.pdf">深度学习教程中文笔记</a></p>
          </div>
<h1 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h1><p><img src="/posts/dl-11Language-model-and-Sample/986226c39270a1e14643e8658fe6c374.png" alt="序列模型训练原理"><br><a id="more"></a><br>　　下图利用训练好的模型生成随机序列：<br><img src="/posts/dl-11Language-model-and-Sample/8b901fc8fcab9e16b1fe26b92f4ec546.png" alt="生成随机序列"></p>
]]></content>
      <categories>
        <category>毕设准备</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>毕设准备</tag>
      </tags>
  </entry>
  <entry>
    <title>不同类型循环神经网络</title>
    <url>/posts/dl-10different-rnn/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>课程名称：<a href="https://www.bilibili.com/video/BV1F4411y7BA">吴恩达深度学习课程</a><br>学习资料：<a href="http://file.panjiangtao.cn/Deeplearning%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0v5.71.pdf">深度学习教程中文笔记</a></p>
          </div>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="多对多-Many-to-many"><a href="#多对多-Many-to-many" class="headerlink" title="多对多(Many-to-many)"></a>多对多(Many-to-many)</h2><p>　　上一节中提到的命名识别模型就属于多对多模型（下图左），其$T_{x}=T_{y}$<br>　　多对多也存在$T_{x}!=T_{y}$的情况。<br><a id="more"></a><br><img src="/posts/dl-10different-rnn/14e1df0a7a8cdd1584b2e92e87e23aa7.png" alt="多对多(左)，多对一(右)"></p>
<h2 id="多对一-Many-to-one"><a href="#多对一-Many-to-one" class="headerlink" title="多对一(Many-to-one)"></a>多对一(Many-to-one)</h2><p>　　情感分类中（上图右），输入一个序列，输出单个评分，其$T_{x}&gt;1$,$T_{y}=1$</p>
<h2 id="一对多-One-to-many"><a href="#一对多-One-to-many" class="headerlink" title="一对多(One-to-many)"></a>一对多(One-to-many)</h2><p>　　音乐生成模型，输入为一个音符，输出一段乐谱序列。每个输出单元都会喂给下一单元作为输入。<br><img src="/posts/dl-10different-rnn/db580f1dfd6095d672fc62cce74ce5e2.png" alt="音乐生成模型"></p>
]]></content>
      <categories>
        <category>毕设准备</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>毕设准备</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习——序列模型介绍</title>
    <url>/posts/dl-9Sequence-Models-introduce/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>课程名称：<a href="https://www.bilibili.com/video/BV1F4411y7BA">吴恩达深度学习课程</a><br>学习资料：<a href="http://file.panjiangtao.cn/Deeplearning%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0v5.71.pdf">深度学习教程中文笔记</a></p>
          </div>
<h1 id="序列模型"><a href="#序列模型" class="headerlink" title="序列模型"></a>序列模型</h1><h2 id="序列模型的使用场景"><a href="#序列模型的使用场景" class="headerlink" title="序列模型的使用场景"></a>序列模型的使用场景</h2><p>　　语音识别、语言翻译、句子中名字识别等场景中，输入和输出都是一个具有顺序的序列，在这种情况下循环神经网络（<strong>RNN</strong>）之类的模型具有很好的效果。<br><a id="more"></a></p>
<h2 id="序列模型中的符号表示"><a href="#序列模型中的符号表示" class="headerlink" title="序列模型中的符号表示"></a>序列模型中的符号表示</h2><p>　　以识别句子中名字为例<br>符号|含义<br>:-:|:-:<br>$x^{(i)<t>}$|第i个训练样本中，输入序列X的第t个单词<br>$y^{(i)<t>}$|第i个训练样本中，输出序列Y的第t个标识符（1代表$x^{(i)<t>}$是名字，0代表不是）<br>$T_{x}^{(i)}$|第i个训练样本中，输入序列X的单词数量<br>$T_{y}^{(i)}$|第i个训练样本中，输出序列Y的标识符数量</t></t></t></p>
<h1 id="循环神经网络"><a href="#循环神经网络" class="headerlink" title="循环神经网络"></a>循环神经网络</h1><h2 id="不使用标准神经网络原因"><a href="#不使用标准神经网络原因" class="headerlink" title="不使用标准神经网络原因"></a>不使用标准神经网络原因</h2><pre><code>1. 不同样本的输入和输出的长度不同
2. 在神经网络中学习到的内容不能共享
</code></pre><h2 id="循环神经网络定义"><a href="#循环神经网络定义" class="headerlink" title="循环神经网络定义"></a>循环神经网络定义</h2><p>　　每一个时间步$x^{<t>}$按顺序作为神经网络的输入，同时输入也包含上一时间步的激活值$a^{<t-1>}$，同时设置初始激活值$a^{<0>}$如下图所示：<br><img src="/posts/dl-9Sequence-Models-introduce/cb041c33b65e17600842ebf87174c4f2.png" alt="循环神经网络示意图"><br>　　图中有一些参数。我们用$W_{ax}$来表示管理着从$x^{<t>}$到隐藏层的连接的一系列参数，每个时间步使用的都是相同的参数$W_{ax}$。而激活值也就是水平联系是由参数$W_{aa}$决定的，同时每一个时间步都使用相同的参数$W_{aa}$，同样的输出结果由$W_{\text{ya}}$决定。</t></0></t-1></t></p>
<p>　　该神经网络存在的问题：前面单元的预测无法使用后面的单元的信息，这在双向循环神经网络（BRNN）中将会介绍。</p>
<h2 id="向前传播"><a href="#向前传播" class="headerlink" title="向前传播"></a>向前传播</h2><p>　　一般的情况下，在$t$时刻，</p>
<p>$a^{&lt; t &gt;} = g_{1}(W_{aa}a^{&lt; t - 1 &gt;} + W_{ax}x^{&lt; t &gt;} + b_{a})$</p>
<p>$\hat y^{&lt; t &gt;} = g_{2}(W_{ya}a^{&lt; t &gt;} + b_{y})$</p>
<p>　　循环神经网络用的激活函数经常是<strong>tanh</strong>，不过有时候也会用<strong>ReLU</strong>，但是<strong>tanh</strong>是更通常的选择，我们有其他方法来避免梯度消失问题，我们将在之后进行讲述。选用哪个激活函数是取决于你的输出$y$，如果它是一个二分问题，那么我猜你会用<strong>sigmoid</strong>函数作为激活函数，如果是$k$类别分类问题的话，那么可以选用<strong>softmax</strong>作为激活函数。不过这里激活函数的类型取决于你有什么样类型的输出$y$，对于命名实体识别来说$y$只可能是0或者1，那我猜这里第二个激活函数$g$可以是<strong>sigmoid</strong>激活函数。</p>
<p>　　接下来为了<strong>简化</strong>这些符号，我要将这部分（$W_{\text{aa}}a^{<t -1>} +W_{\text{ax}}x^{<t>}$）以更简单的形式写出来，我把它写做$a^{<t>} =g(W_{a}\left\lbrack a^{&lt; t-1 &gt;},x^{<t>} \right\rbrack +b_{a})$，那么左右两边划线部分应该是等价的。所以我们定义$W_{a}$的方式是将矩阵$W_{aa}$和矩阵$W_{ax}$水平并列放置，$[ {W}_{aa}\vdots {W}_{ax}]=W_{a}$。举个例子，如果$a$是100维的，然后延续之前的例子，$x$是10,000维的，那么$W_{aa}$就是个$（100，100）$维的矩阵，$W_{ax}$就是个$（100，10,000）$维的矩阵，因此如果将这两个矩阵堆起来，$W_{a}$就会是个$（100，10,100）$维的矩阵。</t></t></t></t></p>
<p>　　用这个符号（$\left\lbrack a^{&lt; t - 1 &gt;},x^{&lt; t &gt;}\right\rbrack$）的意思是将这两个向量堆在一起，我会用这个符号表示，即$\begin{bmatrix}a^{&lt; t-1 &gt;} \\ x^{&lt; t &gt;} \\\end{bmatrix}$，最终这就是个10,100维的向量。你可以自己检查一下，用这个矩阵乘以这个向量，刚好能够得到原来的量，因为此时，矩阵$[ {W}_{aa}\vdots {W}_{ax}]$乘以$\begin{bmatrix} a^{&lt; t - 1 &gt;} \\ x^{&lt; t &gt;} \\ \end{bmatrix}$，刚好等于$W_{aa}a^{<t-1>} + W_{ax}x^{<t>}$，</t></t-1></p>
<p>　　同样对于这个例子$\hat y^{<t>} = g(W_{ya}a^{<t>} +b_{y})$，我会用更简单的方式重写，$\hat y^{&lt; t &gt;} = g(W_{y}a^{&lt; t &gt;} +b_{y})$</t></t></p>
<p>　　于是，上述二式子变为：</p>
<p>$a^{<t>} =g(W_{a}\left\lbrack a^{&lt; t-1 &gt;},x^{<t>} \right\rbrack +b_{a})$</t></t></p>
<p>$\hat y^{&lt; t &gt;} = g(W_{y}a^{&lt; t &gt;} +b_{y})$</p>
<h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>　　单个元素损失函数：$L^{<t>}( \hat y^{<t>},y^{<t>}) = - y^{<t>}\log\hat  y^{<t>}-( 1- y^{<t>})log(1-\hat y^{<t>})$</t></t></t></t></t></t></t></p>
<p>　　整个序列损失函数：$L(\hat y,y) = \ \sum_{t = 1}^{T_{x}}{L^{&lt; t &gt;}(\hat  y^{&lt; t &gt;},y^{&lt; t &gt;})}$</p>
<p>　　过程如下图所示：</p>
<p><img src="/posts/dl-9Sequence-Models-introduce/71a0ed918704f6d35091d8b6d60793e4.png" alt="反向传播过程"></p>
]]></content>
      <categories>
        <category>毕设准备</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>毕设准备</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络中的梯度下降</title>
    <url>/posts/dl-8Gradient-descent-for-neural/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>课程名称：<a href="https://www.bilibili.com/video/BV164411m79z">吴恩达深度学习课程</a><br>学习资料：<a href="http://file.panjiangtao.cn/Deeplearning%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0v5.71.pdf">深度学习教程中文笔记</a></p>
          </div>
<h1 id="梯度下降的计算过程"><a href="#梯度下降的计算过程" class="headerlink" title="梯度下降的计算过程"></a>梯度下降的计算过程</h1><p>　　单隐层神经网络会有$W^{[1]}$，$b^{[1]}$，$W^{[2]}$，$b^{[2]}$这些参数，还有个$n_x$表示输入特征的个数，$n^{[1]}$表示隐藏单元个数，$n^{[2]}$表示输出单元个数。<br><a id="more"></a></p>
<p>　　在我们的例子中，我们只介绍过的这种情况，那么参数:</p>
<p>　　矩阵$W^{[1]}$的维度就是($n^{[1]}, n^{[0]}$)，$b^{[1]}$就是$n^{[1]}$维向量，可以写成$(n^{[1]}, 1)$，就是一个的列向量。<br>矩阵$W^{[2]}$的维度就是($n^{[2]}, n^{[1]}$)，$b^{[2]}$的维度就是$(n^{[2]},1)$维度。</p>
<p>　　你还有一个神经网络的成本函数，假设你在做二分类任务，那么你的成本函数等于：</p>
<p><strong>Cost function</strong>:<br>公式：$J(W^{[1]},b^{[1]},W^{[2]},b^{[2]}) = {\frac{1}{m}}\sum_{i=1}^mL(\hat{y}, y)$<br><strong>loss function</strong>和之前做<strong>logistic</strong>回归完全一样。</p>
<h2 id="训练参数公式"><a href="#训练参数公式" class="headerlink" title="训练参数公式"></a>训练参数公式</h2><p>　　训练参数需要做梯度下降，在训练神经网络的时候，随机初始化参数很重要，而不是初始化成全零。当你参数初始化成某些值后，每次梯度下降都会循环计算以下预测值：</p>
<p>　　$\hat{y}^{(i)},(i=1,2,…,m)$</p>
<p>公式3.28：$dW^{[1]} = \frac{dJ}{dW^{[1]}},db^{[1]} = \frac{dJ}{db^{[1]}}$</p>
<p>公式3.29：${d}W^{[2]} = \frac{dJ}{dW^{[2]}},{d}b^{[2]} = \frac{dJ}{db^{[2]}}$</p>
<p>公式3.30：$W^{[1]}\implies{W^{[1]} - adW^{[1]}},b^{[1]}\implies{b^{[1]} -adb^{[1]}}$</p>
<p>公式3.31：$W^{[2]}\implies{W^{[2]} - \alpha{\rm d}W^{[2]}},b^{[2]}\implies{b^{[2]} - \alpha{\rm d}b^{[2]}}$</p>
<h2 id="传播公式"><a href="#传播公式" class="headerlink" title="传播公式"></a>传播公式</h2><h3 id="正向传播方程如下："><a href="#正向传播方程如下：" class="headerlink" title="正向传播方程如下："></a>正向传播方程如下：</h3><p><strong>forward propagation</strong>：</p>
<p>(1)$z^{[1]} = W^{[1]}x + b^{[1]}$</p>
<p>(2)$a^{[1]} = \sigma(z^{[1]})$</p>
<p>(3)$z^{[2]} = W^{[2]}a^{[1]} + b^{[2]}$</p>
<p>(4)$a^{[2]} = g^{[2]}(z^{[z]}) = \sigma(z^{[2]})$</p>
<h3 id="反向传播方程如下"><a href="#反向传播方程如下" class="headerlink" title="反向传播方程如下:"></a>反向传播方程如下:</h3><p><strong>back propagation</strong>：</p>
<p>公式3.32：$ dZ^{[2]} = A^{[2]} - Y , Y = \begin{bmatrix}y^{[1]} &amp; y^{[2]} &amp; \cdots &amp; y^{[m]}\\ \end{bmatrix} $</p>
<p>公式3.33：$ dW^{[2]} = {\frac{1}{m}}dZ^{[2]}A^{[1]T} $</p>
<p>公式3.34：$ {\rm d}b^{[2]} = {\frac{1}{m}}np.sum({d}z^{[2]},axis=1,keepdims=True)$</p>
<p>公式3.35：<img src="/posts/dl-8Gradient-descent-for-neural/QQ截图20210307171037.jpg" alt></p>
<p>公式3.36：$dW^{[1]} = {\frac{1}{m}}dZ^{[1]}x^{T}$</p>
<p>公式3.37：${\underbrace{db^{[1]}}_{(n^{[1]},1)}} = {\frac{1}{m}}np.sum(dZ^{[1]},axis=1,keepdims=True)$</p>
<p>　　上述是反向传播的步骤，注：这些都是针对所有样本进行过向量化，$Y$是$1×m$的矩阵；这里<code>np.sum</code>是python的numpy命令，<code>axis=1</code>表示水平相加求和，<code>keepdims</code>是防止<strong>python</strong>输出那些古怪的秩数$(n,)$，加上这个确保阵矩阵$db^{[2]}$这个向量输出的维度为$(n,1)$这样标准的形式。 </p>
<h1 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h1><p>　　一般情况下，$w^{[1]}$不初始化为全0矩阵，在单隐层神经网络中，$n_{0}$为2，$n_{1}$为2。使用如下公式对其进行初始化。</p>
<p>$W^{[1]} = np.random.randn(2,2) * 0.01$</p>
<p>$b^{[1]} = np.zeros((2,1))$</p>
<p>$W^{[2]} = np.random.randn(2,2) * 0.01$</p>
<p>$b^{[2]} = 0$</p>
<p>　　乘0.01是为了使z落在sigmoid函数中斜率较大位置，提高收敛效率。</p>
<h1 id="深层神经网络概述"><a href="#深层神经网络概述" class="headerlink" title="深层神经网络概述"></a>深层神经网络概述</h1><p>　　深度神经网络是具有多个隐藏层的神经网络，其大体上计算过程和浅层神经网络类似，只是多了隐藏层的多次循环。</p>
]]></content>
      <categories>
        <category>毕设准备</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>毕设准备</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络的激活函数</title>
    <url>/posts/dl-7activation-functions/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>课程名称：<a href="https://www.bilibili.com/video/BV164411m79z">吴恩达深度学习课程</a><br>学习资料：<a href="http://file.panjiangtao.cn/Deeplearning%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0v5.71.pdf">深度学习教程中文笔记</a></p>
          </div>
<h1 id="不同的激活函数"><a href="#不同的激活函数" class="headerlink" title="不同的激活函数"></a>不同的激活函数</h1><h2 id="下图为4种常见激活函数"><a href="#下图为4种常见激活函数" class="headerlink" title="下图为4种常见激活函数"></a>下图为4种常见激活函数</h2><p><img src="/posts/dl-7activation-functions/L1_week3_9.jpg" alt="激活函数图像"><br><a id="more"></a></p>
<h3 id="1-sigmoid函数"><a href="#1-sigmoid函数" class="headerlink" title="1.sigmoid函数"></a>1.sigmoid函数</h3><p>　　$a = \sigma(z) = \frac{1}{1 + e^{- z}}$，其值介于0和1之间。</p>
<h3 id="2-tanh函数"><a href="#2-tanh函数" class="headerlink" title="2.tanh函数"></a>2.tanh函数</h3><p>　　激活函数g(z)可以是$a = tanh(z) = \frac{e^{z} - e^{- z}}{e^{z} + e^{- z}}$,其值介于-1和1之间，在大多情况下使用该函数的效果优于sigmoid函数，但是也有例外，如二分类问题。</p>
<p>　　每一层可以使用不同的激活函数，表示为$g^{[i]}()$,i表示层数。</p>
<p>　　tanh和sigmoid函数的共同问题是z很大或很小时导数的梯度过小，会使梯度下降算法效率降低。</p>
<h3 id="3-ReLU函数"><a href="#3-ReLU函数" class="headerlink" title="3.ReLU函数"></a>3.ReLU函数</h3><p>　　ReLU函数的公式为$a=max(0,z)$,z大于0时导数为1，小于0时导数为0</p>
<h3 id="4-Leaky-ReLU函数"><a href="#4-Leaky-ReLU函数" class="headerlink" title="4.Leaky ReLU函数"></a>4.Leaky ReLU函数</h3><p>　　公式为$a=max(0.01z,z)$,z大于1时导数为1，z小于0时，导数介于0到1之间。</p>
<p>　　<strong>sigmoid函数只适合作为二分类的输出层激活函数，其他层使用ReLU作为激活函数。如果不知道使用什么函数，那就默认使用ReLU函数</strong></p>
<h2 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h2><ul>
<li>ReLU函数不存在导数靠近0的时刻，故效率高</li>
<li>sigmoid 和 tanh 函数的导数在正负饱和区的梯度都会接近于 0，这会造成梯度弥散，而 Relu 和 Leaky ReLu 函数大于 0 部分都为常数，不会产生梯度弥散现象。(同时应该注意到的是，Relu 进入负半区的时候，梯度为 0，神经元此时不会训练，产生所谓的稀疏性，而 Leaky ReLu 不会有这问题)</li>
<li>z在 ReLu 的梯度一半都是 0，但是，有足够的隐藏层使得z值大于 0，所以对大多数的训练数据来说学习过程仍然可以很快。</li>
</ul>
<p>注意：不能在隐藏层用线性激活函数，可以用 ReLU 或者 tanh 或者 leaky ReLU 或者其他的非线性激活函数，唯一可以用线性激活函数的通常就是输出层</p>
<h1 id="激活函数的导数"><a href="#激活函数的导数" class="headerlink" title="激活函数的导数"></a>激活函数的导数</h1><h2 id="sigmoid函数的导数"><a href="#sigmoid函数的导数" class="headerlink" title="sigmoid函数的导数"></a>sigmoid函数的导数</h2><p>　　$a= g(z)$， $g^{‘}(z)=\frac{d}{dz}g(z)={\frac{1}{1 + e^{-z}} (1-\frac{1}{1 + e^{-z}})}=g(z)(1-g(z))=a(1-a)$，故只需求出a就可知道其导数。</p>
<h2 id="tanh函数的导数"><a href="#tanh函数的导数" class="headerlink" title="tanh函数的导数"></a>tanh函数的导数</h2><p>　　$a = g(z) = tanh(z) = \frac{e^{z} - e^{-z}}{e^{z} + e^{-z}} $</p>
<p>　　$g^{‘}(z)=\frac{d}{dz}g(z) = 1 - (tanh(z))^{2}=1-a^{2}$</p>
<h2 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h2><p>　　z大于0时，导数为1；小于0时导数为0。</p>
]]></content>
      <categories>
        <category>毕设准备</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>毕设准备</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络的表示和输出</title>
    <url>/posts/dl-6neural-network-representation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>课程名称：<a href="https://www.bilibili.com/video/BV164411m79z">吴恩达深度学习课程</a><br>学习资料：<a href="http://file.panjiangtao.cn/Deeplearning%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0v5.71.pdf">深度学习教程中文笔记</a></p>
          </div>
<h1 id="神经网络的表示"><a href="#神经网络的表示" class="headerlink" title="神经网络的表示"></a>神经网络的表示</h1><p>　　下图为一个只包含一个隐藏层的神经网络。<br><img src="/posts/dl-6neural-network-representation/L1_week3_3.png" alt="神经网络图片"><br><a id="more"></a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>层名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>输入层</strong></td>
<td>图中的$x_{1}$、$x_{2}$、$x_{3}$,包含神经网络的输入</td>
</tr>
<tr>
<td><strong>隐藏层</strong></td>
<td>中间的一列四个结点，因在训练集中看不到，故称隐藏层</td>
</tr>
<tr>
<td><strong>输出层</strong></td>
<td>最后的那个结点，负责产生预测值</td>
</tr>
</tbody>
</table>
</div>
<p>　　每一层的值都有表示方法，如下图：<br><img src="/posts/dl-6neural-network-representation/L1_week3_5.png" alt="神经网络符号"><br>　　$a^{[0]}$,$a^{[1]}$,$a^{[2]}$分别表示图中的输入层，隐藏层和输出层，而$a^{[1]}$则是一个有四个隐藏层单元的1*4的列向量。</p>
<div class="note ">
            <p>值得注意的是，神经网络计算层数时不算输入层，因此上图中为两层神经网络。</p>
          </div>
<p>　　在隐藏层中将拥有两个参数$W$和$b$，我将给它们加上上标$^{[1]}$($W^{[1]}$,$b^{[1]}$)，表示这些参数是和第一层这个隐藏层有关系的。之后在这个例子中我们会看到$W$是一个4x3的矩阵，而$b$是一个4x1的向量，第一个数字4源自于我们有四个结点或隐藏层单元，然后数字3源自于这里有三个输入特征，我们之后会更加详细地讨论这些矩阵的维数，到那时你可能就更加清楚了。相似的输出层也有一些与之关联的参数$W^{[2]}$以及$b^{[2]}$。从维数上来看，它们的规模分别是1x4以及1x1。1x4是因为隐藏层有四个隐藏层单元而输出层只有一个单元。</p>
<h1 id="神经网络输出"><a href="#神经网络输出" class="headerlink" title="神经网络输出"></a>神经网络输出</h1><h2 id="神经网络的计算"><a href="#神经网络的计算" class="headerlink" title="神经网络的计算"></a>神经网络的计算</h2><p>　　下图为一次逻辑回归计算的过程，圆圈表示神经网络的计算单元，首先你按步骤计算出$z$，然后在第二步中你以<strong>sigmoid</strong>函数为激活函数计算$z$（得出$a$），一个神经网络只是这样子做了好多次重复计算。<br><img src="/posts/dl-6neural-network-representation/L1_week3_6.png" alt="逻辑回归计算"><br>　　通过对隐藏层的四个单元的分别进行逻辑回归运算，得到了四组z和a的结果：<br>$z^{[1]}_1 = w^{[1]T}_1x + b^{[1]}_1, a^{[1]}_1 = \sigma(z^{[1]}_1)$</p>
<p>$z^{[1]}_2 = w^{[1]T}_2x + b^{[1]}_2, a^{[1]}_2 = \sigma(z^{[1]}_2)$</p>
<p>$z^{[1]}_3 = w^{[1]T}_3x + b^{[1]}_3, a^{[1]}_3 = \sigma(z^{[1]}_3)$</p>
<p>$z^{[1]}_4 = w^{[1]T}_4x + b^{[1]}_4, a^{[1]}_4 = \sigma(z^{[1]}_4)$</p>
<h2 id="向量化计算"><a href="#向量化计算" class="headerlink" title="向量化计算"></a>向量化计算</h2><p>　　把上面四个等式向量化。向量化的过程是将神经网络中的一层神经元参数纵向堆积起来，例如隐藏层中的$w$纵向堆积起来变成一个(4,3)的矩阵，用符号$W^{[1]}$表示。<br>　　因而，得到z、a的向量计算过程：<br><img src="/posts/dl-6neural-network-representation/QQ截图20210305135246.jpg" alt="z计算过程"><br><img src="/posts/dl-6neural-network-representation/QQ截图20210305135223.jpg" alt="a计算过程"><br>　　对于需要计算的两层参数，列出下图中的两组计算式。<br><img src="/posts/dl-6neural-network-representation/L1_week3_7.png" alt="隐藏层、输出层参数计算"><br>　　最终可以得到一个(1,1)的$z^{[2]}$和$a^{[2]}$。</p>
<h2 id="多样本的向量化"><a href="#多样本的向量化" class="headerlink" title="多样本的向量化"></a>多样本的向量化</h2><p>　　对于每一个训练样本i，都进行上述的四个等式的计算：</p>
<p>$z^{[1](i)}=W^{[1](i)}x^{(i)}+b^{[1](i)}$</p>
<p>$a^{[1](i)}=\sigma(z^{[1](i)})$</p>
<p>$z^{[2](i)}=W^{[2](i)}a^{[1](i)}+b^{[2](i)}$</p>
<p>$a^{[2](i)}=\sigma(z^{[2](i)})$</p>
<p>　　当我们进行归纳推演，不难得出如下向量计算式：</p>
<p>$Z^{[1]}=W^{[1]}X+b^{[1]}$</p>
<p>$A^{[1]}=\sigma(Z^{[1]})$</p>
<p>$Z^{[2]}=W^{[2]}A^{[1]}+b^{[2]}$</p>
<p>$A^{[2]}=\sigma(Z^{[2]})$</p>
<p>其中，X为下图所示<br><img src="/posts/dl-6neural-network-representation/QQ截图20210305142218.jpg" alt="向量X"><br>$Z^{[1]}$为<br><img src="/posts/dl-6neural-network-representation/QQ截图20210305142539.jpg" alt="向量Z^1"><br>$A^{[1]}$为<br><img src="/posts/dl-6neural-network-representation/QQ截图20210305142550.jpg" alt="向量A^1"><br>　　横向计算为每个训练样本，纵向为不同隐藏层单元。</p>
]]></content>
      <categories>
        <category>毕设准备</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>毕设准备</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习中的向量化</title>
    <url>/posts/dl-5vectorization/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>课程名称：<a href="https://www.bilibili.com/video/BV164411m79z">吴恩达深度学习课程</a><br>学习资料：<a href="http://file.panjiangtao.cn/Deeplearning%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0v5.71.pdf">深度学习教程中文笔记</a></p>
          </div>
<h1 id="极大提高计算效率"><a href="#极大提高计算效率" class="headerlink" title="极大提高计算效率"></a>极大提高计算效率</h1><p>　　在逻辑回归中计算$z=w^{T}x+b$时，w，x都是列向量。</p>
<p>　　非向量方法：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">z=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n_x)</span><br><span class="line">z+=w[i]*x[i]</span><br><span class="line">z+=b</span><br></pre></td></tr></table></figure><br><a id="more"></a><br>　　向量方法：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">z=np.dot(w,x)+b</span><br></pre></td></tr></table></figure><br>　　使用一个具体的例子，<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment">#导入 numpy 库</span></span><br><span class="line"><span class="keyword">import</span> time <span class="comment">#导入时间库</span></span><br><span class="line">a = np.random.rand(<span class="number">1000000</span>)</span><br><span class="line">b = np.random.rand(<span class="number">1000000</span>) <span class="comment">#通过 round 随机得到两个一百万维度的数组</span></span><br><span class="line">tic = time.time() <span class="comment">#现在测量一下当前时间</span></span><br><span class="line"><span class="comment">#向量化的版本</span></span><br><span class="line">c = np.dot(a,b)</span><br><span class="line">toc = time.time()</span><br><span class="line">print(“Vectorized version:” + str(<span class="number">1000</span>*(toc-tic)) +”ms”) <span class="comment">#打印一下向量</span></span><br><span class="line">化的版本的时间</span><br><span class="line"><span class="comment">#非向量化的版本</span></span><br><span class="line">c = <span class="number">0</span></span><br><span class="line">tic = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">c += a[i]*b[i]</span><br><span class="line">toc = time.time()</span><br><span class="line">print(c)</span><br><span class="line">print(“For loop:” + str(<span class="number">1000</span>*(toc-tic)) + “ms”)</span><br></pre></td></tr></table></figure><br>　　向量化的方法几乎要快300倍。<br>　　其原因是深度学习基本上由CPU或GPU来完成计算，他们都有并行化的指令，称为SIMD(单指令流多数据流)，而高级语言中的内置函数(如np.dot)可以更好地利用并行化进行计算，其中GPU比CPU更擅长SIMD处理。</p>
<h1 id="更多向量化例子"><a href="#更多向量化例子" class="headerlink" title="更多向量化例子"></a>更多向量化例子</h1><h3 id="u-np-exp-v-可以使列向量v的每一项-v-i-都变为-e-v-i-。"><a href="#u-np-exp-v-可以使列向量v的每一项-v-i-都变为-e-v-i-。" class="headerlink" title="u=np.exp(v) 可以使列向量v的每一项$v_{i}$都变为$e^{v_{i}}$。"></a><code>u=np.exp(v)</code> 可以使列向量v的每一项$v_{i}$都变为$e^{v_{i}}$。</h3><pre><code>* np.log(v)——每一项求自然对数
* np.abs(v)——每一项求绝对值
* np.maximum(v,0)——每一项是否比0大
</code></pre><h3 id="在逻辑回归中"><a href="#在逻辑回归中" class="headerlink" title="在逻辑回归中"></a>在逻辑回归中</h3><p>　　原本需要使用二重for循环：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">J=<span class="number">0</span>,db=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n:</span><br><span class="line">    dw(i) = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to m:</span><br><span class="line">    z(i) = wx(i)+b</span><br><span class="line">    a(i) = sigmoid(z(i))</span><br><span class="line">    J += -[y(i)log(a(i))+(<span class="number">1</span>-y(i)）log(<span class="number">1</span>-a(i))</span><br><span class="line">    dz(i) = a(i)-y(i)</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span> to n:</span><br><span class="line">        dw(j) += x(j)(i)dz(i)</span><br><span class="line">    db += dz(i)</span><br><span class="line">J/= m</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n:</span><br><span class="line">    dw(i) /= m</span><br><span class="line">db/= m</span><br><span class="line">w=w-alpha*dw</span><br><span class="line">b=b-alpha*db</span><br></pre></td></tr></table></figure><br>　　在经过简单向量化后，代码具有一重for循环，变为：<br><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">J=<span class="number">0</span>,dw=np.zeros(n_x,<span class="number">1</span>),db=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to m:</span><br><span class="line">    z(i) = wx(i)+b</span><br><span class="line">    a(i) = sigmoid(z(i))</span><br><span class="line">    J += -[y(i)log(a(i))+(<span class="number">1</span>-y(i)）log(<span class="number">1</span>-a(i))</span><br><span class="line">    dz(i) = a(i)-y(i)</span><br><span class="line">    dw = np.dot(x,dz.T)</span><br><span class="line">    db += dz(i)</span><br><span class="line">J/= m</span><br><span class="line">dw /= m</span><br><span class="line">db/= m</span><br><span class="line">w=w-alpha*dw</span><br><span class="line">b=b-alpha*db</span><br></pre></td></tr></table></figure></p>
<h1 id="终极向量化"><a href="#终极向量化" class="headerlink" title="终极向量化"></a>终极向量化</h1><h2 id="求取z"><a href="#求取z" class="headerlink" title="　求取z"></a>　求取z</h2><p>　　只需一行代码即可完成逻辑回归中z的计算，即<code>Z=np.dot(w.T,X)+b</code>。</p>
<p>　　$[z^{(1)} z^{(2)}…z^{(m)}]=w^{T}X+[b b…b]=[w^{T}x^{(1)}+b,w^{T}x^{(2)}+b…w^{T}x^{(m)}+b]$ 。</p>
<p>　　$w^{T}x^{(1)}+b$ 这是第一个元素，$w^{T}x^{(2)}+b$ 这是第二个元素， $w^{T}x^{(m)}+b$ 这是第 $m$ 个元素。</p>
<p>　　这里在 Python 中有一个巧妙的地方，这里 𝑏 是一个实数，或者你可以说是一个 1 × 1 矩阵，只是一个普通的实数。但是当你将这个向量加上这个实数时，Python 自动把这个实数 𝑏 扩展成一个 1 × 𝑚 的行向量。所以这种情况下的操作似乎有点不可思议，它在 Python 中被称作广播(brosdcasting)。</p>
<p>　　而$A=[a^{(1)} a^{(2)} … a^{(m)}]=\sigma (Z)$可以高效输出A。</p>
<h2 id="去掉循环"><a href="#去掉循环" class="headerlink" title="　去掉循环"></a>　去掉循环</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">Z = np.dot( w.T,X)+b</span><br><span class="line">A = sigma( Z )</span><br><span class="line">dZ = A - Y</span><br><span class="line">dw = <span class="number">1</span>/m*np.dot(x,dz.T)</span><br><span class="line">db= <span class="number">1</span>/m*np.sum(dZ)</span><br><span class="line">w: = w - a*dw</span><br><span class="line">b: = b - a*db</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>毕设准备</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>毕设准备</tag>
      </tags>
  </entry>
  <entry>
    <title>梯度下降法</title>
    <url>/posts/dl-4Gradient-Descent/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>课程名称：<a href="https://www.bilibili.com/video/BV164411m79z">吴恩达深度学习课程</a><br>学习资料：<a href="http://file.panjiangtao.cn/Deeplearning%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0v5.71.pdf">深度学习教程中文笔记</a></p>
          </div>
<p>　　我们通过使代价函数最小化来训练参数$w$和$b$。<br><img src="/posts/dl-4Gradient-Descent/cbd5ff8c461fcb5a699c4ec4789687b3.jpg" alt="代价函数J(w,b)"><br>　　下图中横轴表示你的空间参数$w$和$b$，在实践中，$w$可以是更高的维度，但是为了更好地绘图，我们定义$w$和$b$，都是单一实数，代价函数（成本函数）$J(w,b)$是在水平轴$w$和$b$上的曲面，因此曲面的高度就是$J(w,b)$在某一点的函数值。我们所做的就是找到使得代价函数（成本函数）$J(w,b)$函数值是最小值，对应的参数$w$和$b$。<br><a id="more"></a><br><img src="/posts/dl-4Gradient-Descent/c5eda5608fd2f4d846559ed8e89ed33c.jpg" alt="梯度下降法过程说明"></p>
<h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><h2 id="一、在三维坐标系中"><a href="#一、在三维坐标系中" class="headerlink" title="一、在三维坐标系中"></a>一、在三维坐标系中</h2><h3 id="1-初始化，随机取-w-b-，获得-J-w-b-初始值"><a href="#1-初始化，随机取-w-b-，获得-J-w-b-初始值" class="headerlink" title="　1. 初始化，随机取$w$,$b$，获得$J(w,b)$初始值"></a>　1. 初始化，随机取$w$,$b$，获得$J(w,b)$初始值</h3><h3 id="2-从初始点不断向最陡的下坡方向迭代"><a href="#2-从初始点不断向最陡的下坡方向迭代" class="headerlink" title="　2. 从初始点不断向最陡的下坡方向迭代"></a>　2. 从初始点不断向最陡的下坡方向迭代</h3><h3 id="3-直到走到全局最优解附近"><a href="#3-直到走到全局最优解附近" class="headerlink" title="　3. 直到走到全局最优解附近"></a>　3. 直到走到全局最优解附近</h3><h2 id="二、单参数细节说明"><a href="#二、单参数细节说明" class="headerlink" title="二、单参数细节说明"></a>二、单参数细节说明</h2><p>　　假定b恒定，则只有w在变化，J变为二维平面函数。<br><img src="/posts/dl-4Gradient-Descent/4fb3b91114ecb2cd81ec9f3662434d81.jpg" alt="二维梯度下降"><br>　　迭代此公式：$w=w-\alpha\frac{dJ(w)}{dw}$</p>
<p>　　其中等号为赋值符；a为学习率，控制步长。</p>
<ul>
<li><p>初始化点在最优解右边时，斜率$\frac{dJ(w)}{dw}>0$,故下一步向左走。</p>
</li>
<li><p>初始化点在最优解左边时，斜率$\frac{dJ(w)}{dw}&lt;0$,故下一步向右走。</p>
</li>
</ul>
<h2 id="三、双参数细节说明"><a href="#三、双参数细节说明" class="headerlink" title="三、双参数细节说明"></a>三、双参数细节说明</h2><p>　　代价函数有两个参数，因此需要对两个参数分别求偏导。<br>　　　　$w=w-\alpha\frac{\partial J(w,b)}{\partial w}$　　$b=b-\alpha\frac{\partial J(w,b)}{\partial b}$<br>　　<br>　　$\partial $ 表示求偏导符号，可以读作<strong>round</strong>，$\frac{\partial J(w,b)}{\partial w}$  就是函数$J(w,b)$ 对$w$ 求偏导，在代码中我们会使用$dw$ 表示这个结果，$\frac{\partial J(w,b)}{\partial b}$  就是函数$J(w,b)$对$b$ 求偏导，在代码中我们会使用$db$ 表示这个结果，小写字母$d$ 用在求导数（<strong>derivative</strong>），即函数只有一个参数，偏导数符号$\partial $ 用在求偏导（<strong>partial derivative</strong>），即函数含有两个以上的参数。　</p>
<h1 id="逻辑回归中的梯度下降-单个样本"><a href="#逻辑回归中的梯度下降-单个样本" class="headerlink" title="逻辑回归中的梯度下降(单个样本)"></a>逻辑回归中的梯度下降(单个样本)</h1><h2 id="1-求出损失函数L的值"><a href="#1-求出损失函数L的值" class="headerlink" title="　1. 求出损失函数L的值"></a>　1. 求出损失函数L的值</h2><p>　　假设样本只有两个特征$x_{1}$和$x_{2}$，只考虑单个样本情况，可以通过以下三个式子求出损失函数L的值。<br><img src="/posts/dl-4Gradient-Descent/03f5f96177ab15d5ead8298ba50300ac.jpg" alt="推理公式"></p>
<h2 id="2-反向求导"><a href="#2-反向求导" class="headerlink" title="　2.反向求导"></a>　2.反向求导</h2><p>　　现在让我们来讨论通过反向计算出导数。因为我们想要计算出的代价函数$L(a,y)$的导数，首先我们需要反向计算出代价函数$L(a,y)$关于$a$的导数，在编写代码时，你只需要用$da$ 来表示$\frac{dL(a,y)}{da}$。</p>
<p>　　通过微积分得到：$\frac{dL(a,y)}{da}=-y/a+(1-y)/(1-a)$ </p>
<p>　　而根据$da$可以求出${dz} = \frac{dL(a,y)}{dz} = \frac{dL}{dz} = ( \frac{dL}{da} ) \cdot (\frac{da}{dz} ) = ( - \frac{y}{a} + \frac{(1 - y)}{(1 - a)})\cdot a(1 - a) = a - y$</p>
<p>　　然后通过反向推导求出是计算𝑤和𝑏变化对代价函数𝐿的影响：<br>　　$d{w_{1}}=\frac{\partial L}{\partial w_{1}}=x_{1}\cdot dz$， </p>
<p>　　$d{w_{2}}=\frac{\partial L}{\partial w_{2}}=x_{2}\cdot dz$，</p>
<p>　　$db=dz$<br><img src="/posts/dl-4Gradient-Descent/6403f00e5844c3100f4aa9ff043e2319.jpg" alt="反向推导"></p>
<h2 id="3-更新参数值"><a href="#3-更新参数值" class="headerlink" title="　3. 更新参数值"></a>　3. 更新参数值</h2><p>　　$w_{1}=w_{1}-\alpha d{w}_{1}$，</p>
<p>　　$w_{2}=w_{2}-\alpha d{w}_{2}$，</p>
<p>　　$b=b-\alpha db$。</p>
<h1 id="逻辑回归中的梯度下降-m个样本"><a href="#逻辑回归中的梯度下降-m个样本" class="headerlink" title="逻辑回归中的梯度下降(m个样本)"></a>逻辑回归中的梯度下降(m个样本)</h1><p>　　我们所需要做的就是将单个样本的梯度下降过程进行m次并求出平均值。<br><img src="/posts/dl-4Gradient-Descent/8b725e51dcffc53a5def49438b70d925.png" alt="一轮梯度下降计算"><br>　　我们初始化$J=0,d{w_{1}}=0,d{w_{2}}=0,db=0$</p>
<p>　　代码流程：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">J=<span class="number">0</span>,dw1=<span class="number">0</span>,dw2=<span class="number">0</span>,db=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to m:</span><br><span class="line">    z(i) = wx(i)+b</span><br><span class="line">    a(i) = sigmoid(z(i))</span><br><span class="line">    J += -[y(i)log(a(i))+(<span class="number">1</span>-y(i)）log(<span class="number">1</span>-a(i))</span><br><span class="line">    dz(i) = a(i)-y(i)</span><br><span class="line">    dw1 += x1(i)dz(i)</span><br><span class="line">    dw2 += x2(i)dz(i)</span><br><span class="line">    db += dz(i)</span><br><span class="line">J/= m</span><br><span class="line">dw1/= m</span><br><span class="line">dw2/= m</span><br><span class="line">db/= m</span><br><span class="line">w=w-alpha*dw</span><br><span class="line">b=b-alpha*db</span><br></pre></td></tr></table></figure>
<p>　　然而，随着n的增大，dw的求取也需要一重循环，导致程序效率低下，故考虑向量化来摆脱循环。</p>
]]></content>
      <categories>
        <category>毕设准备</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>毕设准备</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络中的逻辑回归</title>
    <url>/posts/dl-3logistic-regression/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>课程名称：<a href="https://www.bilibili.com/video/BV164411m79z">吴恩达深度学习课程</a><br>学习资料：<a href="http://file.panjiangtao.cn/Deeplearning%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0v5.71.pdf">深度学习教程中文笔记</a></p>
          </div>
<h1 id="二分分类"><a href="#二分分类" class="headerlink" title="二分分类"></a>二分分类</h1><p>　　识别一张图片是否为猫片，如果识别这张图片为猫，则输出标签 1 作为结果；如果识别出不是猫，那么输出标签 0 作为结果。<br><img src="/posts/dl-3logistic-regression/1e664a86fa2014d5212bcb88f1c419cf.png" alt="图片像素的rgb排列"><br><a id="more"></a><br>　　为了把这些像素值放到一个特征向量中，我们需要把这些像素值提取出来，然后放入一个特征向量x。为了把这些像素值转换为特征向量 x，我们需要像下面这样定义一个特征向量 x 来表示这张图片，我们把所有的像素都取出来，例如255、231等等，直到取完所有的红色像素，接着最后是255、134、…、255、134等等，直到得到一个特征向量，把图片中所有的红、绿、蓝像素值都列出来。如果图片的大小为64x64像素，那么向量 x 的总维度，将是64乘以64乘以3，这是三个像素矩阵中像素的总量。在这个例子中结果为12,288。现在我们用$n_x$=12,288，来表示输入特征向量的维度，有时候为了简洁，我会直接用小写的n来表示输入特征向量x的维度。所以在二分类问题中，我们的目标就是习得一个分类器，它以图片的特征向量作为输入，然后预测输出结果y为1还是0，也就是预测图片中是否有猫。<br><img src="/posts/dl-3logistic-regression/55345ba411053da11ff843bbb3406369.png" alt="X、Y矩阵"><br><strong>符号定义</strong> ：<br>$x$：表示一个$n_x$维数据，为输入数据，维度为$(n_x,1)$； </p>
<p>$y$：表示输出结果，取值为$(0,1)$；</p>
<p>$(x^{(i)},y^{(i)})$：表示第$i$组数据，可能是训练数据，也可能是测试数据，此处默认为训练数据； </p>
<p>$X=[x^{(1)},x^{(2)},…,x^{(m)}]$：表示所有的训练数据集的输入值，放在一个 $n_x×m$的矩阵中，其中$m$表示样本数目; </p>
<p>$Y=[y^{(1)},y^{(2)},…,y^{(m)}]$：对应表示所有训练数据集的输出值，维度为$1×m$。</p>
<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><h2 id="假设函数（Hypothesis-Function）。"><a href="#假设函数（Hypothesis-Function）。" class="headerlink" title="假设函数（Hypothesis Function）。"></a>假设函数（Hypothesis Function）。</h2><p>　　对于二元分类问题来讲，给定一个输入特征向量$X$，它可能对应一张图片，你想识别这张图片识别看它是否是一只猫或者不是一只猫的图片，你想要一个算法能够输出预测，你只能称之为$\hat{y}$，也就是你对实际值 $y$ 的估计。更正式地来说，你想让 $\hat{y}$ 表示 $y$ 等于1的一种可能性或者是机会，前提条件是给定了输入特征$X$。换句话来说，如果$X$是我们在上个视频看到的图片，你想让$\hat{y}$ 来告诉你这是一只猫的图片的机率有多大。在之前的视频中所说的，$X$是一个$n_x$维的向量（相当于有$n_x$个特征的特征向量）。我们用$w$来表示逻辑回归的参数，这也是一个$n_x$维向量（因为$w$实际上是特征权重，维度与特征向量相同），参数里面还有$b$，这是一个实数（表示偏差）。所以给出输入$x$以及参数$w$和$b$之后，我们怎样产生输出预测值$\hat{y}$，一件你可以尝试却不可行的事是让$\hat{y}=w^{T}x+b$。<br><img src="/posts/dl-3logistic-regression/dfb5731c30b81eced917450d31e860a3.png" alt="逻辑回归表达式"><br>　　这是一个线性函数，但是我们期待的$\hat{y}$是一个介于0到1的函数，因此引入了<strong>sigmoid</strong>函数。下图是<strong>sigmoid</strong>函数的图像，如果我把水平轴作为$z$轴，那么关于$z$的<strong>sigmoid</strong>函数是这样的，它是平滑地从0走向1，让我在这里标记纵轴，这是0，曲线与纵轴相交的截距是0.5，这就是关于$z$的<strong>sigmoid</strong>函数的图像。我们通常都使用$z$来表示$w^{T}x+b$的值，其中b是拦截器。<br><img src="/posts/dl-3logistic-regression/7e304debcca5945a3443d56bcbdd2964.png" alt="sigmoid函数"><br>　　<strong>sigmoid</strong>函数的公式是这样的，$\sigma ( z )=\frac{1}{1+e^{-z}}$,在这里$z$是一个实数，这里要说明一些要注意的事情，如果$z$非常大那么$e^{-z}$将会接近于0，关于$z$的<strong>sigmoid</strong>函数将会近似等于1除以1加上某个非常接近于0的项，因为$e$ 的指数如果是个绝对值很大的负数的话，这项将会接近于0，所以如果$z$很大的话那么关于$z$的<strong>sigmoid</strong>函数会非常接近1。相反地，如果$z$非常小或者说是一个绝对值很大的负数，那么关于$e^{-z}$这项会变成一个很大的数，你可以认为这是1除以1加上一个非常非常大的数，所以这个就接近于0。实际上你看到当$z$变成一个绝对值很大的负数，关于$z$的<strong>sigmoid</strong>函数就会非常接近于0，因此当你实现逻辑回归时，你的工作就是去让机器学习参数$w$以及$b$这样才使得$\hat{y}$成为对$y=1$这一情况的概率的一个很好的估计。</p>
<hr>
<p>　　我们需要训练一个代价函数来得到参数$w$和参数$b$。下图为逻辑回归的输出函数。<br><img src="/posts/dl-3logistic-regression/4c9a27b071ce9162dbbcdad3393061d2.png" alt="逻辑回归输出函数"><br>　　通过$m$个样本的训练，找到参数$w$和参数$b$，将训练集的预测值记为$\hat{y}$，上面的定义是对一个训练样本来说的，这种形式也使用于每个训练样本。训练样本$i$所对应的预测值是$y^{(i)}$,是用训练样本的$w^{T}x^{(i)}+b$然后通过<strong>sigmoid</strong>函数来得到，也可以把$z$定义为$z^{(i)}=w^{T}x^{(i)}+b$。</p>
<h2 id="损失函数-Loss-function"><a href="#损失函数-Loss-function" class="headerlink" title="损失函数 (Loss function)"></a>损失函数 (Loss function)</h2><p>　　损失函数又叫做误差函数，用来衡量算法的运行情况，<strong>Loss function:$L( \hat{y},y )$.</strong><br>　　我们在逻辑回归中用到的损失函数是：<strong>$L( \hat{y},y )=-y\log\hat{y}-(1-y)\log (1-\hat{y})$</strong>。</p>
<p>　　(1) 当$y=1$时$L=-\log (\hat{y})$，如果想要损失函数$L$尽可能得小，那么$\hat{y}$就要尽可能大，因为<strong>sigmoid</strong>函数取值$[0,1]$，所以$\hat{y}$会无限接近于1。</p>
<p>　　(2) 当$y=0$时$L=-\log (1-\hat{y})$，如果想要损失函数$L$尽可能得小，那么$\hat{y}$就要尽可能小，因为<strong>sigmoid</strong>函数取值$[0,1]$，所以$\hat{y}$会无限接近于0。</p>
<h2 id="代价函数-Cost-function"><a href="#代价函数-Cost-function" class="headerlink" title="代价函数 (Cost function)"></a>代价函数 (Cost function)</h2><p>　　为了衡量算法在全部训练样本上的表现如何，我们需要定义一个算法的代价函数，算法的代价函数是对$m$个样本的损失函数求和然后除以$m$：</p>
<p><strong>$J( w,b )=\frac{1}{m}\sum\limits_{i=1}^{m}{L( \hat{y}^{(i)},y^{(i)} )}=\frac{1}{m}\sum\limits_{i=1}^{m}{[-y^{(i)}\log \hat{y}^{(i)}-(1-y^{(i)})\log (1-\hat{y}^{(i)})]}$</strong></p>
<p>　　损失函数只适用于像这样的单个训练样本，而代价函数是参数的总代价。</p>
]]></content>
      <categories>
        <category>毕设准备</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>毕设准备</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络介绍</title>
    <url>/posts/dl-2Neural-Networks/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>课程名称：<a href="https://www.bilibili.com/video/BV164411m79z">吴恩达深度学习课程</a><br>学习资料：<a href="http://file.panjiangtao.cn/Deeplearning%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0v5.71.pdf">深度学习教程中文笔记</a></p>
          </div>
<h1 id="基本神经网络"><a href="#基本神经网络" class="headerlink" title="基本神经网络"></a>基本神经网络</h1><p>房价预测问题：<br><img src="/posts/dl-2Neural-Networks/3fe6da26014467243e3d499569be3675.png" alt="房价预测函数"><br>　　从趋近于零开始，然后变成一条直线。这个函数被称作 <strong>ReLU</strong> 激活函数，它的全称是Rectified Linear Unit。rectify（修正）可以理解成𝑚𝑎𝑥(0, 𝑥)，这也是你得到一个这种形状的函数的原因。<br><a id="more"></a></p>
<p><img src="/posts/dl-2Neural-Networks/7a0e0d40f4ba80a0466f0bd7aa9f8537.png" alt="神经网络预测房价"><br>　　图上每一个画的小圆圈都可以是<strong>ReLU</strong>的一部分，也就是指修正线性单元，或者其它稍微非线性的函数。基于房屋面积和卧室数量，可以估算家庭人口，基于邮编，可以估测步行化程度或者学校的质量。最后你可能会这样想，这些决定人们乐意花费多少钱。</p>
<p>　　神经网络的一部分神奇之处在于，当你实现它之后，你要做的只是输入x，就能得到输出y。因为它可以自己计算你训练集中样本的数目以及所有的中间过程。</p>
<h1 id="神经网络的监督学习-Supervised-Learning-with-Neural-Networks"><a href="#神经网络的监督学习-Supervised-Learning-with-Neural-Networks" class="headerlink" title="神经网络的监督学习(Supervised Learning with Neural Networks)"></a>神经网络的监督学习(Supervised Learning with Neural Networks)</h1><p>　　在监督学习中你有一些输入𝑥，你想学习到一个函数来映射到一些输出𝑦，比如我们之前提到的房价预测的例子，你只要输入有关房屋的一些特征，试着去输出或者估计价格𝑦。我们举一些其它的例子，来说明神经网络已经被高效应用到其它地方。<br><img src="/posts/dl-2Neural-Networks/QQ截图20210219142516.jpg" alt="监督学习应用"></p>
<ul>
<li>对于图像应用，我们经常在神经网络上使用卷积（Convolutional Neural Network），通常缩写为 CNN。</li>
</ul>
<p><img src="/posts/dl-2Neural-Networks/1bebe0ac41715ef8132f2d802968495c.png" alt="卷积神经网络模型"></p>
<ul>
<li>对于序列数据，例如音频，有一个时间组件，随着时间的推移，音频被播放出来，所以音频是最自然的表现。作为一维时间序列（两种英文说法 one-dimensional time series / temporal sequence）。对于序列数据，经常使用 RNN，一种递归神经网络（Recurrent Neural Network），语言，英语和汉语字母表或单词都是逐个出现的，所以语言也是最自然的序列数据，因此更复杂的 RNNs 版本经常用于这些应用。</li>
</ul>
<p><img src="/posts/dl-2Neural-Networks/4656617e30e7ad44490fe605b2e49e56.png" alt="递归神经网络模型"></p>
<h1 id="深度学习的发展"><a href="#深度学习的发展" class="headerlink" title="深度学习的发展"></a>深度学习的发展</h1><p>　　多亏数字化社会的来临，现在的数据量都非常巨大，我们花了很多时间活动在这些数字的领域，比如在电脑网站上、在手机软件上以及其它数字化的服务，它们都能创建数据，同时便宜的相机被配置到移动电话，还有加速仪及各类各样的传感器，同时在物联网领域我们也收集到了越来越多的数据。仅仅在过去的20年里对于很多应用，我们便收集到了大量的数据，远超过机器学习算法能够高效发挥它们优势的规模。</p>
<p>　　事实上如今最可靠的方法来在神经网络上获得更好的性能，往往就是<strong>要么训练一个更大的神经网络，要么投入更多的数据</strong>，这只能在一定程度上起作用，因为最终你耗尽了数据，或者最终你的网络是如此大规模导致将要用太久的时间去训练，但是仅仅提升规模的的确确地让我们在深度学习的世界中摸索了很多时间。<br><img src="/posts/dl-2Neural-Networks/2b14edfcb21235115fca05879f8d9de2.png" alt="深度学习规模大小带来的性能影响"></p>
<p>　　作为一个具体的例子，神经网络方面的一个巨大突破是从<strong>sigmoid</strong>函数转换到一个<strong>ReLU</strong>函数。<br><img src="/posts/dl-2Neural-Networks/1a3d288dc243ca9c5a70a69799180c4a.png" alt="sigmoid函数和ReLU函数"><br>　　可以知道的一个使用<strong>sigmoid</strong>函数和机器学习问题是，在这个区域，也就是这个<strong>sigmoid</strong>函数的梯度会接近零，所以学习的速度会变得非常缓慢，因为当你实现梯度下降以及梯度接近零的时候，参数会更新的很慢，所以学习的速率也会变的很慢，而通过改变这个被叫做激活函数的东西，神经网络换用这一个函数，叫做<strong>ReLU</strong>的函数（修正线性单元），<strong>ReLU</strong>它的梯度对于所有输入的负值都是零，因此梯度更加不会趋向逐渐减少到零。而这里的梯度，这条线的斜率在这左边是零，仅仅通过将<strong>Sigmod</strong>函数转换成<strong>ReLU</strong>函数，便能够使得一个叫做梯度下降（<strong>gradient descent</strong>）的算法运行的更快，这就是一个或许相对比较简单的算法创新的例子。</p>
]]></content>
      <categories>
        <category>毕设准备</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>毕设准备</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习引言</title>
    <url>/posts/dl-1definition/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>课程名称：<a href="https://www.bilibili.com/video/BV164411b7dx">吴恩达机器学习课程</a></p>
          </div>
<h1 id="机器学习-machine-learning-定义"><a href="#机器学习-machine-learning-定义" class="headerlink" title="机器学习(machine learning)定义"></a>机器学习(machine learning)定义</h1><ul>
<li>Arther Samuel(1959):Machine Learning:Field fo study that gives computers the ability to learn without being explicitly programmed.</li>
<li>Tom Mitchell(1998) well-posed Learning Problem: A computer program is said to learn from experience E with respect to some task T and some performance measure P, if its improves with experience E.</li>
</ul>
<p>　　在跳棋游戏中，E-&gt;程序和自己下上万次棋，T-&gt;玩跳棋，P-&gt;与新对手下棋赢的概率。<br><a id="more"></a></p>
<h1 id="机器学习算法分类"><a href="#机器学习算法分类" class="headerlink" title="机器学习算法分类"></a>机器学习算法分类</h1><h2 id="一、监督学习-Supervised-learning"><a href="#一、监督学习-Supervised-learning" class="headerlink" title="　一、监督学习(Supervised learning)"></a>　一、监督学习(Supervised learning)</h2><h3 id="1-回归问题-Regression-problem-预测出一个连续值的输出。"><a href="#1-回归问题-Regression-problem-预测出一个连续值的输出。" class="headerlink" title="(1)回归问题(Regression problem):预测出一个连续值的输出。"></a>(1)回归问题(Regression problem):预测出一个连续值的输出。</h3><p>例如：预测房价问题，根据样本的数据集进行拟合就可以得到一条连续的曲线。<br><img src="https://pic1.zhimg.com/80/v2-7497b88c2931c082a5bf6334f54b147c_720w.jpg" alt="房价预测"></p>
<h3 id="2-分类问题-Classification-problem-预测出一个离散值的输出。"><a href="#2-分类问题-Classification-problem-预测出一个离散值的输出。" class="headerlink" title="(2)分类问题(Classification problem):预测出一个离散值的输出。"></a>(2)分类问题(Classification problem):预测出一个离散值的输出。</h3><p>例子：根据肿瘤的某些特征来判断是良性还是恶性，得到的结果是“良性”或者是“恶性”，是离散的。<br><img src="https://pic4.zhimg.com/80/v2-7e1eb4d75ea5d8fb6b3cba72addeffef_720w.jpg" alt="肿瘤预测-单变量"><br><img src="https://pic3.zhimg.com/80/v2-c11e632cb62e2351541647412b0b546e_720w.jpg" alt="肿瘤预测-多变量"></p>
<h2 id="二、无监督学习-Unsupervised-learning"><a href="#二、无监督学习-Unsupervised-learning" class="headerlink" title="　二、无监督学习(Unsupervised learning)"></a>　二、无监督学习(Unsupervised learning)</h2><p>　　无监督学习的数据集和监督学习的不同，没任何标签，也就是<strong>没有“正确的输出结果”</strong>。在此过程中没有指导者，只有计算机自己学习。</p>
<h3 id="聚类算法-Clustering-algorithms"><a href="#聚类算法-Clustering-algorithms" class="headerlink" title="聚类算法(Clustering algorithms)"></a>聚类算法(Clustering algorithms)</h3><p>　　从数据集中可以通过非监督学习得到数据的某种结构，可能是把数据分成两个不同的聚集簇，称为聚类算法。<br>应用：</p>
<ul>
<li>Google新闻将相似新闻分类</li>
<li>基因学将有相同基因序列的个体分为一类</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-0e62546b76127accdbcd984d89ff7ed1_720w.jpg" alt="DNA微阵列数据"></p>
<h3 id="盲信号分离算法"><a href="#盲信号分离算法" class="headerlink" title="盲信号分离算法"></a>盲信号分离算法</h3><ul>
<li>鸡尾酒会问题(Cocktail party problem):两人在说话，两个麦克风离两人距离不同，从每段麦克风录制的音频中分离出两个人各自的声音。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-61819fa6432378a1b42e03f6be07b8b7_720w.jpg" alt="鸡尾酒会问题"><br>实现该音频处理只需如下代码：<br><img src="https://pic1.zhimg.com/80/v2-ff9409c9b9439df1af1e03a11f429d4c_720w.jpg" alt="音频分离代码"><br>其中：SVD()函数——奇异值分解的缩写，作为线性代数常规函数的缩写,内置于Octave软件中。</p>
]]></content>
      <categories>
        <category>毕设准备</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>毕设准备</tag>
      </tags>
  </entry>
  <entry>
    <title>使用AWS Deep Learning Containers在Amazon EC2上训练深度学习模型</title>
    <url>/posts/aws-4deepl/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>参考文章：<a href="https://aws.amazon.com/cn/getting-started/hands-on/train-deep-learning-model-aws-ec2-containers/">Train deep learning model AWS EC2 containers</a></p>
          </div>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>AWS Deep Learning Containers (DL Containers)是预先安装了深度学习框架的 Docker 镜像，可以跳过从头构建和优化环境的复杂流程，轻松快速部署自定义机器学习环境。</li>
<li>利用AWS DL Containers，开发人员和数据科学家可以为其部署在 Amazon Elastic Container Service for Kubernetes (Amazon EKS)、自行管理的Kubernetes、Amazon Elastic Container Service (Amazon ECS) 和 Amazon EC2 上的容器化应用程序添加机器学习功能。</li>
<li>本文中我们将使用 AWS Deep Learning Containers 在 Amazon EC2 实例上训练一个 TensorFlow 机器学习模型。由于还未学习TensorFlow 机器学习模型的建立和使用，故文中使用AWS官方给出的样例。<a id="more"></a>
</li>
</ul>
<h1 id="一、添加访问Amazon-ECR的权限"><a href="#一、添加访问Amazon-ECR的权限" class="headerlink" title="一、添加访问Amazon ECR的权限"></a>一、添加访问Amazon ECR的权限</h1><h2 id="1-导航到-IAM-控制台"><a href="#1-导航到-IAM-控制台" class="headerlink" title="1. 导航到 IAM 控制台"></a>1. 导航到 IAM 控制台</h2><p>打开 AWS 管理控制台，以便使本分步指南处于打开状态。此屏幕加载后，请输入用户名和密码以便开始操作。在搜索栏中输入 IAM，然后选择 <strong>IAM</strong> 以便打开服务控制台。<br><img src="/posts/aws-4deepl/1a.png" alt="导航到 IAM 控制台"></p>
<h2 id="2-选择用户"><a href="#2-选择用户" class="headerlink" title="2. 选择用户"></a>2. 选择用户</h2><p>在左侧导航窗格中，选择<strong>用户</strong>。<br><img src="/posts/aws-4deepl/1b.png" alt="选择用户"></p>
<h2 id="3-添加权限"><a href="#3-添加权限" class="headerlink" title="3. 添加权限"></a>3. 添加权限</h2><p>现在，为所创建的新 IAM 用户或现有 IAM 用户添加权限。在 IAM 用户摘要页面上选择<strong>添加权限</strong>。<br><img src="/posts/aws-4deepl/1c.png" alt="添加权限"></p>
<h2 id="4-添加-ECS-完全访问策略"><a href="#4-添加-ECS-完全访问策略" class="headerlink" title="4. 添加 ECS 完全访问策略"></a>4. 添加 ECS 完全访问策略</h2><p>选择<strong>直接附加现有策略</strong>，搜索 ECS_FullAccess。选择 <strong>Amazon_FullAccess</strong> 策略，依次单击<strong>查看</strong>和<strong>添加权限</strong>。<br><img src="/posts/aws-4deepl/1d.png" alt="添加 ECS 完全访问策略"></p>
<h2 id="5-添加内联策略"><a href="#5-添加内联策略" class="headerlink" title="5. 添加内联策略"></a>5. 添加内联策略</h2><p>在 IAM 用户摘要页面上选择<strong>添加内联策略</strong>。<br><img src="/posts/aws-4deepl/1e.png" alt="添加内联策略"></p>
<h2 id="6-粘贴-JSON-策略"><a href="#6-粘贴-JSON-策略" class="headerlink" title="6. 粘贴 JSON 策略"></a>6. 粘贴 JSON 策略</h2><p>选择 <strong>JSON</strong> 选项卡并粘贴以下策略：<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       <span class="attr">&quot;Version&quot;</span>: <span class="string">&quot;2012-10-17&quot;</span>,</span><br><span class="line">       <span class="attr">&quot;Statement&quot;</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                     <span class="attr">&quot;Action&quot;</span>: <span class="string">&quot;ecr:*&quot;</span>,</span><br><span class="line">                     <span class="attr">&quot;Effect&quot;</span>: <span class="string">&quot;Allow&quot;</span>,</span><br><span class="line">                     <span class="attr">&quot;Resource&quot;</span>: <span class="string">&quot;*&quot;</span></span><br><span class="line">              &#125;</span><br><span class="line">       ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>将此策略另存为 “ECR”，然后选择<strong>创建策略</strong>。<br><img src="/posts/aws-4deepl/1f.png" alt="粘贴 JSON 策略"></p>
<h1 id="二、启动一个-AWS-Deep-Learning-Base-AMI-实例"><a href="#二、启动一个-AWS-Deep-Learning-Base-AMI-实例" class="headerlink" title="二、启动一个 AWS Deep Learning Base AMI 实例"></a>二、启动一个 AWS Deep Learning Base AMI 实例</h1><p>在本文中，我们将在 AWS Deep Learning Base Amazon Machine Images (AMIs) 上使用 AWS Deep Learning Containers，这些容器预先打包了必要的依赖项，例如 Nvidia 驱动程序、docker 和 nvidia-docker。可以使用这些软件包在任何 AMI 上运行 Deep Learning Containers。</p>
<h2 id="1-导航到EC2控制台"><a href="#1-导航到EC2控制台" class="headerlink" title="1. 导航到EC2控制台"></a>1. 导航到EC2控制台</h2><p>返回到 AWS 管理控制台，在搜索栏中输入 EC2，并选择 <strong>EC2</strong>以打开服务控制台。<br><img src="/posts/aws-4deepl/2a.png" alt="导航到EC2控制台"></p>
<h2 id="2-启动一个-Amazon-EC2-实例"><a href="#2-启动一个-Amazon-EC2-实例" class="headerlink" title="2. 启动一个 Amazon EC2 实例"></a>2. 启动一个 Amazon EC2 实例</h2><p>再次导航到 Amazon EC2 控制台，然后选择 <strong>Launch Instance</strong>（启动实例）按钮。<br><img src="/posts/aws-4deepl/2b.png" alt="启动一个 Amazon EC2 实例"></p>
<h2 id="3-选择-AWS-Deep-Learning-Base-AMI"><a href="#3-选择-AWS-Deep-Learning-Base-AMI" class="headerlink" title="3. 选择 AWS Deep Learning Base AMI"></a>3. 选择 AWS Deep Learning Base AMI</h2><p>选择左侧的 <strong>AWS Marketplace</strong> 选项卡，然后搜索“deep learning base ubuntu”。选择 <strong>Deep Learning Base AMI (Ubuntu)</strong>。还可以选择 <strong>Deep Learning Base AMI (Amazon Linux)</strong>。<br><img src="/posts/aws-4deepl/2c.png" alt="选择 AWS Deep Learning Base AMI"></p>
<h2 id="4-选择实例类型"><a href="#4-选择实例类型" class="headerlink" title="4. 选择实例类型"></a>4. 选择实例类型</h2><p>选择 Amazon EC2 实例类型。Amazon Elastic Compute Cloud (EC2) 是用于在云中创建和运行虚拟机的 Amazon Web 服务。AWS 将这些虚拟机称为“实例”。可以选择c5.large或基于GPU 的 P3 实例。</p>
<p>选择<strong>检查和启动</strong>。<br><img src="/posts/aws-4deepl/2d.png" alt="选择实例类型"></p>
<h2 id="5-启动实例"><a href="#5-启动实例" class="headerlink" title="5. 启动实例"></a>5. 启动实例</h2><p>查看实例的详细信息，然后选择<strong>启动</strong>。<br><img src="/posts/aws-4deepl/2e.png" alt="启动实例"></p>
<h2 id="6-创建一个新的私钥文件"><a href="#6-创建一个新的私钥文件" class="headerlink" title="6. 创建一个新的私钥文件"></a>6. 创建一个新的私钥文件</h2><ul>
<li><p>在下一个屏幕中，系统会要求选择现有密钥对或创建新的密钥对。可以使用密钥对通过 SSH 安全访问实例。AWS 会存储密钥对的公有部分，该部分密钥的作用就像门锁。需下载并使用密钥对的私有部分，该部分密钥的作用就像门锁钥匙。</p>
</li>
<li><p>选择<strong>创建新密钥对</strong>，并为其命名。然后选择<strong>下载密钥对</strong>，并将密钥存储在安全的位置。如果丢失密钥，就无法访问该实例。如果他人获得密钥，他们就能够访问该实例。</p>
</li>
<li><p>如果以前创建了私钥文件，并且现在仍可访问，则可以选择选择<strong>现有的密钥对</strong>，使用现有私钥。</p>
</li>
</ul>
<p><img src="/posts/aws-4deepl/2f.png" alt="创建一个新的私钥文件"></p>
<h2 id="7-查看实例详情"><a href="#7-查看实例详情" class="headerlink" title="7. 查看实例详情"></a>7. 查看实例详情</h2><p>选择<strong>实例ID</strong>，在控制台上查看新创建的 Amazon EC2 的详细信息。<br><img src="/posts/aws-4deepl/2g.png" alt="查看实例详情"></p>
<h1 id="三、连接到实例"><a href="#三、连接到实例" class="headerlink" title="三、连接到实例"></a>三、连接到实例</h1><p>在此步骤中，将使用 SSH 连接到新启动的实例。以下说明使用 Mac/Linux 环境。如果使用的是 Windows，请按照<a href="https://aws.amazon.com/cn/getting-started/hands-on/launch-a-virtual-machine/">教程</a>完成。</p>
<h2 id="1-找到实例的公共-DNS-并复制"><a href="#1-找到实例的公共-DNS-并复制" class="headerlink" title="1. 找到实例的公共 DNS 并复制"></a>1. 找到实例的公共 DNS 并复制</h2><p>在<strong>说明</strong>选项卡下，复制 Amazon EC2 实例的公共 DNS (IPv4)。<br><img src="/posts/aws-4deepl/3a.png" alt="找到实例的公共 DNS 并复制"></p>
<h2 id="2-打开命令行终端"><a href="#2-打开命令行终端" class="headerlink" title="2. 打开命令行终端"></a>2. 打开命令行终端</h2><p>在终端中使用以下命令更改为安全密钥所在的目录，然后使用 SSH 连接实例。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cd /Users/<span class="xml"><span class="tag">&lt;<span class="name">your_username</span>&gt;</span>/Downloads/</span></span><br><span class="line"></span><br><span class="line">chmod 0400 &lt;your .pem filename&gt;</span><br><span class="line"></span><br><span class="line">ssh -L localhost:8888:localhost:8888 -i &lt;your .pem filename&gt; ubuntu@&lt;your instance DNS&gt;</span><br></pre></td></tr></table></figure><br><img src="/posts/aws-4deepl/3b.png" alt="打开命令行终端"></p>
<h1 id="四、登录到-Amazon-ECR"><a href="#四、登录到-Amazon-ECR" class="headerlink" title="四、登录到 Amazon ECR"></a>四、登录到 Amazon ECR</h1><p>AWS Deep Learning Container 映像托管在 Amazon Elastic Container Registry (ECR) 上，这是一个完全托管的 Docker 容器注册表，让开发人员可以轻松存储、管理和部署 Docker 容器映像。在此步骤中，将登录并验证能否正常访问 Amazon ECR。</p>
<h2 id="1-使用-AWS-凭证配置-EC2-实例"><a href="#1-使用-AWS-凭证配置-EC2-实例" class="headerlink" title="1. 使用 AWS 凭证配置 EC2 实例"></a>1. 使用 AWS 凭证配置 EC2 实例</h2><p>需要提供AWS 访问密钥 ID 和秘密访问密钥。如果还没有这些信息，则可以在<a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.html#Using_CreateAccessKey">此处</a>创建访问密钥 ID 和秘密访问密钥。<br><img src="/posts/aws-4deepl/4a.png" alt="使用 AWS 凭证配置 EC2 实例"></p>
<h2 id="2-登录到-Amazon-ECR"><a href="#2-登录到-Amazon-ECR" class="headerlink" title="2. 登录到 Amazon ECR"></a>2. 登录到 Amazon ECR</h2><p>使用以下命令登录到 Amazon ECR：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(aws ecr get-login --region us-east<span class="number">-1</span> --no-include-email --registry-ids <span class="number">763104351884</span>)</span><br></pre></td></tr></table></figure><br><strong>注意</strong>：需要在命令中包含“$”和圆括号。完成此步骤后，将看到“登录成功”。<br><img src="/posts/aws-4deepl/4b.png" alt="登录到 Amazon ECR"></p>
<h1 id="五、使用-Deep-Learning-Containers-运行-TensorFlow-训练"><a href="#五、使用-Deep-Learning-Containers-运行-TensorFlow-训练" class="headerlink" title="五、使用 Deep Learning Containers 运行 TensorFlow 训练"></a>五、使用 Deep Learning Containers 运行 TensorFlow 训练</h1><p>在此步骤中，我们将使用 AWS Deep Learning Container 映像，通过 Python 3.6 在 CPU 实例上进行 TensorFlow 训练。</p>
<h2 id="1-运行-AWS-Deep-Learning-Containers"><a href="#1-运行-AWS-Deep-Learning-Containers" class="headerlink" title="1.运行 AWS Deep Learning Containers"></a>1.运行 AWS Deep Learning Containers</h2><p>现在，使用以下命令在 EC2 实例上运行 AWS Deep Learning Container 映像。如果 Deep Learning Container 映像在本地不存在，则此命令将自动提取该映像。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">docker run -it <span class="number">763104351884.</span>dkr.ecr.us-east<span class="number">-1.</span>amazonaws.com/tensorflow-training:<span class="number">1.13</span>-cpu-py36-ubuntu16<span class="number">.04</span></span><br></pre></td></tr></table></figure><br><strong>注意</strong>：此步骤可能需要几分钟，具体取决于映像的大小。如果使用的是 GPU 实例，请使用“nvidia-docker”而非“docker”。 成功完成此步骤后，将为容器进入一个 bash 提示符界面。<br><img src="/posts/aws-4deepl/5a.png" alt="运行 AWS Deep Learning Containers"></p>
<h2 id="2-拉取一个示例模型进行训练"><a href="#2-拉取一个示例模型进行训练" class="headerlink" title="2.拉取一个示例模型进行训练"></a>2.拉取一个示例模型进行训练</h2><p>我们将克隆 Keras 存储库，其中包括用于训练模型的示例 Python 脚本。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git clone https:<span class="comment">//github.com/fchollet/keras.git</span></span><br></pre></td></tr></table></figure><br><img src="/posts/aws-4deepl/5b.png" alt="拉取一个示例模型进行训练"></p>
<h2 id="3-开始训练"><a href="#3-开始训练" class="headerlink" title="3. 开始训练"></a>3. 开始训练</h2><p>使用以下命令开始训练规范的 MNIST CNN 模型：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">python keras/examples/mnist_cnn.py</span><br></pre></td></tr></table></figure><br>已经成功使用 AWS Deep Learning Container 开始了训练。<br><img src="/posts/aws-4deepl/5c.png" alt="开始训练"></p>
<h1 id="六、终止资源"><a href="#六、终止资源" class="headerlink" title="六、终止资源"></a>六、终止资源</h1><p>在此步骤中，将终止在本教程中创建的 Amazon EC2 实例。</p>
<p><strong>注意</strong>：终止当前未在使用的资源可降低成本，这是最佳实践。不终止资源可能会在账户下产生费用。</p>
<h2 id="1-选择正在运行的实例"><a href="#1-选择正在运行的实例" class="headerlink" title="1.选择正在运行的实例"></a>1.选择正在运行的实例</h2><p>在 Amazon EC2 控制台上，选择<strong>正在运行的实例</strong>。<br><img src="/posts/aws-4deepl/6a.png" alt="选择正在运行的实例"></p>
<h2 id="2-终止EC2实例"><a href="#2-终止EC2实例" class="headerlink" title="2.终止EC2实例"></a>2.终止EC2实例</h2><p>选择之前创建的 EC2 实例，再选择<strong>操作 &gt; 实例状态 &gt; 终止</strong>。<br><img src="/posts/aws-4deepl/6b.png" alt="终止EC2实例"></p>
<h2 id="3-确认终止"><a href="#3-确认终止" class="headerlink" title="3. 确认终止"></a>3. 确认终止</h2><p>系统会提示确认终止。选择<strong>是，终止</strong>。</p>
<p><strong>注意</strong>：完成此过程可能需要几秒钟。终止实例后，EC2 控制台上的“实例状态”会变为“已终止”。<br><img src="/posts/aws-4deepl/6c.png" alt="确认终止"></p>
]]></content>
      <categories>
        <category>云服务</category>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>云服务</tag>
        <tag>AWS</tag>
        <tag>亚马逊</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>使用AWS Systems Manager在EC2实例上远程运行命令</title>
    <url>/posts/aws-3manager/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>参考文章：<a href="https://aws.amazon.com/cn/getting-started/hands-on/remotely-run-commands-ec2-instance-systems-manager/">Remotely run commands EC2 instance systems manager</a></p>
          </div>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>本文介绍如何使用 AWS Systems Manager 在 Amazon EC2 实例上远程运行命令。Systems Manager 是一种管理工具，可以用它来了解 AWS 资源的运行状况，并以安全且规模化的方式对 AWS 资源采取措施。使用 Systems Manager 的一种自动化功能 Run Command 时，无需使用堡垒主机、SSH 或远程 PowerShell，从而可以简化管理任务。</li>
<li>为解决团队不允许通过 SSH 或使用堡垒主机直接访问生产服务器的问题，我们将创建 Identity and Access Management (IAM) 角色，在实例上启动一个与 Systems Manager 通信的代理，然后遵循通过运行 AWS-UpdateSSMAgent 文档升级 Systems Manager 代理的最佳实践，最后使用 Systems Manager 在实例上运行命令。<a id="more"></a>
</li>
</ul>
<h1 id="一、创建Identity-and-Access-Management-IAM-角色"><a href="#一、创建Identity-and-Access-Management-IAM-角色" class="headerlink" title="一、创建Identity and Access Management(IAM)角色"></a>一、创建Identity and Access Management(IAM)角色</h1><h2 id="1-打开IAM控制台"><a href="#1-打开IAM控制台" class="headerlink" title="1. 打开IAM控制台"></a>1. 打开<a href="https://console.aws.amazon.com/iam/">IAM控制台</a></h2><p><img src="/posts/aws-3manager/1a.png" alt="IAM控制台"></p>
<h2 id="2-从左侧导航窗格中选择Roles（角色），然后选择Create-role（创建角色）。"><a href="#2-从左侧导航窗格中选择Roles（角色），然后选择Create-role（创建角色）。" class="headerlink" title="2. 从左侧导航窗格中选择Roles（角色），然后选择Create role（创建角色）。"></a>2. 从左侧导航窗格中选择<strong>Roles</strong>（角色），然后选择<strong>Create role</strong>（创建角色）。</h2><p><img src="/posts/aws-3manager/1b.png" alt="创建角色"></p>
<h2 id="3-在选择受信任实体的类型页面上，在AWS-服务下选择EC2，然后选择下一步-权限。"><a href="#3-在选择受信任实体的类型页面上，在AWS-服务下选择EC2，然后选择下一步-权限。" class="headerlink" title="3. 在选择受信任实体的类型页面上，在AWS 服务下选择EC2，然后选择下一步: 权限。"></a>3. 在选择受信任实体的类型页面上，在<strong>AWS 服务</strong>下选择<strong>EC2</strong>，然后选择<strong>下一步: 权限</strong>。</h2><p><img src="/posts/aws-3manager/1c.png" alt="受信任实体"></p>
<h2 id="4-在Attached-permissions-policy（附加的权限策略）页面上的搜索栏中输入-AmazonEC2RoleforSSM，然后从策略列表中选择AmazonEC2RoleforSSM，然后选择Next-Review（下一步：审核）。"><a href="#4-在Attached-permissions-policy（附加的权限策略）页面上的搜索栏中输入-AmazonEC2RoleforSSM，然后从策略列表中选择AmazonEC2RoleforSSM，然后选择Next-Review（下一步：审核）。" class="headerlink" title="4. 在Attached permissions policy（附加的权限策略）页面上的搜索栏中输入 AmazonEC2RoleforSSM，然后从策略列表中选择AmazonEC2RoleforSSM，然后选择Next: Review（下一步：审核）。"></a>4. 在<strong>Attached permissions policy</strong>（附加的权限策略）页面上的搜索栏中输入 AmazonEC2RoleforSSM，然后从策略列表中选择<strong>AmazonEC2RoleforSSM</strong>，然后选择<strong>Next: Review</strong>（下一步：审核）。</h2><p><img src="/posts/aws-3manager/1d.png" alt="AmazonEC2RoleforSSM"></p>
<h2 id="5-在Review（审核）页面上的Role-name（角色名称）框中键入-EnablesEC2ToAccessSystemsManagerRole。在Role-description（角色描述）框中键入-Enables-an-EC2-instance-to-access-Systems-Manager。选择Create-role（创建角色）。"><a href="#5-在Review（审核）页面上的Role-name（角色名称）框中键入-EnablesEC2ToAccessSystemsManagerRole。在Role-description（角色描述）框中键入-Enables-an-EC2-instance-to-access-Systems-Manager。选择Create-role（创建角色）。" class="headerlink" title="5. 在Review（审核）页面上的Role name（角色名称）框中键入 EnablesEC2ToAccessSystemsManagerRole。在Role description（角色描述）框中键入 Enables an EC2 instance to access Systems Manager。选择Create role（创建角色）。"></a>5. 在<strong>Review</strong>（审核）页面上的<strong>Role name</strong>（角色名称）框中键入 EnablesEC2ToAccessSystemsManagerRole。在<strong>Role description</strong>（角色描述）框中键入 Enables an EC2 instance to access Systems Manager。选择<strong>Create role</strong>（创建角色）。</h2><p><img src="/posts/aws-3manager/1e.png" alt="角色描述"></p>
<h1 id="二、创建EC2实例"><a href="#二、创建EC2实例" class="headerlink" title="二、创建EC2实例"></a>二、创建EC2实例</h1><p>此过程在<a href="http://www.panjiangtao.cn/posts/aws-1register/">AWS服务的注册和创建主机</a>已介绍，在此不加赘述。</p>
<h1 id="三、更新-Systems-Manager-代理"><a href="#三、更新-Systems-Manager-代理" class="headerlink" title="三、更新 Systems Manager 代理"></a>三、更新 Systems Manager 代理</h1><h2 id="1-单击顶部菜单中的Services（服务）。然后在“Management-Tools”（管理工具）下，选择-Systems-Manager-以打开-Systems-Manager-控制台。"><a href="#1-单击顶部菜单中的Services（服务）。然后在“Management-Tools”（管理工具）下，选择-Systems-Manager-以打开-Systems-Manager-控制台。" class="headerlink" title="1. 单击顶部菜单中的Services（服务）。然后在“Management Tools”（管理工具）下，选择 Systems Manager 以打开 Systems Manager 控制台。"></a>1. 单击顶部菜单中的<strong>Services</strong>（服务）。然后在“Management Tools”（管理工具）下，选择 Systems Manager 以打开 Systems Manager 控制台。</h2><p><img src="/posts/aws-3manager/3a.png" alt="Systems Manager 控制台"></p>
<h2 id="2-选择左侧导航栏中Shared-Resources（共享资源）下方的Managed-Instances（托管实例）。"><a href="#2-选择左侧导航栏中Shared-Resources（共享资源）下方的Managed-Instances（托管实例）。" class="headerlink" title="2. 选择左侧导航栏中Shared Resources（共享资源）下方的Managed Instances（托管实例）。"></a>2. 选择左侧导航栏中<strong>Shared Resources</strong>（共享资源）下方的<strong>Managed Instances</strong>（托管实例）。</h2><p><img src="/posts/aws-3manager/3b.png" alt="托管实例"></p>
<h2 id="3-在托管实例页面上，选择Actions（操作）下拉菜单中的Run-Command（运行命令）。"><a href="#3-在托管实例页面上，选择Actions（操作）下拉菜单中的Run-Command（运行命令）。" class="headerlink" title="3. 在托管实例页面上，选择Actions（操作）下拉菜单中的Run Command（运行命令）。"></a>3. 在托管实例页面上，选择<strong>Actions</strong>（操作）下拉菜单中的<strong>Run Command</strong>（运行命令）。</h2><p><img src="/posts/aws-3manager/3c.png" alt="运行命令"></p>
<h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><ul>
<li>在<strong>Run a command</strong>（运行命令）页面上的搜索栏中单击并选择<strong>Document name prefix</strong>（文档名称前缀），然后单击<strong>Equal</strong>（等于），并键入 AWS-UpdateSSMAgent。</li>
<li>现在单击<strong>AWS-UpdateSSMAgent</strong> 左边的单选按钮。本文档将更新实例上的系统管理代理。</li>
<li>向下滚动至<strong>目标</strong>面板，并单击您的托管式 Amazon EC2 实例旁的复选框。</li>
<li>最后，向下滚动并选择<strong>运行</strong>。</li>
</ul>
<p><img src="/posts/aws-3manager/3d.png" alt="AWS-UpdateSSMAgent"></p>
<h2 id="5-接下来您将看到页面上记录了正在运行的命令，且整体状态以绿色显示为“Success”（成功）。"><a href="#5-接下来您将看到页面上记录了正在运行的命令，且整体状态以绿色显示为“Success”（成功）。" class="headerlink" title="5. 接下来您将看到页面上记录了正在运行的命令，且整体状态以绿色显示为“Success”（成功）。"></a>5. 接下来您将看到页面上记录了正在运行的命令，且整体状态以绿色显示为“Success”（成功）。</h2><p><img src="/posts/aws-3manager/3e.png" alt="成功"></p>
<h1 id="四、运行-Remote-Shell-脚本"><a href="#四、运行-Remote-Shell-脚本" class="headerlink" title="四、运行 Remote Shell 脚本"></a>四、运行 Remote Shell 脚本</h1><h2 id="1-从系统管理控制台中，选择左侧导航栏中Shared-Resources（共享资源）下方的Managed-instances（托管实例）。然后在Actions（操作）菜单中选择Run-Command（运行命令）-菜单项。"><a href="#1-从系统管理控制台中，选择左侧导航栏中Shared-Resources（共享资源）下方的Managed-instances（托管实例）。然后在Actions（操作）菜单中选择Run-Command（运行命令）-菜单项。" class="headerlink" title="1. 从系统管理控制台中，选择左侧导航栏中Shared Resources（共享资源）下方的Managed instances（托管实例）。然后在Actions（操作）菜单中选择Run Command（运行命令） 菜单项。"></a>1. 从<strong>系统管理</strong>控制台中，选择左侧导航栏中<strong>Shared Resources</strong>（共享资源）下方的<strong>Managed instances</strong>（托管实例）。然后在<strong>Actions</strong>（操作）菜单中选择<strong>Run Command</strong>（运行命令） 菜单项。</h2><p><img src="/posts/aws-3manager/4a.png" alt="运行命令"></p>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><ul>
<li>在<strong>Run a command</strong>（运行命令）页面上的搜索栏中单击并选择<strong>Document name prefix</strong>（文档名称前缀），然后单击<strong>Equal</strong>（等于），并键入 AWS-RunShellScript。</li>
<li>现在单击<strong>AWS-RunShellScript</strong> 左边的单选按钮。本文档将更新实例上的系统管理代理。</li>
<li>向下滚动至<strong>目标</strong>面板，并单击您的托管式 Amazon EC2 实例旁的复选框。</li>
</ul>
<p><img src="/posts/aws-3manager/4b.png" alt="更新实例上的系统管理代理"></p>
<h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><ul>
<li>向下滚动至<strong>Command Parameters</strong>（命令参数）面板，并在<strong>Commands</strong>（命令）文本框中插入以下命令：<br><code>sudo yum update -y</code></li>
<li>最后，向下滚动并选择<strong>运行</strong>。</li>
</ul>
<p><img src="/posts/aws-3manager/4c.png" alt="命令参数"></p>
<h2 id="4-当您的脚本在托管式-Amazon-EC2-实例上远程运行时，整体状态显示为正在进行。不久后，整体状态将变成“成功”。届时，向下滚动至Targets-and-outputs（目标和输出）面板并单击实例的实例-ID。您的实例-ID-将与图片上的不同。"><a href="#4-当您的脚本在托管式-Amazon-EC2-实例上远程运行时，整体状态显示为正在进行。不久后，整体状态将变成“成功”。届时，向下滚动至Targets-and-outputs（目标和输出）面板并单击实例的实例-ID。您的实例-ID-将与图片上的不同。" class="headerlink" title="4. 当您的脚本在托管式 Amazon EC2 实例上远程运行时，整体状态显示为正在进行。不久后，整体状态将变成“成功”。届时，向下滚动至Targets and outputs（目标和输出）面板并单击实例的实例 ID。您的实例 ID 将与图片上的不同。"></a>4. 当您的脚本在托管式 Amazon EC2 实例上远程运行时，<strong>整体状态</strong>显示为<strong>正在进行</strong>。不久后，<strong>整体状态</strong>将变成“成功”。届时，向下滚动至<strong>Targets and outputs</strong>（目标和输出）面板并单击实例的实例 ID。您的实例 ID 将与图片上的不同。</h2><p><img src="/posts/aws-3manager/4d.png" alt="成功"></p>
<h2 id="5-在Output-on-i-XX-页面中，单击Step-1-Output（第-1-步-输出）面板的标头，查看来自实例的更新命令输出。"><a href="#5-在Output-on-i-XX-页面中，单击Step-1-Output（第-1-步-输出）面板的标头，查看来自实例的更新命令输出。" class="headerlink" title="5. 在Output on: i-XX 页面中，单击Step 1 - Output（第 1 步 - 输出）面板的标头，查看来自实例的更新命令输出。"></a>5. 在<strong>Output on: i-XX</strong> 页面中，单击<strong>Step 1 - Output</strong>（第 1 步 - 输出）面板的标头，查看来自实例的更新命令输出。</h2><p><img src="/posts/aws-3manager/4e.png" alt="查看"></p>
]]></content>
      <categories>
        <category>云服务</category>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>云服务</tag>
        <tag>AWS</tag>
        <tag>亚马逊</tag>
      </tags>
  </entry>
  <entry>
    <title>在AWS上托管简单静态页面</title>
    <url>/posts/aws-2staticweb/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>参考文章：<a href="https://aws.amazon.com/cn/getting-started/hands-on/host-static-website/">host static website</a></p>
          </div>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul>
<li>本文记录在AWS控制台中使用 AWS Amplify 托管静态网站的过程。AWS Amplify 可提供完全托管的静态网站和 Web 应用程托管。Amplify 的托管解决方案利用 Amazon CloudFront 和 Amazon S3 通过 AWS 内容分发网络 (CDN) 交付您的站点资产。</li>
<li>设置连续部署：Amplify 提供了基于 Git 的连续部署工作流，允许您在每次提交代码时自动将更新部署到站点。<a id="more"></a>
</li>
</ul>
<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><h2 id="一、创建并连接数据库"><a href="#一、创建并连接数据库" class="headerlink" title="一、创建并连接数据库"></a>一、创建并连接数据库</h2><h2 id="1-创建并初始化一个存储库。最简单的方法就是使用命令-create-react-app。在命令提示符或终端中使用以下命令安装此软件包。"><a href="#1-创建并初始化一个存储库。最简单的方法就是使用命令-create-react-app。在命令提示符或终端中使用以下命令安装此软件包。" class="headerlink" title="1. 创建并初始化一个存储库。最简单的方法就是使用命令 create-react-app。在命令提示符或终端中使用以下命令安装此软件包。"></a>1. 创建并初始化一个存储库。最简单的方法就是使用命令 create-react-app。在命令提示符或终端中使用以下命令安装此软件包。</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npx create-react-app amplifyapp</span><br><span class="line">cd amplifyapp</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
<h2 id="2-为应用创建一个新的-GitHub-代码库"><a href="#2-为应用创建一个新的-GitHub-代码库" class="headerlink" title="2. 为应用创建一个新的 GitHub 代码库"></a>2. 为应用创建一个新的 GitHub 代码库</h2><p><img src="/posts/aws-2staticweb/git库.png" alt="GitHub 代码库"></p>
<h2 id="3-初始化-Git-并将应用程序推送到新的-GitHub-代码库，在命令行界面中执行以下命令："><a href="#3-初始化-Git-并将应用程序推送到新的-GitHub-代码库，在命令行界面中执行以下命令：" class="headerlink" title="3. 初始化 Git 并将应用程序推送到新的 GitHub 代码库，在命令行界面中执行以下命令："></a>3. 初始化 Git 并将应用程序推送到新的 GitHub 代码库，在命令行界面中执行以下命令：</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:username/reponame.git</span><br><span class="line">git add .</span><br><span class="line">git commit -m “initial commit”</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<h2 id="4-登录Amplify-控制台，然后在部署下选择入门。"><a href="#4-登录Amplify-控制台，然后在部署下选择入门。" class="headerlink" title="4. 登录Amplify 控制台，然后在部署下选择入门。"></a>4. 登录<a href="https://signin.aws.amazon.com/signin?redirect_uri=https%3A%2F%2Fconsole.aws.amazon.com%2Famplify%2Fhome%3Fstate%3DhashArgs%2523%26isauthcode%3Dtrue&amp;client_id=arn%3Aaws%3Aiam%3A%3A015428540659%3Auser%2Famplify&amp;forceMobileApp=0&amp;code_challenge=TtR_InsZGGm6AJR4mRegMnEVcuDPSHVTWaZiEAyfK6E&amp;code_challenge_method=SHA-256">Amplify 控制台</a>，然后在<strong>部署</strong>下选择<strong>入门</strong>。</h2><p><img src="/posts/aws-2staticweb/入门.png" alt="Amplify 控制台"></p>
<h2 id="5-连接GitHub存储库。在授权-Amplify-控制台后，Amplify-会通过存储库提供商获取访问令牌，但不会将令牌存储在-AWS-服务器上。Amplify-仅使用安装在特定存储库中的部署密钥来访问存储库。"><a href="#5-连接GitHub存储库。在授权-Amplify-控制台后，Amplify-会通过存储库提供商获取访问令牌，但不会将令牌存储在-AWS-服务器上。Amplify-仅使用安装在特定存储库中的部署密钥来访问存储库。" class="headerlink" title="5. 连接GitHub存储库。在授权 Amplify 控制台后，Amplify 会通过存储库提供商获取访问令牌，但不会将令牌存储在 AWS 服务器上。Amplify 仅使用安装在特定存储库中的部署密钥来访问存储库。"></a>5. 连接GitHub存储库。在授权 Amplify 控制台后，Amplify 会通过存储库提供商获取访问令牌，但不会将令牌存储在 AWS 服务器上。Amplify 仅使用安装在特定存储库中的部署密钥来访问存储库。</h2><p><img src="/posts/aws-2staticweb/选择.png" alt="连接存储库"></p>
<h2 id="6-连接存储库服务提供商后，请选择一个存储库，然后选择一个对应的分支来进行构建和部署。"><a href="#6-连接存储库服务提供商后，请选择一个存储库，然后选择一个对应的分支来进行构建和部署。" class="headerlink" title="6. 连接存储库服务提供商后，请选择一个存储库，然后选择一个对应的分支来进行构建和部署。"></a>6. 连接存储库服务提供商后，请选择一个存储库，然后选择一个对应的分支来进行构建和部署。</h2><p><img src="/posts/aws-2staticweb/分支.png" alt="选择分支"></p>
<h2 id="二、确认构建设置"><a href="#二、确认构建设置" class="headerlink" title="二、确认构建设置"></a>二、确认构建设置</h2><p>　　对于所选择的分支，Amplify 会检查存储库，以自动检测要执行的构建命令的顺序。确认构建设置并单击<strong>下一步</strong>。<br><img src="/posts/aws-2staticweb/确认.png" alt="确认构建设置"></p>
<h2 id="三、保存并部署"><a href="#三、保存并部署" class="headerlink" title="三、保存并部署"></a>三、保存并部署</h2><p>　　查看所有设置，以确保所有设置均正确无误。选择<strong>保存并部署</strong>，将Web 应用程序部署到全球内容分发网络 (CDN)。前端构建通常需要 1-2 分钟的时间，但可能会因应用程序的大小而有所差异。<br><img src="/posts/aws-2staticweb/部署.png" alt="部署Web应用"></p>
]]></content>
      <categories>
        <category>云服务</category>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>云服务</tag>
        <tag>AWS</tag>
        <tag>亚马逊</tag>
      </tags>
  </entry>
  <entry>
    <title>AWS服务的注册和创建主机</title>
    <url>/posts/aws-1register/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>参考文章：<a href="https://blog.csdn.net/jjihuang/article/details/80777306">注册aws账号创建ec2免费套餐</a>,<a href="https://www.cnblogs.com/ccw869476711/p/11535812.html">AWS使用教程</a></p>
          </div>
<h1 id="一、注册aws账号"><a href="#一、注册aws账号" class="headerlink" title="一、注册aws账号"></a>一、注册aws账号</h1><ul>
<li>进入<a href="（https://portal.aws.amazon.com/billing/signup）">aws注册页面</a></li>
<li>填写email、密码、用户名等信息，绑定信用卡(我暂无支持aws的信用卡)</li>
<li>完成注册<a id="more"></a>
</li>
</ul>
<h1 id="二、开通EC2套餐"><a href="#二、开通EC2套餐" class="headerlink" title="二、开通EC2套餐"></a>二、开通EC2套餐</h1><h2 id="1-访问AWS主页，登录后找到AWS管理控制台"><a href="#1-访问AWS主页，登录后找到AWS管理控制台" class="headerlink" title="1. 访问AWS主页，登录后找到AWS管理控制台"></a>1. 访问<a href="https://aws.amazon.com/">AWS主页</a>，登录后找到AWS管理控制台</h2><p><img src="/posts/aws-1register/主页.png" alt="AWS管理控制"></p>
<h2 id="2-在控制台页面点击服务-gt-计算-gt-EC2"><a href="#2-在控制台页面点击服务-gt-计算-gt-EC2" class="headerlink" title="2. 在控制台页面点击服务-&gt;计算-&gt;EC2"></a>2. 在控制台页面点击<strong>服务-&gt;计算-&gt;EC2</strong></h2><p><img src="/posts/aws-1register/服务.png" alt="选择服务"></p>
<h2 id="3-跳转到资源页面先选择区域再点击启动实例"><a href="#3-跳转到资源页面先选择区域再点击启动实例" class="headerlink" title="3. 跳转到资源页面先选择区域再点击启动实例"></a>3. 跳转到资源页面先选择区域再点击<strong>启动实例</strong></h2><p><img src="/posts/aws-1register/启动.png" alt="启动实例"></p>
<h2 id="4-选择AMI（记得打勾仅免费套餐，过滤出所有的AMI都是免费的。按照自己的需要选择一个，一般选第2个）"><a href="#4-选择AMI（记得打勾仅免费套餐，过滤出所有的AMI都是免费的。按照自己的需要选择一个，一般选第2个）" class="headerlink" title="4. 选择AMI（记得打勾仅免费套餐，过滤出所有的AMI都是免费的。按照自己的需要选择一个，一般选第2个）"></a>4. 选择AMI（记得打勾仅免费套餐，过滤出所有的AMI都是免费的。按照自己的需要选择一个，一般选第2个）</h2><p><img src="/posts/aws-1register/ami.png" alt="选择AMI"></p>
<h2 id="5-实例类型默认，直接下一步：配置实例详细信息"><a href="#5-实例类型默认，直接下一步：配置实例详细信息" class="headerlink" title="5. 实例类型默认，直接下一步：配置实例详细信息"></a>5. 实例类型默认，直接<strong>下一步：配置实例详细信息</strong></h2><p><img src="/posts/aws-1register/实例.png" alt="选择实例类型"></p>
<h2 id="6-填写详细信息，大都默认"><a href="#6-填写详细信息，大都默认" class="headerlink" title="6. 填写详细信息，大都默认"></a>6. 填写详细信息，大都默认</h2><p><img src="/posts/aws-1register/详细.png" alt="详细信息"></p>
<h2 id="7-添加存储，大小改为30G"><a href="#7-添加存储，大小改为30G" class="headerlink" title="7. 添加存储，大小改为30G"></a>7. 添加存储，大小改为30G</h2><p><img src="/posts/aws-1register/30g.png" alt="存储大小"></p>
<h2 id="8-添加标签直接下一步"><a href="#8-添加标签直接下一步" class="headerlink" title="8. 添加标签直接下一步"></a>8. 添加标签直接<strong>下一步</strong></h2><p><img src="/posts/aws-1register/标签.png" alt="添加标签"></p>
<h2 id="9-安全组主要开通访问服务器的端口和允许访问的IP，按下图配置完就可以下一步审核启动"><a href="#9-安全组主要开通访问服务器的端口和允许访问的IP，按下图配置完就可以下一步审核启动" class="headerlink" title="9. 安全组主要开通访问服务器的端口和允许访问的IP，按下图配置完就可以下一步审核启动"></a>9. 安全组主要开通访问服务器的端口和允许访问的IP，按下图配置完就可以下一步<strong>审核启动</strong></h2><p><img src="/posts/aws-1register/安全组.png" alt="安全组配置"></p>
<h2 id="10-审核启动，确定没错后点击启动"><a href="#10-审核启动，确定没错后点击启动" class="headerlink" title="10. 审核启动，确定没错后点击启动"></a>10. 审核启动，确定没错后点击<strong>启动</strong></h2><p><img src="/posts/aws-1register/审核.png" alt="审核启动"></p>
<h2 id="11-创建密钥，填写名称后下载密钥对（一定要保存好），点击启动实例"><a href="#11-创建密钥，填写名称后下载密钥对（一定要保存好），点击启动实例" class="headerlink" title="11. 创建密钥，填写名称后下载密钥对（一定要保存好），点击启动实例"></a>11. 创建密钥，填写名称后下载密钥对（一定要保存好），点击<strong>启动实例</strong></h2><p><img src="/posts/aws-1register/密钥.png" alt="创建密钥"></p>
<h2 id="12-实例正在启动"><a href="#12-实例正在启动" class="headerlink" title="12. 实例正在启动"></a>12. 实例正在启动</h2><p><img src="/posts/aws-1register/状态.png" alt="启动状态"></p>
<h2 id="13-启动完成，查看实例"><a href="#13-启动完成，查看实例" class="headerlink" title="13. 启动完成，查看实例"></a>13. 启动完成，查看实例</h2><p><img src="/posts/aws-1register/查看.png" alt="查看实例"></p>
]]></content>
      <categories>
        <category>云服务</category>
        <category>AWS</category>
      </categories>
      <tags>
        <tag>云服务</tag>
        <tag>AWS</tag>
        <tag>亚马逊</tag>
      </tags>
  </entry>
  <entry>
    <title>51单片机的串口通信</title>
    <url>/posts/51-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>原文链接：<a href="https://blog.csdn.net/nanfeibuyi/article/details/84024606">单片机 串口编程之串口通信仿真实验</a></p>
          </div>
<h2 id="单片机的串口相关的寄存器"><a href="#单片机的串口相关的寄存器" class="headerlink" title="单片机的串口相关的寄存器"></a>单片机的串口相关的寄存器</h2><ul>
<li><strong>串口控制寄存器SCON：(Serial CONtrol)</strong></li>
<li><strong>串行数据寄存器SBUF：(Serial data BUFfer)</strong></li>
<li><strong>电源管理寄存器PCON：(Power CONtrol)</strong><a id="more"></a>
</li>
</ul>
<h2 id="串口控制寄存器SCON"><a href="#串口控制寄存器SCON" class="headerlink" title="串口控制寄存器SCON"></a>串口控制寄存器SCON</h2><ul>
<li>　　<strong>用来对串口进行控制，其寄存器地址为0x98，支持位寻址。</strong></li>
<li>　　<strong>一般来说单片机的寄存器的个数在制作好就已经确定了，MCS-51单片机有一些寄存器是8位的(可以存放8位数据)，有一些是16位的，这些寄存器有点像全局变量(寄存器名-变量名)，它们分配了固定的地址空间，我们可以对这个寄存器变量进行赋值或读取值。比如我们禁止串口中断，那么我们可以设置相应的值，当系统处理串口相关的任务时，读取到这个我们设置的值时，直到我们要禁止串口中断，那么系统就不会相应串口中断。串口控制寄存器SCON的地址为0x98，我们可以直接对SCON这个”变量”进行赋值，支持位寻址意思是：SCON一共有8位，每1位代表的意思都有不同，可以直接单独对某一位进行设置，有一些寄存器是不可以位寻址的。</strong></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">SCON控制寄存器</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">位编号</td>
<td>D7</td>
<td>D6</td>
<td>D5</td>
<td>D4</td>
<td>D3</td>
<td>D2</td>
<td>D1</td>
<td>D0</td>
</tr>
<tr>
<td style="text-align:center">位名称</td>
<td>SM0</td>
<td>SM1</td>
<td>SM2</td>
<td>REN</td>
<td>TB8</td>
<td>RB8</td>
<td>TI</td>
<td>RI</td>
</tr>
<tr>
<td style="text-align:center">位地址</td>
<td>9FH</td>
<td>9EH</td>
<td>9DH</td>
<td>9CH</td>
<td>9BH</td>
<td>9AH</td>
<td>99H</td>
<td>98H</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">SM0，SM1串行口工作方式控制位</th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SM0</td>
<td>SM1</td>
<td>工作方式</td>
<td>功能</td>
<td>波特率</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td>0</td>
<td>方式0</td>
<td>8位同步移位寄存器</td>
<td>晶振频率/12</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td>1</td>
<td>方式1</td>
<td>10位UART</td>
<td>可变</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td>0</td>
<td>方式2</td>
<td>11位UART</td>
<td>晶振频率/64或晶振频率/32</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td>1</td>
<td>方式3</td>
<td>11位UART</td>
<td>可变</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>SM2</th>
<th>多机通信控制位</th>
<th>当该位置1为多机通信，多机通信仅在方式2、方式3有效。</th>
</tr>
</thead>
<tbody>
<tr>
<td>REN</td>
<td>接收允许位</td>
<td>为1允许接收，为0禁止接收</td>
</tr>
<tr>
<td>TB8</td>
<td>待发送的第9位数据</td>
<td>同来存放工作方式2，工作方式3模式下等待发送的第9位数据</td>
</tr>
<tr>
<td>RB8</td>
<td>收到的第9位数据</td>
<td>同来存放工作方式2，工作方式3模式下接收到的第9位数据，在方式1下为接收到的停止位，工作当时0不使用该位。</td>
</tr>
<tr>
<td>TI</td>
<td>发送中断标志位</td>
<td>发送完成标志位，当SBUF中的数据发送完成后由硬件置1，并且当单片机硬件中断被使能之后触发中断事件，该位必须由软件清零，并且该位被清零之后才能进行下一个字节数据的发送。</td>
</tr>
<tr>
<td>RI</td>
<td>接收中断标志位</td>
<td>接受完成标志位，当SBUF收到一个字节的数据后由硬件系统置1，并且当单片机硬件中断被使能之后触发串行中断事件，该位必须由软件清零，并且只有该位被清零之后才能够进行下一字节数据的接收。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="串行数据寄存器SBUF"><a href="#串行数据寄存器SBUF" class="headerlink" title="串行数据寄存器SBUF"></a>串行数据寄存器SBUF</h2><ul>
<li><p>　　<strong>用于存放串行通信中发送和接收的相关数据。其寄存器地址是0x99。</strong></p>
</li>
<li><p>　　<strong>SBUF由发送缓冲寄存器和接收缓冲寄存器组成，这两个寄存器占用同一个寄存器地址。其中发送缓冲寄存器只写，接收寄存器只读。</strong></p>
</li>
<li><p>　　<strong>发送数据：当将一个数据写入SBUF后，单片机立即根据选择的工作方式和波特率将写入的字节数据进行相应的处理然后从TXD(P3.1)引脚串行发送出去，发送完成之后置位相应寄存器的标志位，只有相应的标志位被清除之后才能进行下一次的数据发送。</strong></p>
</li>
<li><p>　　<strong>接收数据：当RXD(P3.0)引脚根据工作方式和波特率接收到一个完整的数据字节后单片机将该数据字节放入接收缓冲寄存器中，并置位相应的标志位。接收缓冲寄存器是双字节的，这样就可以在单片机读取接收缓冲寄存器的数据时同时进行下一个字节的数据接收。不会发生前后两个字节的数据冲突(数据覆盖)。</strong></p>
</li>
</ul>
<h2 id="电源管理寄存器PCON"><a href="#电源管理寄存器PCON" class="headerlink" title="电源管理寄存器PCON"></a>电源管理寄存器PCON</h2><p>​      <strong>可以控制串口波特率加倍。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>PCON电源管理寄存器</strong></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>位编号</td>
<td>D7</td>
<td>D6</td>
<td>D5</td>
<td>D4</td>
<td>D3</td>
<td>D2</td>
<td>D1</td>
<td>D0</td>
</tr>
<tr>
<td>位符号</td>
<td>SMOD</td>
<td>SMOD0</td>
<td>LVDF</td>
<td>POF</td>
<td>GF1</td>
<td>GF0</td>
<td>PD</td>
<td>IDL</td>
</tr>
</tbody>
</table>
</div>
<p>   <strong>SMOD：该位与串口通信有关。</strong></p>
<p>   <strong>SMOD=0; 串口方式1，2，3时，波特率正常。</strong></p>
<p>   <strong>SMOD=1; 串口方式1，2，3时，波特率加倍。</strong></p>
<h2 id="串口的工作方式"><a href="#串口的工作方式" class="headerlink" title="串口的工作方式"></a>串口的工作方式</h2><p>　　 <strong>MCS-51单片机的串口一共4种工作方式。其中工作方式0为同步通信方式，其余3种为异步通信。</strong></p>
<ul>
<li><strong>工作方式0：外部引脚TXD（P3.0）为数据的输出输入端，外部引脚TXD（P3.1）提供数据的同步脉冲。</strong></li>
</ul>
<p>　　<strong>因此工作在方式0进行串口通信不需要考虑波特率。</strong></p>
<ul>
<li><p><strong>工作方式1：使用定时器作为波特率发生器。</strong></p>
<p><strong>波特率的计算</strong> </p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2018111315393093.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25hbmZlaWJ1eWk=,size_16,color_FFFFFF,t_70" alt="img"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>常见的波特率对应的初始值</strong></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>波特率/工作频率</td>
<td>11.0592MHz</td>
<td>12MHz</td>
<td>14.74456MHz</td>
<td>16MHz</td>
<td>20MHz</td>
<td>SMOD值</td>
</tr>
<tr>
<td>150（b/s）</td>
<td>0x40</td>
<td>0x30</td>
<td>0x00</td>
<td></td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>300（b/s）</td>
<td>0xA0</td>
<td>0x98</td>
<td>0x80</td>
<td>0x75</td>
<td>0x52</td>
<td>0</td>
</tr>
<tr>
<td>600（b/s）</td>
<td>0xD0</td>
<td>0xCC</td>
<td>0xC0</td>
<td>0xBB</td>
<td>0xA9</td>
<td>0</td>
</tr>
<tr>
<td>1200（b/s）</td>
<td>0xF8</td>
<td>0xE6</td>
<td>0xE0</td>
<td>0xDE</td>
<td>0xD5</td>
<td>0</td>
</tr>
<tr>
<td>2400（b/s）</td>
<td>0xF4</td>
<td>0xF3</td>
<td>0xF0</td>
<td>0xEF</td>
<td>0xEA</td>
<td>0</td>
</tr>
<tr>
<td>4800（b/s）</td>
<td></td>
<td>0xF3</td>
<td>0xEF</td>
<td>0xEF</td>
<td></td>
<td>1</td>
</tr>
<tr>
<td>4800（b/s）</td>
<td>0xFA</td>
<td></td>
<td>0xF8</td>
<td></td>
<td>0xF5</td>
<td>0</td>
</tr>
<tr>
<td>9600（b/s）</td>
<td>0xFD</td>
<td></td>
<td>0xFC</td>
<td></td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>9600（b/s）</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>0xF5</td>
<td>1</td>
</tr>
<tr>
<td>19200（b/s）</td>
<td>0xFD</td>
<td></td>
<td>0xFC</td>
<td></td>
<td></td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>工作方式2：</strong></li>
</ul>
<p>​                                   <img src="https://img-blog.csdnimg.cn/2018111316174940.png" alt="img"></p>
<ul>
<li><strong>工作方式3：波特率计算方式与工作方式1相同。</strong></li>
</ul>
<h2 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h2><ul>
<li><p><strong>波特率是指数据信号对载波的调制速率，它用单位时间内载波调制状态改变的次数来表示。</strong></p>
</li>
<li><p><strong>在信息传输通道中，携带数据信息的信号单元叫码元，每秒钟通过信道传输的码元数称为码元传输速率，简称波特率。</strong></p>
</li>
<li><p><strong>通信双方约定一致的波特率以便正确的接收数据。(数据发送前可能进行了调制，波特率不同，调制参数不同）</strong></p>
</li>
<li><p><strong>如果收发双方的波特率不一样，那么调制与解调的参数不一样，就很有可能读取不到正确的数据，从而解读为乱码。</strong></p>
</li>
<li><p><strong>通常串口工作方式1使用定时器作为波特率发生器。</strong></p>
</li>
</ul>
<h2 id="串口中断"><a href="#串口中断" class="headerlink" title="串口中断"></a>串口中断</h2><p>　　<strong>使能串口中断：打开总中断-中断控制寄存器IE的EA位置1，打开串口中断中断控制寄存器IE的ES位置1</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>中断控制寄存器IE（Interrupt Enable）</strong></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>位序号</td>
<td>D0</td>
<td>D1</td>
<td>D2</td>
<td>D3</td>
<td>D4</td>
<td>D5</td>
<td>D6</td>
<td>D7</td>
</tr>
<tr>
<td>说明</td>
<td>外部中断0</td>
<td>定时/计数0</td>
<td>外部中断1</td>
<td>定时/计数1</td>
<td>串行口中断</td>
<td>保留位</td>
<td>保留位</td>
<td>全局中断位</td>
</tr>
<tr>
<td>位符号</td>
<td>EX0</td>
<td>ET0</td>
<td>EX1</td>
<td>ET1</td>
<td>ES</td>
<td>—</td>
<td>—</td>
<td>EA</td>
</tr>
<tr>
<td>位地址</td>
<td>A8H</td>
<td>A9H</td>
<td>AAH</td>
<td>ABH</td>
<td>ACH</td>
<td>—</td>
<td>—</td>
<td>AFH</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>EX0</th>
<th style="text-align:center">外部中断0允许位</th>
<th>EX0=1，允许外部中断0中断；EX0=0，禁止外部中断0中断。</th>
</tr>
</thead>
<tbody>
<tr>
<td>ET0</td>
<td style="text-align:center">T0溢出中断允许位</td>
<td>ET0=1，允许T0中断；ET0=0，禁止T0中断。</td>
</tr>
<tr>
<td>EX1</td>
<td style="text-align:center">外部中断1允许位</td>
<td>EX1=1，允许外部中断1中断；EX1=0，禁止外部中断1中断。</td>
</tr>
<tr>
<td>ET1</td>
<td style="text-align:center">T1溢出中断允许位</td>
<td>ET1=1，允许T1中断；ET1=0，禁止T1中断。</td>
</tr>
<tr>
<td>ES</td>
<td style="text-align:center">串行中断允许位(Enable Serial)</td>
<td>ES=1，允许串行口中断；ES=0，禁止串行口中断。</td>
</tr>
<tr>
<td>EA</td>
<td style="text-align:center">中断总允许位(Enable All)</td>
<td>EA=1，CPU开放中断；EA=0，CPU禁止所有的中断请求。总允许EA好比一个总开关。</td>
</tr>
</tbody>
</table>
</div>
<p>　　<strong>使能串口中断之后，接收到数据(RI置1)/完成发送(TI置1)，RI/TI被置1就会触发串口中断事件，然后执行中断处理函数。</strong></p>
<p>　　<strong>中断处理函数编写格式：</strong>       </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> 函数名(<span class="keyword">void</span>) interrupt <span class="number">4</span> <span class="keyword">using</span> 工作寄存器组编号</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//要执行的动作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   　　<strong>4的含义： 一共5个中断编号为0~4，串口中断的编号为4</strong></p>
<p>　　   <strong>using 寄存器组编号：一共4组工作寄存器组，编号为0~3，如果不写默认为工作寄存器组0。</strong></p>
<h2 id="初始化串口为模式1过程。"><a href="#初始化串口为模式1过程。" class="headerlink" title="初始化串口为模式1过程。"></a>初始化串口为模式1过程。</h2><h3 id="SCON设置"><a href="#SCON设置" class="headerlink" title="SCON设置"></a>SCON设置</h3><div class="table-container">
<table>
<thead>
<tr>
<th>位名称</th>
<th>SM0</th>
<th>SM1</th>
<th>SM2</th>
<th>REN</th>
<th>TB8</th>
<th>RB8</th>
<th>TI</th>
<th>RI</th>
</tr>
</thead>
<tbody>
<tr>
<td>设置值</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>含义</td>
<td>工作在方式1</td>
<td>波特率不加倍</td>
<td>允许接收数据</td>
<td>工作方式1不设置该位</td>
<td>初始为未发送完数据</td>
<td>初始为为接收到数据</td>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>   SCON = 0x01010000 = 0x50  </p>
<h3 id="PCON设置"><a href="#PCON设置" class="headerlink" title="PCON设置"></a>PCON设置</h3><div class="table-container">
<table>
<thead>
<tr>
<th>位编号</th>
<th>D7</th>
<th>D6</th>
<th>D5</th>
<th>D4</th>
<th>D3</th>
<th>D2</th>
<th>D1</th>
<th>D0</th>
</tr>
</thead>
<tbody>
<tr>
<td>位符号</td>
<td>SMOD</td>
<td>SMOD0</td>
<td>LVDF</td>
<td>POF</td>
<td>GF1</td>
<td>GF0</td>
<td>PD</td>
<td>IDL</td>
</tr>
<tr>
<td>默认波特率不加倍</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>波特率加倍</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>   PCON = 0x00 （SMOD=0，波特率不加倍）</p>
<p>   PCON = 0x80 （SMOD=1，波特率加倍）</p>
<h3 id="定时器设置"><a href="#定时器设置" class="headerlink" title="定时器设置"></a>定时器设置</h3><ul>
<li>工作方式设置：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20181113174059940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25hbmZlaWJ1eWk=,size_16,color_FFFFFF,t_70" alt="img"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>MI，M0定时器模式选择</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>M1</td>
<td>M0</td>
<td>工作方式</td>
<td>功能说明</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>方式0</td>
<td>13位定时器/计数器</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>方式1</td>
<td>16位定时器/计数器</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>方式2</td>
<td>自动重载8位定时器/计数器</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>方式3</td>
<td>T0分为2个8位独立计数器，T1无方式3</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p>开启定时器1：将控制寄存器TCON的TR1置1</p>
</li>
<li><p>设置定时器1的初值：TH1数据寄存器装载初值的高8位，TL1数据寄存器装载初值的低8位。</p>
</li>
<li><p>定时器用作波特率发生器时，使用上面的波特率计算公式得到初始值，或直接查看<strong>常见的波特率对应的初始值。</strong></p>
</li>
</ul>
<p>​      <strong>TH1 = 0xFD；// 11.0592MHz的工作频率，9600的波特率 对应的初始值。</strong> </p>
<h3 id="打开总中断-EA-1-打开串口中断-ES-1；"><a href="#打开总中断-EA-1-打开串口中断-ES-1；" class="headerlink" title="打开总中断 EA = 1; 打开串口中断 ES = 1；"></a><strong>打开总中断 EA = 1; 打开串口中断 ES = 1；</strong></h3>]]></content>
      <categories>
        <category>硬件</category>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>开源硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>基于51单片机的时钟</title>
    <url>/posts/51-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>参考视频：<a href="https://www.bilibili.com/video/BV1DW411a7mz">哈工程郭天祥老师51单片机</a></p>
          </div>
<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><ul>
<li>AT89C52芯片</li>
<li>7SEG-MPX8-CA-BLUE八位共阳数码管</li>
<li>74HC573锁存器<a id="more"></a>
</li>
</ul>
<h1 id="电路图"><a href="#电路图" class="headerlink" title="电路图"></a>电路图</h1><p><img src="/posts/51-1/电路图.jpg" alt="电路图"></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;reg52.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> uint unsigned int</span></span><br><span class="line"><span class="keyword">int</span> tt=<span class="number">0</span>,ts=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> num=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">10</span>]=&#123;<span class="number">192</span>,<span class="number">249</span>,<span class="number">164</span>,<span class="number">176</span>,<span class="number">153</span>,<span class="number">146</span>,<span class="number">130</span>,<span class="number">248</span>,<span class="number">128</span>,<span class="number">144</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> C[<span class="number">8</span>]=&#123;<span class="number">1</span>,<span class="number">7</span>,<span class="number">-1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;	</span><br><span class="line">	<span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">	TMOD=<span class="number">0x01</span>;<span class="comment">//timer0 work motion 1</span></span><br><span class="line">	TH0=(<span class="number">65536</span><span class="number">-50000</span>)/<span class="number">256</span>;</span><br><span class="line">	TL0=(<span class="number">65536</span><span class="number">-50000</span>)%<span class="number">256</span>;</span><br><span class="line">	EA=<span class="number">1</span>;<span class="comment">//all interrupt</span></span><br><span class="line">	ET0=<span class="number">1</span>; <span class="comment">//open timer0 interrupt</span></span><br><span class="line">	TR0=<span class="number">1</span>; <span class="comment">//start timer0</span></span><br><span class="line">	P2=<span class="number">1</span>;</span><br><span class="line">	P1=A[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span>(tt==<span class="number">2</span>)&#123;</span><br><span class="line">			tt=<span class="number">0</span>;</span><br><span class="line">			P2=P2&lt;&lt;<span class="number">1</span>;			</span><br><span class="line">			<span class="keyword">if</span>(P2==<span class="number">0</span>) P2=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(ts==<span class="number">500</span>)&#123;</span><br><span class="line">				ts=<span class="number">0</span>;</span><br><span class="line">				C[<span class="number">7</span>]=(C[<span class="number">7</span>]+<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">				<span class="keyword">if</span>(C[<span class="number">7</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">					C[<span class="number">6</span>]=(C[<span class="number">6</span>]+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">					<span class="keyword">if</span>(C[<span class="number">6</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">						C[<span class="number">4</span>]=(C[<span class="number">4</span>]+<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">						<span class="keyword">if</span>(C[<span class="number">4</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">							C[<span class="number">3</span>]=(C[<span class="number">3</span>]+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">							<span class="keyword">if</span>(C[<span class="number">3</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">								C[<span class="number">1</span>]=(C[<span class="number">1</span>]+<span class="number">1</span>)%<span class="number">10</span>;</span><br><span class="line">								<span class="keyword">if</span>(C[<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">									C[<span class="number">0</span>]=(C[<span class="number">0</span>]+<span class="number">1</span>)%<span class="number">6</span>;</span><br><span class="line">									<span class="keyword">if</span>(C[<span class="number">1</span>]==<span class="number">0</span>)&#123;</span><br><span class="line">										C[<span class="number">0</span>]++;</span><br><span class="line">									&#125;				</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">if</span>(C[<span class="number">0</span>]==<span class="number">2</span> &amp;&amp; C[<span class="number">1</span>]==<span class="number">4</span>)&#123;</span><br><span class="line">									C[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">									C[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			num++;</span><br><span class="line">			<span class="keyword">if</span>(num==<span class="number">9</span>) num=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(C[num<span class="number">-1</span>]==<span class="number">-1</span>)&#123;</span><br><span class="line">				P1=<span class="number">191</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>&#123;</span><br><span class="line">				P1=A[C[num<span class="number">-1</span>]];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计时器中断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter0</span><span class="params">()</span> interrupt 1</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TH0=(<span class="number">65536</span><span class="number">-1650</span>)/<span class="number">256</span>;</span><br><span class="line">	TL0=(<span class="number">65536</span><span class="number">-1650</span>)%<span class="number">256</span>;</span><br><span class="line">	tt++;</span><br><span class="line">	ts++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p><img src="/posts/51-1/效果.jpg" alt="时钟效果"></p>
]]></content>
      <categories>
        <category>硬件</category>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>开源硬件</tag>
      </tags>
  </entry>
  <entry>
    <title>手写字体制作并在Next上部署</title>
    <url>/posts/ziti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>下载<a href="http://file.panjiangtao.cn/ziti.ttf">江涛休闲体</a></p>
          </div>
<h1 id="字库制作"><a href="#字库制作" class="headerlink" title="字库制作"></a>字库制作</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>　　在<a href="http://www.flexifont.com/flexifont-chn/mine/">flexifont</a>上注册并下载需要的字体模板，如下图。<br><img src="/posts/ziti/moban.jpg" alt="字体模板"><br><a id="more"></a><br>　　推荐使用6763字+符号6886字这个模板，包含了GB2312完整字库，基本上碰不到这以外的字体。</p>
<h2 id="书写"><a href="#书写" class="headerlink" title="书写"></a>书写</h2><p>　　将下载的pdf文件打印出来写，或者在电脑上用PS+手绘板、ipad上用pencil。这一步是整个过程最麻烦的部分，博主耗时18个小时。<br>　　注意事项：<br>　　1. 请使用黑色或蓝色的圆珠笔、水笔或者钢笔，请勿使用签字笔、铅笔和彩笔。<br>　　2. 书写时，保证文字尽量居中，大小匀称，不要压到或超过边框。</p>
<h2 id="拍照上传"><a href="#拍照上传" class="headerlink" title="拍照上传"></a>拍照上传</h2><p><img src="/posts/ziti/paizhao.jpg" alt="拍照要求"></p>
<h2 id="生成字库"><a href="#生成字库" class="headerlink" title="生成字库"></a>生成字库</h2><p><img src="/posts/ziti/shengcheng.jpg" alt="生成字库要求"><br>　　生成完毕后下载ttf文件，打卡后安装即可在word文档中使用。</p>
<h1 id="博客安装"><a href="#博客安装" class="headerlink" title="博客安装"></a>博客安装</h1><h2 id="转码"><a href="#转码" class="headerlink" title="转码"></a>转码</h2><p>　　在<a href="https://www.aconvert.com/cn/image/ttf-to-svg/">字体文件转码网站</a>将ttf文件分别转码成svg、woff、eot文件，下载备用。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>　　<em> 在Hexo文件夹中的source文件夹下建立_data文件夹，在其内新建styles.styl文件。
　　</em> 在主题文件夹下的source文件夹下建立fonts文件夹，其内放入所有字体文件。<br>　　styles.styl文件内容：<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&#x27;JTHandwrite&#x27;</span>; <span class="comment">/*引号中为字体名，将下列所有JTHandwrite用你的文件名代替 */</span></span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;/fonts/JTHandwrite.eot&#x27;</span>);</span><br><span class="line">    <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;/fonts/JTHandwrite.eot?#iefix&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;embedded-opentype&#x27;</span>),</span><br><span class="line">        <span class="built_in">url</span>(<span class="string">&#x27;/fonts/JTHandwrite.svg&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;svg&#x27;</span>),</span><br><span class="line">        <span class="built_in">url</span>(<span class="string">&#x27;/fonts/JTHandwrite.ttf&#x27;</span>)  <span class="built_in">format</span>(<span class="string">&#x27;truetype&#x27;</span>);</span><br><span class="line">    <span class="attribute">font-weight</span>: <span class="number">500</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>　　在主题配置文件_config.yml中修改成如下：<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used for all elements inside &lt;body&gt;.</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">&#x27;JTHandwrite&#x27;</span> <span class="comment"># 改为上面你的font-family</span></span><br><span class="line">    <span class="attr">size:</span></span><br></pre></td></tr></table></figure></p>
<h2 id="OK-完事了。"><a href="#OK-完事了。" class="headerlink" title="OK,完事了。"></a>OK,完事了。</h2>]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>daily</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>php面向对象</title>
    <url>/posts/php-7oop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　PHP的面向对象大体和C++相同，下面具体阐述php的不同之处。</p>
<h1 id="PHP-构造函数"><a href="#PHP-构造函数" class="headerlink" title="PHP 构造函数"></a>PHP 构造函数</h1><p>　　构造函数是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，在创建对象的语句中与 new 运算符一起使用。</p>
<p>　　PHP 5 允许开发者在一个类中定义一个方法作为构造函数，语法格式如下：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __construct ([ mixed $args [, $... ]] )&#123;&#125;</span><br></pre></td></tr></table></figure><br><a id="more"></a><br>在上面的例子中我们就可以通过构造方法来初始化 $url 和 $title 变量：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"> $par1, $par2 </span>) </span>&#123;</span><br><span class="line">   <span class="keyword">$this</span>-&gt;url = $par1;</span><br><span class="line">   <span class="keyword">$this</span>-&gt;title = $par2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在我们就不需要再调用 setTitle 和 setUrl 方法了：</p>
<h2 id><a href="#" class="headerlink" title></a><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$runoob = <span class="keyword">new</span> Site(<span class="string">&#x27;www.runoob.com&#x27;</span>, <span class="string">&#x27;菜鸟教程&#x27;</span>);</span><br></pre></td></tr></table></figure></h2><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><p>　　析构函数(destructor) 与构造函数相反，当对象结束其生命周期时（例如对象所在的函数已调用完毕），系统自动执行析构函数。</p>
<p>　　PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，其语法格式如下：</p>
<h2 id="-1"><a href="#-1" class="headerlink" title></a><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> __destruct ( <span class="keyword">void</span> )&#123;&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><h2 id="-2"><a href="#-2" class="headerlink" title></a><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> constant = <span class="string">&#x27;常量值&#x27;</span>;   <span class="comment">//定义</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">showConstant</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span>  <span class="built_in">self</span>::constant . PHP_EOL;  <span class="comment">//使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h1 id="Static-关键字"><a href="#Static-关键字" class="headerlink" title="Static 关键字"></a>Static 关键字</h1><p>　　声明类属性或方法为 static(静态)，就可以不实例化类而直接访问。<br>　　静态属性访问用‘::’<br>　　定义静态属性：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">static</span> $my_static = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><br>　　访问静态属性：</p>
<h2 id="-3"><a href="#-3" class="headerlink" title></a><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接访问类属性</span></span><br><span class="line"><span class="keyword">print</span> Foo::$my_static . PHP_EOL;</span><br><span class="line"><span class="comment">//实例化后访问</span></span><br><span class="line">$foo = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">print</span> $foo::$my_static . PHP_EOL;</span><br></pre></td></tr></table></figure></h2><h1 id="调用父类构造方法"><a href="#调用父类构造方法" class="headerlink" title="调用父类构造方法"></a>调用父类构造方法</h1><p>　　PHP 不会在子类的构造方法中自动的调用父类的构造方法。要执行父类的构造方法，需要在子类的构造方法中调用 parent::__construct() 。</p>
]]></content>
      <categories>
        <category>frontend</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>php魔术常量</title>
    <url>/posts/php-6magic/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　PHP 向它运行的任何脚本提供了大量的预定义常量。<br>　　不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。<br>　　有八个魔术常量它们的值随着它们在代码中的位置改变而改变。</p>
<h1 id="1-LINE"><a href="#1-LINE" class="headerlink" title="1. __LINE__"></a>1. __LINE__</h1><p>　　文件中的当前行号。<br><a id="more"></a></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;这是第 &quot; &#x27;</span>  . <span class="keyword">__LINE__</span> . <span class="string">&#x27; &quot; 行&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果为：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">这是第 “ <span class="number">2</span> ” 行</span><br></pre></td></tr></table></figure></p>
<h1 id="2-FILE"><a href="#2-FILE" class="headerlink" title="2. __FILE__"></a>2. __FILE__</h1><p>　　文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。</p>
<p>　　自 PHP 4.0.2 起，__FILE__ 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。</p>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例:"></a>实例:</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;该文件位于 &quot; &#x27;</span>  . <span class="keyword">__FILE__</span> . <span class="string">&#x27; &quot; &#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该文件位于 “ E:\wamp\www\test\index.php ”</span><br></pre></td></tr></table></figure></p>
<h1 id="3-DIR"><a href="#3-DIR" class="headerlink" title="3. __DIR__"></a>3. __DIR__</h1><p>　　文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。</p>
<p>　　它等价于 dirname(__FILE__)。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增）</p>
<h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;该文件位于 &quot; &#x27;</span>  . <span class="keyword">__DIR__</span> . <span class="string">&#x27; &quot; &#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">该文件位于 “ E:\wamp\www\test ”</span><br></pre></td></tr></table></figure></p>
<h1 id="4-FUNCTION"><a href="#4-FUNCTION" class="headerlink" title="4. __FUNCTION__"></a>4. __FUNCTION__</h1><p>　　函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。</p>
<h2 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span>  <span class="string">&#x27;函数名为：&#x27;</span> . <span class="keyword">__FUNCTION__</span> ;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数名为：test</span><br></pre></td></tr></table></figure></p>
<h1 id="5-CLASS"><a href="#5-CLASS" class="headerlink" title="5. __CLASS__"></a>5. __CLASS__</h1><p>　　类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。</p>
<p>　　在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）。注意自 PHP 5.4 起 __CLASS__ 对 trait 也起作用。当用在 trait 方法中时，__CLASS__ 是调用 trait 方法的类的名字。</p>
<h2 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">_print</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;类名为：&#x27;</span>  . <span class="keyword">__CLASS__</span> . <span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">        <span class="keyword">echo</span>  <span class="string">&#x27;函数名为：&#x27;</span> . <span class="keyword">__FUNCTION__</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$t = <span class="keyword">new</span> test();</span><br><span class="line">$t-&gt;_print();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">类名为：test</span><br><span class="line">函数名为：_print</span><br></pre></td></tr></table></figure></p>
<h1 id="6-TRAIT"><a href="#6-TRAIT" class="headerlink" title="6. __TRAIT__"></a>6. __TRAIT__</h1><p>　　Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits。</p>
<p>　　Trait 名包括其被声明的作用区域（例如 Foo\Bar）。</p>
<p>　　从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。</p>
<h2 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Hello &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">trait</span> SayWorld &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">parent</span>::sayHello();</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;World!&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHelloWorld</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">    <span class="keyword">use</span> <span class="title">SayWorld</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">$o = <span class="keyword">new</span> MyHelloWorld();</span><br><span class="line">$o-&gt;sayHello();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上例程会输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure></p>
<h1 id="7-METHOD"><a href="#7-METHOD" class="headerlink" title="7. __METHOD__"></a>7. __METHOD__</h1><p>　　类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。</p>
<h2 id="实例-6"><a href="#实例-6" class="headerlink" title="实例:"></a>实例:</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">echo</span>  <span class="string">&#x27;函数名为：&#x27;</span> . <span class="keyword">__METHOD__</span> ;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数名为：test</span><br></pre></td></tr></table></figure></p>
<h1 id="8-NAMESPACE"><a href="#8-NAMESPACE" class="headerlink" title="8. __NAMESPACE__"></a>8. __NAMESPACE__</h1><p>　　当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。</p>
<h2 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a>实例</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;命名空间为：&quot;&#x27;</span>, <span class="keyword">__NAMESPACE__</span>, <span class="string">&#x27;&quot;&#x27;</span>; <span class="comment">// 输出 &quot;MyProject&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上实例输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命名空间为：&quot;MyProject&quot;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>frontend</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>php超级全局变量</title>
    <url>/posts/php-5superglobal/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>　　PHP中预定义了几个超级全局变量（superglobals） ，这意味着它们在一个脚本的全部作用域中都可用。 你不需要特别说明，就可以在函数及类中使用。</p>
<blockquote>
<p><a href="https://www.runoob.com/php/php-superglobals.html">详细介绍</a><br><a id="more"></a></p>
<h1 id="PHP-超级全局变量列表"><a href="#PHP-超级全局变量列表" class="headerlink" title="PHP 超级全局变量列表:"></a>PHP 超级全局变量列表:</h1><ul>
<li>$GLOBALS</li>
<li>$_SERVER</li>
<li>$_REQUEST</li>
<li>$_POST</li>
<li>$_GET</li>
<li>$_FILES</li>
<li>$_ENV</li>
<li>$_COOKIE</li>
<li>$_SESSION</li>
</ul>
</blockquote>
<h1 id="本文具体介绍-POST和-GET"><a href="#本文具体介绍-POST和-GET" class="headerlink" title="本文具体介绍$_POST和$_GET"></a>本文具体介绍$_POST和$_GET</h1><h2 id="POST"><a href="#POST" class="headerlink" title="$_POST"></a>$_POST</h2><p>　　PHP $_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”post”。</p>
<p>　　以下实例显示了两个输入字段（input）及提交按钮(submit)的表单(form)。 当用户通过点击 “Submit” 按钮提交表单数据时, 表单数据将发送至<form>标签中 action 属性中指定的脚本文件。 在这个实例中，我们指定文件来处理表单数据。如果你希望其他的PHP文件来处理该数据，你可以修改该指定的脚本文件名。 然后，我们可以使用超级全局变量 $_POST 来收集表单中的 input 字段数据:</form></p>
<h3 id="form-html-文件代码："><a href="#form-html-文件代码：" class="headerlink" title="form.html 文件代码："></a>form.html 文件代码：</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>菜鸟教程(runoob.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;welcome.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">名字: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;fname&quot;</span>&gt;</span></span><br><span class="line">年龄: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　当用户填写完上面的表单并点击提交按钮时，表单的数据会被送往名为 “welcome.php” 的 PHP 文件：</p>
<h3 id="welcome-php-文件代码："><a href="#welcome-php-文件代码：" class="headerlink" title="welcome.php 文件代码："></a>welcome.php 文件代码：</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">欢迎<span class="meta">&lt;?php</span> <span class="keyword">echo</span> $_POST[<span class="string">&quot;fname&quot;</span>]; <span class="meta">?&gt;</span>!&lt;br&gt;</span><br><span class="line">你的年龄是 <span class="meta">&lt;?php</span> <span class="keyword">echo</span> $_POST[<span class="string">&quot;age&quot;</span>]; <span class="meta">?&gt;</span>  岁。</span><br></pre></td></tr></table></figure>
<h2 id="GET"><a href="#GET" class="headerlink" title="$_GET"></a>$_GET</h2><p>　　PHP $_GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method=”get”。</p>
<p>　　$_GET 也可以收集URL中发送的数据。</p>
<h3 id="html代码"><a href="#html代码" class="headerlink" title="html代码"></a>html代码</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;test_get.php?subject=PHP&amp;web=runoob.com&quot;</span>&gt;</span>Test $GET<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>　　当用户点击链接 “Test $GET”, 参数 “subject” 和 “web” 将发送至”test_get.php”,你可以在 “test_get.php” 文件中使用 $_GET 变量来获取这些数据。</p>
<h3 id="test-get-php"><a href="#test-get-php" class="headerlink" title="test_get.php"></a>test_get.php</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Study &quot;</span> . $_GET[<span class="string">&#x27;subject&#x27;</span>] . <span class="string">&quot; @ &quot;</span> . $_GET[<span class="string">&#x27;web&#x27;</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>frontend</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>php数组</title>
    <url>/posts/php-4array/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p><a href="https://www.runoob.com/php/php-ref-array.html">数组相关函数</a></p>
          </div>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><ul>
<li>数值数组 - 带有数字 ID 键的数组</li>
<li>关联数组 - 带有指定的键的数组，每个键关联一个值</li>
<li>多维数组 - 包含一个或多个数组的数组<a id="more"></a>
</li>
</ul>
<h2 id="数值数组"><a href="#数值数组" class="headerlink" title="数值数组"></a>数值数组</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol>
<li>自动分配 ID 键<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$cars=<span class="keyword">array</span>(<span class="string">&quot;Volvo&quot;</span>,<span class="string">&quot;BMW&quot;</span>,<span class="string">&quot;Toyota&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>人工分配 ID 键：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$cars[<span class="number">0</span>]=<span class="string">&quot;Volvo&quot;</span>;</span><br><span class="line">$cars[<span class="number">1</span>]=<span class="string">&quot;BMW&quot;</span>;</span><br><span class="line">$cars[<span class="number">2</span>]=<span class="string">&quot;Toyota&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="count-函数"><a href="#count-函数" class="headerlink" title="count() 函数"></a>count() 函数</h3><p>返回数组元素数量</p>
<h2 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ol>
<li><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$age=<span class="keyword">array</span>(<span class="string">&quot;Peter&quot;</span>=&gt;<span class="string">&quot;35&quot;</span>,<span class="string">&quot;Ben&quot;</span>=&gt;<span class="string">&quot;37&quot;</span>,<span class="string">&quot;Joe&quot;</span>=&gt;<span class="string">&quot;43&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$age[<span class="string">&#x27;Peter&#x27;</span>]=<span class="string">&quot;35&quot;</span>;</span><br><span class="line">$age[<span class="string">&#x27;Ben&#x27;</span>]=<span class="string">&quot;37&quot;</span>;</span><br><span class="line">$age[<span class="string">&#x27;Joe&#x27;</span>]=<span class="string">&quot;43&quot;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="遍历关联数组"><a href="#遍历关联数组" class="headerlink" title="遍历关联数组"></a>遍历关联数组</h3>遍历并打印关联数组中的所有值，您可以使用 foreach 循环，如下所示：<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$age=<span class="keyword">array</span>(<span class="string">&quot;Peter&quot;</span>=&gt;<span class="string">&quot;35&quot;</span>,<span class="string">&quot;Ben&quot;</span>=&gt;<span class="string">&quot;37&quot;</span>,<span class="string">&quot;Joe&quot;</span>=&gt;<span class="string">&quot;43&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">foreach</span>($age <span class="keyword">as</span> $x=&gt;$x_value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Key=&quot;</span> . $x . <span class="string">&quot;, Value=&quot;</span> . $x_value . PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h1><ul>
<li>sort() - 对数组进行升序排列</li>
<li>rsort() - 对数组进行降序排列</li>
<li>asort() - 根据关联数组的值，对数组进行升序排列</li>
<li>ksort() - 根据关联数组的键，对数组进行升序排列</li>
<li>arsort() - 根据关联数组的值，对数组进行降序排列</li>
<li>krsort() - 根据关联数组的键，对数组进行降序排列</li>
</ul>
]]></content>
      <categories>
        <category>frontend</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>php运算符</title>
    <url>/posts/php-3oprator/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h1><blockquote>
<p>大多与c语言相同</p>
<h2 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h2><h3 id><a href="#" class="headerlink" title="==="></a>===</h3><p>绝对等于，如果 x 等于 y，且它们类型相同，则返回true。如5===”5” 返回 false</p>
<h3 id="lt-gt"><a href="#lt-gt" class="headerlink" title="&lt;&gt;"></a>&lt;&gt;</h3><p>不等于，如果 x 不等于 y，则返回 true。如5&lt;&gt;8 返回 true </p>
<h3 id="-1"><a href="#-1" class="headerlink" title="!=="></a>!==</h3><p>绝对不等于，如果 x 不等于 y，或它们类型不相同，则返回 true。5!==”5” 返回 true<br><a id="more"></a></p>
</blockquote>
<h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">(expr1) ? (expr2) : (expr3) </span><br></pre></td></tr></table></figure>
<p>　　对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。</p>
<p>　　自 PHP 5.3 起，可以省略三元运算符中间那部分。表达式 expr1 ?: expr3 在 expr1 求值为 TRUE 时返回 expr1，否则返回 expr3。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>　　以下实例中通过判断 $_GET 请求中含有 user 值，如果有返回 $_GET[‘user’]，否则返回 nobody：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$test = <span class="string">&#x27;菜鸟教程&#x27;</span>;</span><br><span class="line"><span class="comment">// 普通写法</span></span><br><span class="line">$username = <span class="keyword">isset</span>($test) ? $test : <span class="string">&#x27;nobody&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> $username, PHP_EOL;　<span class="comment">//注意：PHP_EOL 是一个换行符，兼容更大平台。</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// PHP 5.3+ 版本写法</span></span><br><span class="line">$username = $test ?: <span class="string">&#x27;nobody&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> $username, PHP_EOL;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="组合比较符-PHP7"><a href="#组合比较符-PHP7" class="headerlink" title="组合比较符(PHP7+)"></a>组合比较符(PHP7+)</h1><p>　　PHP7+ 支持组合比较符（combined comparison operator）也称之为太空船操作符，符号为 &lt;=&gt;。组合比较运算符可以轻松实现两个变量的比较，当然不仅限于数值类数据的比较。</p>
<p>语法格式如下：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$c = $a &lt;=&gt; $b;</span><br></pre></td></tr></table></figure><br>解析如下：</p>
<p>如果 $a &gt; $b, 则 $c 的值为 1。<br>如果 $a == $b, 则 $c 的值为 0。<br>如果 $a &lt; $b, 则 $c 的值为 -1。</p>
]]></content>
      <categories>
        <category>frontend</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>php EOF的使用</title>
    <url>/posts/php-2EOF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>　　PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字符串的方法。<br><a id="more"></a></p>
</blockquote>
<p>使用概述：</p>
<ol>
<li>必须后接分号，否则编译通不过。</li>
<li>EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。</li>
<li>结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。</li>
<li>开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。</li>
<li>当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。</li>
</ol>
<p>实例<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">echo</span> &lt;&lt;&lt;JK <span class="comment">//JK可以用任何字符串代替，需要与后面一致</span></span><br><span class="line">        &lt;h1&gt;我的第一个标题&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;我的第一个段落。&lt;/p&gt;</span><br><span class="line">JK;</span><br><span class="line"><span class="comment">// 结束需要独立一行且前后不能空格</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>frontend</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>php变量和常量</title>
    <url>/posts/php-1var/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="PHP-变量作用域"><a href="#PHP-变量作用域" class="headerlink" title="PHP 变量作用域"></a>PHP 变量作用域</h1><p>变量的作用域是脚本中变量可被引用/使用的部分。<br>PHP 有四种不同的变量作用域：</p>
<ul>
<li>local</li>
<li>global</li>
<li>static</li>
<li>parameter<a id="more"></a>
</li>
</ul>
<h2 id="local"><a href="#local" class="headerlink" title="local"></a>local</h2><p>　　默认情况下函数内部声明的变量皆为局部变量，仅在函数内部访问。</p>
<h2 id="global"><a href="#global" class="headerlink" title="global"></a>global</h2><ol>
<li>global 关键字用于函数内访问全局变量。</li>
</ol>
<p>　　在函数内调用函数外定义的全局变量，我们需要在函数中的变量前加上 global 关键字：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$x=<span class="number">5</span>;</span><br><span class="line">$y=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">global</span> $x,$y;</span><br><span class="line">    $y=$x+$y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">myTest();</span><br><span class="line"><span class="keyword">echo</span> $y; <span class="comment">// 输出 15</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>PHP 将所有全局变量存储在一个名为 $GLOBALS[index] 的数组中。 index 保存变量的名称。这个数组可以在函数内部访问，也可以直接用来更新全局变量。</li>
</ol>
<p>　　上面的实例可以写成这样：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$x=<span class="number">5</span>;</span><br><span class="line">$y=<span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myTest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    $GLOBALS[<span class="string">&#x27;y&#x27;</span>]=$GLOBALS[<span class="string">&#x27;x&#x27;</span>]+$GLOBALS[<span class="string">&#x27;y&#x27;</span>];</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">myTest();</span><br><span class="line"><span class="keyword">echo</span> $y;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>局部变量在函数结束后不删除，且static语句只执行一次。</p>
<h2 id="parameter"><a href="#parameter" class="headerlink" title="parameter"></a>parameter</h2><p>参数在函数调用时被传递进函数内。</p>
<h1 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h1><ul>
<li>字符串连接用’.’</li>
<li>strlen() 函数返回字符串长度</li>
<li>strpos() 函数在字符串内查找一个字符或一段指定的文本，strpos(“Hello world!”,”world”)返回6。</li>
</ul>
<p><a href="https://www.runoob.com/php/php-ref-string.html">字符串函数</a></p>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><h2 id="设置常量，使用-define-函数，函数语法如下："><a href="#设置常量，使用-define-函数，函数语法如下：" class="headerlink" title="设置常量，使用 define() 函数，函数语法如下："></a>设置常量，使用 define() 函数，函数语法如下：</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> define ( <span class="keyword">string</span> $name , mixed $value [, <span class="keyword">bool</span> $case_insensitive = <span class="literal">false</span> ] )</span><br></pre></td></tr></table></figure>
<p>该函数有三个参数:</p>
<ul>
<li>name：必选参数，常量名称，即标志符。</li>
<li>value：必选参数，常量的值。</li>
<li>case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感。默认是大小写敏感的。</li>
</ul>
<p>以下实例我们创建一个 区分大小写的常量, 常量值为 “欢迎访问 Runoob.com”：<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">// 区分大小写的常量名</span></span><br><span class="line">define(<span class="string">&quot;GREETING&quot;</span>, <span class="string">&quot;欢迎访问 Runoob.com&quot;</span>);</span><br><span class="line"><span class="keyword">echo</span> GREETING;    <span class="comment">// 输出 &quot;欢迎访问 Runoob.com&quot;</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> greeting;   <span class="comment">// 输出 &quot;greeting&quot;</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="常量是全局的"><a href="#常量是全局的" class="headerlink" title="常量是全局的"></a>常量是全局的</h2><p>可以在整个脚本的任何地方使用</p>
]]></content>
      <categories>
        <category>frontend</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>起风了</title>
    <url>/posts/suibi1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <h3 id="風立ちぬ、"><a href="#風立ちぬ、" class="headerlink" title="風立ちぬ、"></a>風立ちぬ、</h3><h3 id="いざ行きめやも。"><a href="#いざ行きめやも。" class="headerlink" title="いざ行きめやも。"></a>いざ行きめやも。</h3><h3 id="————堀辰雄《風立ちぬ》"><a href="#————堀辰雄《風立ちぬ》" class="headerlink" title="————堀辰雄《風立ちぬ》"></a>————堀辰雄《風立ちぬ》</h3>
            <i class="fa fa-quote-right"></i>
          </blockquote>
<a id="more"></a>
<h1 id="病人と愛にする"><a href="#病人と愛にする" class="headerlink" title="病人と愛にする"></a>病人と愛にする</h1><p>　　这究竟是怎样的一种情感，能让你明知道对方时日无多，却仍满怀期待地陪她在疗养院中度过她最后的时光。<br>　　那女子是这样的脆弱，又是如此温柔，让所有与她接触过的人都不禁想要轻抚她的额头。就如同冬日的雪地里长出的一朵稚嫩小野花，她的出现给人带来美好稍纵即逝的绝望，却又让人在她生命的最后一刻忍不住想用双手包裹，直至凋零。</p>
<blockquote>
<p>　　那是些欢愉的日子，欢愉得令人黯然神伤。<br>　　就如同早在我俩初次相遇两年之前的那个夏日里我于漫不经意间脱口而出、从此以后便喜欢上了它、无缘无故地常要浅吟低诵的“风乍起。合当奋意向人生。”那行诗句一般，分明忘怀已久，却又悄然苏生————可谓是早于人生之先、远比人生本身更为鲜活的日子。</p>
</blockquote>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言defer语句</title>
    <url>/posts/go-18defer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>本文转载自：<br>作者：simpleapples<br>链接：<a href="https://www.jianshu.com/p/79c029c0bd58">https://www.jianshu.com/p/79c029c0bd58</a><br>来源：简书</p>
          </div>
<h1 id="语句介绍"><a href="#语句介绍" class="headerlink" title="语句介绍"></a>语句介绍</h1><p>defer语句是Go中一个非常有用的特性，可以将一个方法延迟到包裹该方法的方法返回时执行，在实际应用中，defer语句可以充当其他语言中try…catch…的角色，也可以用来处理关闭文件句柄等收尾操作。<br><a id="more"></a></p>
<h1 id="触发时机"><a href="#触发时机" class="headerlink" title="触发时机"></a>触发时机</h1><ul>
<li>包裹defer的函数返回时</li>
<li>包裹defer的函数执行到末尾时</li>
<li>所在的goroutine发生panic时</li>
</ul>
<h1 id="defer执行顺序"><a href="#defer执行顺序" class="headerlink" title="defer执行顺序"></a>defer执行顺序</h1><p>当一个方法中有多个defer时， defer会将要延迟执行的方法“压栈”，当defer被触发时，将所有“压栈”的方法“出栈”并执行。所以defer的执行顺序是LIFO的。</p>
<p>所以下面这段代码的输出不是1 2 3，而是3 2 1。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stackingDefers</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><h2 id="坑1：defer在匿名返回值和命名返回值函数中的不同表现"><a href="#坑1：defer在匿名返回值和命名返回值函数中的不同表现" class="headerlink" title="坑1：defer在匿名返回值和命名返回值函数中的不同表现"></a>坑1：defer在匿名返回值和命名返回值函数中的不同表现</h2><p>先看下面两个方法执行的结果。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">returnValues</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        result++</span><br><span class="line">        fmt.Println(<span class="string">&quot;defer&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">namedReturnValues</span><span class="params">()</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        result++</span><br><span class="line">        fmt.Println(<span class="string">&quot;defer&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的方法会输出0，下面的方法输出1。上面的方法使用了匿名返回值，下面的使用了命名返回值，除此之外其他的逻辑均相同，为什么输出的结果会有区别呢？</p>
<p>要搞清这个问题首先需要了解defer的执行逻辑，文档中说defer语句在方法返回“时”触发，也就是说return和defer是“同时”执行的。以匿名返回值方法举例，过程如下。</p>
<ul>
<li>将result赋值给返回值（可以理解成Go自动创建了一个返回值retValue，相当于执行retValue = result）</li>
<li>然后检查是否有defer，如果有则执行</li>
<li>返回刚才创建的返回值（retValue）</li>
</ul>
<p>在这种情况下，defer中的修改是对result执行的，而不是retValue，所以defer返回的依然是retValue。在命名返回值方法中，由于返回值在方法定义时已经被定义，所以没有创建retValue的过程，result就是retValue，defer对于result的修改也会被直接返回。</p>
<h2 id="坑2：在for循环中使用defer可能导致的性能问题"><a href="#坑2：在for循环中使用defer可能导致的性能问题" class="headerlink" title="坑2：在for循环中使用defer可能导致的性能问题"></a>坑2：在for循环中使用defer可能导致的性能问题</h2><p>看下面的代码<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferInLoops</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        f, _ := os.Open(<span class="string">&quot;/etc/hosts&quot;</span>)</span><br><span class="line">        <span class="keyword">defer</span> f.Close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>defer在紧邻创建资源的语句后生命力，看上去逻辑没有什么问题。但是和直接调用相比，defer的执行存在着额外的开销，例如defer会对其后需要的参数进行内存拷贝，还需要对defer结构进行压栈出栈操作。所以在循环中定义defer可能导致大量的资源开销，在本例中，可以将f.Close()语句前的defer去掉，来减少大量defer导致的额外资源消耗。</p>
<h2 id="坑3：判断执行没有err之后，再defer释放资源"><a href="#坑3：判断执行没有err之后，再defer释放资源" class="headerlink" title="坑3：判断执行没有err之后，再defer释放资源"></a>坑3：判断执行没有err之后，再defer释放资源</h2><p>一些获取资源的操作可能会返回err参数，我们可以选择忽略返回的err参数，但是如果要使用defer进行延迟释放的的话，需要在使用defer之前先判断是否存在err，如果资源没有获取成功，即没有必要也不应该再对资源执行释放操作。如果不判断获取资源是否成功就执行释放操作的话，还有可能导致释放方法执行错误。</p>
<p>正确写法如下。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="comment">// 先判断操作是否成功</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果操作成功，再进行Close操作</span></span><br><span class="line"><span class="keyword">defer</span> resp.Body.Close()</span><br></pre></td></tr></table></figure></p>
<h2 id="坑4：调用os-Exit时defer不会被执行"><a href="#坑4：调用os-Exit时defer不会被执行" class="headerlink" title="坑4：调用os.Exit时defer不会被执行"></a>坑4：调用os.Exit时defer不会被执行</h2><p>当发生panic时，所在goroutine的所有defer会被执行，但是当调用os.Exit()方法退出程序时，defer并不会被执行。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferExit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;defer&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的defer并不会输出。</p>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言并发</title>
    <url>/posts/go-17bingfa/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Go 语言支持并发，我们只需要通过 go 关键字来开启 goroutine 即可。</p>
<h1 id="goroutine-语法格式："><a href="#goroutine-语法格式：" class="headerlink" title="goroutine 语法格式："></a>goroutine 语法格式：</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> 函数名( 参数列表 )</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="通道（channel）"><a href="#通道（channel）" class="headerlink" title="通道（channel）"></a>通道（channel）</h1><p>通道（channel）是用来传递数据的一个数据结构。</p>
<p>通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。操作符 &lt;- 用于指定通道的方向，发送或接收。如果未指定方向，则为双向通道。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- v    <span class="comment">// 把 v 发送到通道 ch</span></span><br><span class="line">v := &lt;-ch  <span class="comment">// 从 ch 接收数据</span></span><br><span class="line">           <span class="comment">// 并把值赋给 v</span></span><br></pre></td></tr></table></figure><br>声明一个通道很简单，我们使用chan关键字即可，通道在使用前必须先创建：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></p>
<h1 id="通道缓冲区"><a href="#通道缓冲区" class="headerlink" title="通道缓冲区"></a>通道缓冲区</h1><p>通道可以设置缓冲区，通过 make 的第二个参数指定缓冲区大小：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">100</span>)</span><br></pre></td></tr></table></figure><br>带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区里面，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据。</p>
<p>不过由于缓冲区的大小是有限的，所以还是必须有接收端来接收数据的，否则缓冲区一满，数据发送端就无法再发送数据了。<br><div class="note info">
            <p>注意：如果通道不带缓冲，发送方会阻塞直到接收方从通道中接收了值。如果通道带缓冲，发送方则会阻塞直到发送的值被拷贝到缓冲区内；如果缓冲区已满，则意味着需要等待直到某个接收方获取到一个值。接收方在有值可以接收之前会一直阻塞。</p>
          </div></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 这里我们定义了一个可以存储整数类型的带缓冲通道</span></span><br><span class="line">        <span class="comment">// 缓冲区大小为2</span></span><br><span class="line">        ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为 ch 是带缓冲的通道，我们可以同时发送两个数据</span></span><br><span class="line">        <span class="comment">// 而不用立刻需要去同步读取数据</span></span><br><span class="line">        ch &lt;- <span class="number">1</span></span><br><span class="line">        ch &lt;- <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取这两个数据</span></span><br><span class="line">        fmt.Println(&lt;-ch)</span><br><span class="line">        fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h1 id="Go-遍历通道与关闭通道"><a href="#Go-遍历通道与关闭通道" class="headerlink" title="Go 遍历通道与关闭通道"></a>Go 遍历通道与关闭通道</h1><p>Go 通过 range 关键字来实现遍历读取到的数据，类似于与数组或切片。格式如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v, ok := &lt;-ch</span><br></pre></td></tr></table></figure><br>如果通道接收不到数据后 ok 就为 false，这时通道就可以使用 close() 函数来关闭。</p>
<p>实例<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="keyword">int</span>, c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        x, y := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">                c &lt;- x</span><br><span class="line">                x, y = y, x+y</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> fibonacci(<span class="built_in">cap</span>(c), c)</span><br><span class="line">    <span class="comment">// range 函数遍历每个从通道接收到的数据，因为 c 在发送完 10 个</span></span><br><span class="line">    <span class="comment">// 数据之后就关闭了通道，所以这里我们 range 函数在接收到 10 个数据</span></span><br><span class="line">    <span class="comment">// 之后就结束了。如果上面的 c 通道不关闭，那么 range 函数就不</span></span><br><span class="line">    <span class="comment">// 会结束，从而在接收第 11 个数据的时候就阻塞了。</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">            fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">21</span><br><span class="line">34</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言错误处理</title>
    <url>/posts/go-16error/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Go 语言通过内置的错误接口提供了非常简单的错误处理机制。</p>
<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>error类型是一个接口类型，这是它的定义：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">    Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<h1 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h1><p>我们可以在编码中通过实现 error 接口类型来生成错误信息。</p>
<p>函数通常在最后的返回值中返回错误信息。使用errors.New 可返回一个错误信息：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(f <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;math: square root of negative number&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在下面的例子中，我们在调用Sqrt的时候传递的一个负数，然后就得到了non-nil的error对象，将此对象与nil比较，结果为true，所以fmt.Println(fmt包在处理error时会调用Error方法)被调用，以输出错误，请看下面调用的示例代码：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">result, err:= Sqrt(<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="再来个栗子"><a href="#再来个栗子" class="headerlink" title="再来个栗子"></a>再来个栗子</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个 DivideError 结构</span></span><br><span class="line"><span class="keyword">type</span> DivideError <span class="keyword">struct</span> &#123;</span><br><span class="line">    dividee <span class="keyword">int</span></span><br><span class="line">    divider <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 `error` 接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(de *DivideError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    strFormat := <span class="string">`</span></span><br><span class="line"><span class="string">    Cannot proceed, the divider is zero.</span></span><br><span class="line"><span class="string">    dividee: %d</span></span><br><span class="line"><span class="string">    divider: 0</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(strFormat, de.dividee)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 `int` 类型除法运算的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Divide</span><span class="params">(varDividee <span class="keyword">int</span>, varDivider <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>, errorMsg <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> varDivider == <span class="number">0</span> &#123;</span><br><span class="line">            dData := DivideError&#123;</span><br><span class="line">                    dividee: varDividee,</span><br><span class="line">                    divider: varDivider,</span><br><span class="line">            &#125;</span><br><span class="line">            errorMsg = dData.Error()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> varDividee / varDivider, <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常情况</span></span><br><span class="line">    <span class="keyword">if</span> result, errorMsg := Divide(<span class="number">100</span>, <span class="number">10</span>); errorMsg == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;100/10 = &quot;</span>, result)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当除数为零的时候会返回错误信息</span></span><br><span class="line">    <span class="keyword">if</span> _, errorMsg := Divide(<span class="number">100</span>, <span class="number">0</span>); errorMsg != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;errorMsg is: &quot;</span>, errorMsg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以上程序，输出结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100&#x2F;10 &#x3D;  10</span><br><span class="line">errorMsg is:  </span><br><span class="line">    Cannot proceed, the divider is zero.</span><br><span class="line">    dividee: 100</span><br><span class="line">    divider: 0</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言接口</title>
    <url>/posts/go-15interface/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Go 语言提供了另外一种数据类型即接口，它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。</p>
<a id="more"></a>
<p>实例<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Phone <span class="keyword">interface</span> &#123;    <span class="comment">//接口定义</span></span><br><span class="line">    call()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NokiaPhone <span class="keyword">struct</span> &#123;    <span class="comment">//结构体定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(nokiaPhone NokiaPhone)</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am Nokia, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IPhone <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(iPhone IPhone)</span> <span class="title">call</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;I am iPhone, I can call you!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> phone Phone</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(NokiaPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">    phone = <span class="built_in">new</span>(IPhone)</span><br><span class="line">    phone.call()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客将链接自动提交百度</title>
    <url>/posts/baidu-push/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>试过多种方法，发现这个是最高效的SEO</p>
<h1 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install hexo-baidu-url-submit  –save</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="在根目录配置文件-config-yml中："><a href="#在根目录配置文件-config-yml中：" class="headerlink" title="在根目录配置文件_config.yml中："></a>在根目录配置文件_config.yml中：</h1><h2 id="添加新字段"><a href="#添加新字段" class="headerlink" title="添加新字段"></a>添加新字段</h2><p>需要在<a href="https://ziyuan.baidu.com/">百度资源平台</a>注册并获取token秘钥<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">baidu_url_submit:</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">100</span> <span class="comment"># 提交最新的一个链接</span></span><br><span class="line">  <span class="attr">host:</span> <span class="string">wudong.tech</span> <span class="comment"># 在百度站长平台中注册的域名</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">23GYpxowKnhVsUM</span> <span class="comment"># 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidu_urls.txt</span> <span class="comment"># 文本文档的地址， 新链接会保存在此文本文档里</span></span><br></pre></td></tr></table></figure></p>
<h2 id="deploy中添加新的type"><a href="#deploy中添加新的type" class="headerlink" title="deploy中添加新的type"></a>deploy中添加新的type</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span>       <span class="comment">#这行最前面加-</span></span><br><span class="line">  <span class="attr">repo:</span> </span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">baidu_url_submitter</span>     <span class="comment">#这行是新加的</span></span><br></pre></td></tr></table></figure>
<h1 id="最后重新deploy一下就好啦。"><a href="#最后重新deploy一下就好啦。" class="headerlink" title="最后重新deploy一下就好啦。"></a>最后重新deploy一下就好啦。</h1>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言Map</title>
    <url>/posts/go-14map/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。</p>
<p>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>可以使用内建函数 make 也可以使用 map 关键字来定义 Map:<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 声明变量，默认 map 是 nil */</span></span><br><span class="line"><span class="keyword">var</span> map_variable <span class="keyword">map</span>[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 make 函数 */</span></span><br><span class="line">map_variable := <span class="built_in">make</span>(<span class="keyword">map</span>[key_data_type]value_data_type)</span><br></pre></td></tr></table></figure><br><a id="more"></a><br><div class="note info">
            <p>如果不初始化 map，那么就会创建一个 nil map。nil map 不能用来存放键值对</p>
          </div></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> countryCapitalMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span> <span class="comment">/*创建集合 */</span></span><br><span class="line">    countryCapitalMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* map插入key - value对,各个国家对应的首都 */</span></span><br><span class="line">    countryCapitalMap [ <span class="string">&quot;France&quot;</span> ] = <span class="string">&quot;巴黎&quot;</span></span><br><span class="line">    countryCapitalMap [ <span class="string">&quot;Italy&quot;</span> ] = <span class="string">&quot;罗马&quot;</span></span><br><span class="line">    countryCapitalMap [ <span class="string">&quot;Japan&quot;</span> ] = <span class="string">&quot;东京&quot;</span></span><br><span class="line">    countryCapitalMap [ <span class="string">&quot;India &quot;</span> ] = <span class="string">&quot;新德里&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*使用键输出地图值 */</span> </span><br><span class="line">    <span class="keyword">for</span> country := <span class="keyword">range</span> countryCapitalMap &#123;</span><br><span class="line">        fmt.Println(country, <span class="string">&quot;首都是&quot;</span>, countryCapitalMap [country])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*查看元素在集合中是否存在 */</span></span><br><span class="line">    capital, ok := countryCapitalMap [ <span class="string">&quot;American&quot;</span> ] <span class="comment">/*如果确定是真实的,则存在,否则不存在 */</span></span><br><span class="line">    <span class="comment">/*fmt.Println(capital) */</span></span><br><span class="line">    <span class="comment">/*fmt.Println(ok) */</span></span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;American 的首都是&quot;</span>, capital)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;American 的首都不存在&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="delete-函数"><a href="#delete-函数" class="headerlink" title="delete() 函数"></a>delete() 函数</h2><p>delete() 函数用于删除集合的元素, 参数为 map 和其对应的 key。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*删除上例中元素*/</span> </span><br><span class="line"><span class="built_in">delete</span>(countryCapitalMap, <span class="string">&quot;France&quot;</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言range</title>
    <url>/posts/go-13range/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Go 语言中 range 关键字用于 for 循环中迭代数组(array)、切片(slice)、通道(channel)或集合(map)的元素。</p>
<ul>
<li>在数组和切片中它返回元素的索引和索引对应的值，在集合中返回 key-value 对。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//这是我们使用range去求一个slice的和。使用数组跟这个很类似</span></span><br><span class="line">    nums := []<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        sum += num</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;sum:&quot;</span>, sum)</span><br><span class="line">    <span class="comment">//在数组上使用range将传入index和值两个变量。上面那个例子我们不需要使用该元素的序号，所以我们使用空白符&quot;_&quot;省略了。有时侯我们确实需要知道它的索引。</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num == <span class="number">3</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;index:&quot;</span>, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//range也可以用在map的键值对上。</span></span><br><span class="line">    kvs := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;banana&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> kvs &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s -&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//range也可以用来枚举Unicode字符串。第一个参数是字符的索引，第二个是字符（Unicode的值）本身。</span></span><br><span class="line">    <span class="keyword">for</span> i, c := <span class="keyword">range</span> <span class="string">&quot;go&quot;</span> &#123;</span><br><span class="line">        fmt.Println(i, c)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上运行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum: 9</span><br><span class="line">index: 1</span><br><span class="line">a -&gt; apple</span><br><span class="line">b -&gt; banana</span><br><span class="line">0 103</span><br><span class="line">1 111</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言——切片</title>
    <url>/posts/go-12slice/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>Go 语言切片是对数组的抽象。<br>Go 数组的长度不可改变，在特定场景中这样的集合就不太适用，Go中提供了一种灵活，功能强悍的内置类型切片(“动态数组”),与数组相比切片的长度是不固定的，可以追加元素，在追加时可能使切片的容量增大。<br><a id="more"></a><br>你可以声明一个未指定大小的数组来定义切片：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier []<span class="keyword">type</span>;   <span class="comment">//切片不需要说明长度,未赋值前identifier==nil</span></span><br><span class="line"><span class="keyword">var</span> slice1 []<span class="keyword">type</span> = <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>) <span class="comment">//或使用make()函数来创建切片</span></span><br><span class="line">slice1 := <span class="built_in">make</span>([]<span class="keyword">type</span>, <span class="built_in">len</span>)  <span class="comment">//也可以简写</span></span><br><span class="line"><span class="built_in">make</span>([]T, length, capacity) <span class="comment">// 也可以指定容量，其中capacity为可选参数</span></span><br></pre></td></tr></table></figure></p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>有三中方法<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s :=<span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="built_in">len</span>,<span class="built_in">cap</span>) </span><br><span class="line">s :=[] <span class="keyword">int</span> &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;</span><br><span class="line">s := arr[startIndex:endIndex] </span><br></pre></td></tr></table></figure></p>
<h1 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h1><h2 id="len-和-cap-函数"><a href="#len-和-cap-函数" class="headerlink" title="len() 和 cap() 函数"></a>len() 和 cap() 函数</h2><p>切片是可索引的，并且可以由 len() 方法获取长度。<br>切片提供了计算容量的方法 cap() 可以测量切片最长可以达到多少。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="built_in">len</span>(x),<span class="built_in">cap</span>(x),x)</span><br></pre></td></tr></table></figure></p>
<h2 id="append-和-copy-函数"><a href="#append-和-copy-函数" class="headerlink" title="append() 和 copy() 函数"></a>append() 和 copy() 函数</h2><p>如果想增加切片的容量，我们必须创建一个新的更大的切片并把原分片的内容都拷贝过来。<br>下面的代码描述了从拷贝切片的 copy 方法和向切片追加新元素的 append 方法。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 向切片添加一个元素 */</span></span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 同时添加多个元素 */</span></span><br><span class="line">numbers = <span class="built_in">append</span>(numbers, <span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 拷贝 numbers 的内容到 numbers1 */</span></span><br><span class="line"><span class="built_in">copy</span>(numbers1,numbers)</span><br></pre></td></tr></table></figure></p>
<h1 id="切片截取"><a href="#切片截取" class="headerlink" title="切片截取"></a>切片截取</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">numbers := []<span class="keyword">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;   <span class="comment">//len=9 cap=9 slice=[0 1 2 3 4 5 6 7 8]</span></span><br><span class="line">number3 := numbers[<span class="number">2</span>:<span class="number">5</span>]   <span class="comment">//len=3 cap=7 slice=[2 3 4],cap从[start:end]的start开始向后计算</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言结构体</title>
    <url>/posts/go-11struct/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h1><p>结构体定义需要使用 type 和 struct 语句。struct 语句定义一个新的数据类型，结构体中有一个或多个成员。type 语句设定了结构体的名称。结构体的格式如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Books <span class="keyword">struct</span> &#123;</span><br><span class="line">   title <span class="keyword">string</span></span><br><span class="line">   author <span class="keyword">string</span></span><br><span class="line">   subject <span class="keyword">string</span></span><br><span class="line">   book_id <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><a id="more"></a><br>一旦定义了结构体类型，它就能用于变量的声明，语法格式如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Books&#123;<span class="string">&quot;Go 语言&quot;</span>, <span class="string">&quot;www.runoob.com&quot;</span>, <span class="string">&quot;Go 语言教程&quot;</span>, <span class="number">6495407</span>&#125;</span><br><span class="line">或</span><br><span class="line">Books&#123;title: <span class="string">&quot;Go 语言&quot;</span>, author: <span class="string">&quot;www.runoob.com&quot;</span>, subject: <span class="string">&quot;Go 语言教程&quot;</span>, book_id: <span class="number">6495407</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="访问结构体成员"><a href="#访问结构体成员" class="headerlink" title="访问结构体成员"></a>访问结构体成员</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体.成员名</span></span><br><span class="line">Book2.title = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">Book2.author = <span class="string">&quot;www.runoob.com&quot;</span></span><br></pre></td></tr></table></figure>
<h1 id="结构体作为函数参数"><a href="#结构体作为函数参数" class="headerlink" title="结构体作为函数参数"></a>结构体作为函数参数</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">printBook(Book1) <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">( book Books )</span></span> &#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> struct_pointer *Books</span><br></pre></td></tr></table></figure>
<p>以上定义的指针变量可以存储结构体变量的地址。查看结构体变量地址，可以将 &amp; 符号放置于结构体变量前：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">struct_pointer = &amp;Book1</span><br></pre></td></tr></table></figure><br>使用结构体指针访问结构体成员，使用 “.” 操作符：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">struct_pointer.title</span><br></pre></td></tr></table></figure></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Book Books  <span class="comment">/* Declare Book1 of type Book */</span></span><br><span class="line">printBook(&amp;Book)  <span class="comment">//函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printBook</span><span class="params">( book *Books )</span></span> &#123;  <span class="comment">//函数定义</span></span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book title : %s\n&quot;</span>, book.title)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book author : %s\n&quot;</span>, book.author)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book subject : %s\n&quot;</span>, book.subject)</span><br><span class="line">   fmt.Printf( <span class="string">&quot;Book book_id : %d\n&quot;</span>, book.book_id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言指针</title>
    <url>/posts/go-10zhizhen/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h1><p>一个指针变量指向了一个值的内存地址<br>类似于变量和常量，在使用指针前你需要声明指针。指针声明格式如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var_name *<span class="keyword">var</span>-<span class="keyword">type</span></span><br></pre></td></tr></table></figure><br>var-type 为指针类型，var_name 为指针变量名，* 号用于指定变量是作为一个指针。以下是有效的指针声明：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ip *<span class="keyword">int</span>        <span class="comment">/* 指向整型*/</span></span><br><span class="line"><span class="keyword">var</span> fp *<span class="keyword">float32</span>    <span class="comment">/* 指向浮点型 */</span></span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<h1 id="使用指针"><a href="#使用指针" class="headerlink" title="使用指针"></a>使用指针</h1><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ul>
<li>定义指针变量。</li>
<li>为指针变量赋值。</li>
<li>访问指针变量中指向地址的值。<ul>
<li>在指针类型前面加上 * 号（前缀）来获取指针所指向的内容。</li>
</ul>
</li>
</ul>
<h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span>= <span class="number">20</span>   <span class="comment">/* 声明实际变量 */</span></span><br><span class="line"><span class="keyword">var</span> ip *<span class="keyword">int</span>        <span class="comment">/* 声明指针变量 */</span></span><br><span class="line">ip = &amp;a  <span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;a 变量的地址是: %x\n&quot;</span>, &amp;a  )</span><br><span class="line"><span class="comment">/* 指针变量的存储地址 */</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;ip 变量储存的指针地址: %x\n&quot;</span>, ip )</span><br><span class="line"><span class="comment">/* 使用指针访问值 */</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;*ip 变量的值: %d\n&quot;</span>, *ip )</span><br></pre></td></tr></table></figure>
<h2 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span>  ptr *<span class="keyword">int</span>      <span class="comment">/* 不赋值,ptr=0 */</span></span><br><span class="line"><span class="keyword">if</span>(ptr != <span class="literal">nil</span>)     <span class="comment">/* ptr 不是空指针 */</span></span><br><span class="line"><span class="keyword">if</span>(ptr == <span class="literal">nil</span>)     <span class="comment">/* ptr 是空指针 */</span></span><br></pre></td></tr></table></figure>
<h1 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ptr [MAX]*<span class="keyword">int</span>; <span class="comment">//定义</span></span><br><span class="line">ptr[i] = &amp;a[i] <span class="comment">/* 整数地址赋值给指针数组 */</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;a[%d] = %d\n&quot;</span>, i,*ptr[i] )  <span class="comment">//访问</span></span><br></pre></td></tr></table></figure>
<h1 id="Go-语言指针作为函数参数"><a href="#Go-语言指针作为函数参数" class="headerlink" title="Go 语言指针作为函数参数"></a>Go 语言指针作为函数参数</h1><p>Go 语言允许向函数传递指针，只需要在函数定义的参数上设置为指针类型即可。<br>以下实例演示了如何向函数传递指针，并在函数调用后修改函数内的值：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">swap(&amp;a, &amp;b);   <span class="comment">//函数调用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="keyword">int</span>, y *<span class="keyword">int</span>)</span></span> &#123;  <span class="comment">//函数定义</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言数组</title>
    <url>/posts/go-9array/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="声明数组"><a href="#声明数组" class="headerlink" title="声明数组"></a>声明数组</h1><p>Go 语言数组声明需要指定元素类型及元素个数，语法格式如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable_name [SIZE] variable_type</span><br></pre></td></tr></table></figure><br>以上为一维数组的定义方式。例如以下定义了数组 balance 长度为 10 类型为 float32：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balance [<span class="number">10</span>] <span class="keyword">float32</span></span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<h1 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h1><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balance = [<span class="number">5</span>]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br><span class="line"><span class="comment">//忽略 [] 中的数字不设置数组大小</span></span><br><span class="line"> <span class="keyword">var</span> balance = [...]<span class="keyword">float32</span>&#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>二维数组是最简单的多维数组，二维数组本质上是由一维数组组成的。二维数组定义方式如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayName [ x ][ y ] variable_type</span><br></pre></td></tr></table></figure></p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>多维数组可通过大括号来初始值。以下实例为一个 3 行 4 列的二维数组：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">3</span>][<span class="number">4</span>]<span class="keyword">int</span>&#123;  </span><br><span class="line"> &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125; ,   <span class="comment">/*  第一行索引为 0 */</span></span><br><span class="line"> &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125; ,   <span class="comment">/*  第二行索引为 1 */</span></span><br><span class="line"> &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;,   <span class="comment">/* 第三行索引为 2 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="向函数传数组"><a href="#向函数传数组" class="headerlink" title="向函数传数组"></a>向函数传数组</h1><ol>
<li><p>形参设定数组大小：<code>void myFunction(param [10]int)</code></p>
</li>
<li><p>形参未设定数组大小：<code>void myFunction(param []int)</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言函数</title>
    <url>/posts/go-8func/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><h2 id="Go-语言函数定义格式如下："><a href="#Go-语言函数定义格式如下：" class="headerlink" title="Go 语言函数定义格式如下："></a>Go 语言函数定义格式如下：</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">function_name</span><span class="params">( [parameter list] )</span> [<span class="title">return_types</span>]</span> &#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="函数定义解析："><a href="#函数定义解析：" class="headerlink" title="函数定义解析："></a>函数定义解析：</h2><ul>
<li>func：函数由 func 开始声明</li>
<li>function_name：函数名称，函数名和参数列表一起构成了函数签名。</li>
<li>parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。</li>
<li>return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。</li>
<li>函数体：函数定义的代码集合。</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>以下实例为 max() 函数的代码，该函数传入两个整型参数 num1 和 num2，并返回这两个参数的最大值：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 函数返回两个数的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 声明局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>当创建函数时，你定义了函数需要做什么，通过调用该函数来执行指定任务。<br>调用函数，向函数传递参数，并返回值，例如：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">   <span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">200</span></span><br><span class="line">   <span class="keyword">var</span> ret <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用函数并返回最大值 */</span></span><br><span class="line">   ret = max(a, b)</span><br><span class="line"></span><br><span class="line">   fmt.Printf( <span class="string">&quot;最大值是 : %d\n&quot;</span>, ret )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 函数返回两个数的最大值 */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(num1, num2 <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (num1 &gt; num2) &#123;</span><br><span class="line">      result = num1</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = num2</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x, y <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> y, x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h1><h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><p>传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p>引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 定义交换值函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(x *<span class="keyword">int</span>, y *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> temp <span class="keyword">int</span></span><br><span class="line">   temp = *x    <span class="comment">/* 保持 x 地址上的值 */</span></span><br><span class="line">   *x = *y      <span class="comment">/* 将 y 值赋给 x */</span></span><br><span class="line">   *y = temp    <span class="comment">/* 将 temp 值赋给 y */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">swap(&amp;a, &amp;b)</span><br></pre></td></tr></table></figure></p>
<h1 id="函数用法"><a href="#函数用法" class="headerlink" title="函数用法"></a>函数用法</h1><h2 id="函数作为另外一个函数的实参"><a href="#函数作为另外一个函数的实参" class="headerlink" title="函数作为另外一个函数的实参"></a>函数作为另外一个函数的实参</h2><p>函数定义后可作为另外一个函数的实参数传入<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* 声明函数变量 */</span></span><br><span class="line">   getSquareRoot := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> math.Sqrt(x)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 使用函数 */</span></span><br><span class="line">   fmt.Println(getSquareRoot(<span class="number">9</span>))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包是匿名函数，可在动态编程中使用。<br>以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSequence</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">   i:=<span class="number">0</span></span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">      i+=<span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> i  </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">/* nextNumber 为一个函数，函数 i 为 0 */</span></span><br><span class="line">   nextNumber := getSequence()  </span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 调用 nextNumber 函数，i 变量自增 1 并返回 */</span></span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   fmt.Println(nextNumber())</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/* 创建新的函数 nextNumber1，并查看结果 */</span></span><br><span class="line">   nextNumber1 := getSequence()  </span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">   fmt.Println(nextNumber1())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法就是一个包含了接受者的函数<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(variable_name variable_data_type)</span> <span class="title">function_name</span><span class="params">()</span> [<span class="title">return_type</span>]</span>&#123;</span><br><span class="line">   <span class="comment">/* 函数体*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>下面定义一个结构体类型和该类型的一个方法：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义结构体 */</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">  radius <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> c1 Circle</span><br><span class="line">  c1.radius = <span class="number">10.00</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;圆的面积 = &quot;</span>, c1.getArea())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该 method 属于 Circle 类型对象中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c Circle)</span> <span class="title">getArea</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">  <span class="comment">//c.radius 即为 Circle 类型对象中的属性</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3.14</span> * c.radius * c.radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言循环语句</title>
    <url>/posts/go-7xunhuan/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ol>
<li>和 C 语言的 for 一样：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">                sum += i</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ol>
<li>和 C 的 while 一样：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sum := <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> sum &lt;= <span class="number">10</span>&#123;</span><br><span class="line">                sum += sum</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(sum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>和 C 的 for(;;) 一样：</li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        sum := <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            sum++ <span class="comment">// 无限循环下去</span></span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Println(sum) <span class="comment">// 无法输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="For-each-range-循环"><a href="#For-each-range-循环" class="headerlink" title="For-each range 循环"></a>For-each range 循环</h2><p>这种格式的循环可以对字符串、数组、切片等进行迭代输出元素。<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">        strings := []<span class="keyword">string</span>&#123;<span class="string">&quot;google&quot;</span>, <span class="string">&quot;runoob&quot;</span>&#125;</span><br><span class="line">        <span class="keyword">for</span> i, s := <span class="keyword">range</span> strings &#123;</span><br><span class="line">                fmt.Println(i, s)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        numbers := [<span class="number">6</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>&#125; </span><br><span class="line">        <span class="keyword">for</span> i,x:= <span class="keyword">range</span> numbers &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;第 %d 位 x 的值 = %d\n&quot;</span>, i,x)</span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h1><h2 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h2><h3 id="Go-语言中-break-语句用于以下两方面："><a href="#Go-语言中-break-语句用于以下两方面：" class="headerlink" title="Go 语言中 break 语句用于以下两方面："></a>Go 语言中 break 语句用于以下两方面：</h3><ul>
<li>用于循环语句中跳出循环，并开始执行循环之后的语句。<br>（在多重循环中，可以用标号 label 标出想 break 的循环。）</li>
<li>break 在 switch（开关语句）中在执行一条 case 后跳出语句的作用。</li>
</ul>
<h3 id="label标号举例"><a href="#label标号举例" class="headerlink" title="label标号举例"></a>label标号举例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- break ----&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">                <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                        fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                        <span class="keyword">break</span> <span class="comment">//跳出最近一层循环</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- break label ----&quot;</span>)</span><br><span class="line">    re:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">            <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                <span class="keyword">break</span> re  <span class="comment">//直接结束re语句</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h2><h3 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h3><ul>
<li>for 循环中，执行 continue 语句会触发 for 增量语句的执行。</li>
<li>在多重循环中，可以用标号 label 标出想 continue 的循环。</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 不使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- continue ---- &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">            <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                <span class="keyword">continue</span>  <span class="comment">//i2++</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用标记</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;---- continue label ----&quot;</span>)</span><br><span class="line">    re:</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;i: %d\n&quot;</span>, i)</span><br><span class="line">                <span class="keyword">for</span> i2 := <span class="number">11</span>; i2 &lt;= <span class="number">13</span>; i2++ &#123;</span><br><span class="line">                    fmt.Printf(<span class="string">&quot;i2: %d\n&quot;</span>, i2)</span><br><span class="line">                    <span class="keyword">continue</span> re <span class="comment">//i++</span></span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h2><p>Go 语言的 goto 语句可以无条件地转移到过程中指定的行。</p>
<h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>goto配合label LOOP使用，相当于for配合continue<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">/* 定义局部变量 */</span></span><br><span class="line">   <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/* 循环 */</span></span><br><span class="line">   LOOP: <span class="keyword">for</span> a &lt; <span class="number">20</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> a == <span class="number">15</span> &#123;</span><br><span class="line">         <span class="comment">/* 跳过迭代 */</span></span><br><span class="line">         a = a + <span class="number">1</span></span><br><span class="line">         <span class="keyword">goto</span> LOOP</span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;a的值为 : %d\n&quot;</span>, a)</span><br><span class="line">      a++     </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>贯口</title>
    <url>/posts/guanko/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>对口相声中常见的表现形式，也叫“背口”。“贯口”的“贯”字，是一气呵成，一贯到底的意思。常见的段子如《报菜名》《八扇屏 》《地理图》《白事会》都含有大段的贯口。<br>贯口分为大贯儿和小贯儿两种。大贯儿一般上百句，例如《报菜名》、《地理图》（并称“两大贯儿”）。小贯儿一般十几句到几十句不等，例如《白事会》中就有一些小贯儿。<br><a id="more"></a></p>
</blockquote>
<h2 id="报菜名"><a href="#报菜名" class="headerlink" title="报菜名"></a>报菜名</h2><p>蒸羊羔，蒸熊掌，蒸鹿尾儿，烧花鸭，烧雏鸡儿，烧子鹅。<br>卤猪卤鸭，酱鸡腊肉，松花小肚儿，晾肉香肠。<br>什锦苏盘，熏鸡白肚儿，清蒸八宝-猪，江米酿鸭子。<br>罐儿野鸡，罐儿鹌鹑,<br>卤什件儿，卤子鹅,山鸡兔脯菜蟒银鱼,清蒸哈什蚂。<br>烩鸭丝烩鸭腰烩鸭条,清拌腰丝儿黄心管儿,<br>焖白鳝焖黄鳝,豆鼓鲇鱼,锅烧鲤鱼，锅烧鲇鱼，清蒸甲鱼，抓炒鲤鱼,抓炒对虾。<br>软炸里脊软炸鸡,<br>什锦套肠,麻酥油卷儿熘肘寒尖。<br>熘鲜蘑，熘鱼脯儿熘鱼肚儿熘鱼片儿，醋熘肉片儿。<br>烩三鲜,烩白蘑，烩鸽子蛋,炒银丝烩鳗鱼,炒白虾炝青蛤,炒面鱼炝芦笋,<br>芙蓉燕菜,炒虾仁烩虾仁，烩腰花烩海参，锅烧海参,锅烧白菜,<br>炸太耳，炒田鸡，<br>桂花翅子，清蒸翅子，清蒸江瑶柱，糖溜芡实米,<br>拌鸡丝儿拌肚丝儿，什锦豆腐什锦丁儿，<br>糟虾糟蟹糟鱼，糟熘鱼片儿，<br>熘蟹肉炒蟹肉，蒸南瓜，爙倭瓜，炒丝瓜，爙冬瓜，<br>焖鸡掌,焖鸭掌,焖笋,烩茭白,<br>茄干儿涮羊肉,鸭羹,蟹肉羹,是三鲜木樨汤,<br>红丸子,白丸子,熘丸子,炸丸子,南涧丸子,木樨丸子,三鲜丸子，四喜丸子，龟炸丸子，豆腐丸子,鲜炸丸子,玉腐丸子，氽丸子,<br>一品肉,樱桃肉,马牙肉,红闷肉,黄闷肉，坛子肉，<br>糊肉扣肉,松肉厚肉，烧肉烤肉,腊肉白肉,酱豆腐肉,<br>红肘子,白肘子,水晶肘子,蜜蜡肘子,酱豆腐肘子<br>蒸羊肉,酱羊肉，烧羊肉,烤羊肉，五香羊肉,爆羊肉.<br>氽三样儿,爆三样儿,烩银丝，烩散丹,油焖杂碎三鲜鱼翅栗子鸡,尖氽活鲤鱼,是板鸭筒子鸡。</p>
<hr>
<video src="http://file.panjiangtao.cn/baocaiming.mp4" type="video/mp4" poster="http://file.panjiangtao.cn/baocaiming.jpg" controls="controls">
 4     <p>你的浏览器不支持video标签.</p>
 5 </video>

<h2 id="八扇屏之莽撞人"><a href="#八扇屏之莽撞人" class="headerlink" title="八扇屏之莽撞人"></a>八扇屏之莽撞人</h2><p>　　后汉三国年间，有一位莽撞人。自桃园三结义以来，大爷姓刘名备字玄德，家住大树楼桑。二弟姓关名羽字云长，家住山西蒲州解梁县。三弟姓张名飞字翼德，家住涿州范阳郡。后续四弟，姓赵名云字子龙，家住真定府常山县，百战百胜，号称为常胜将军。</p>
<p>　　只皆因长坂坡前，一场鏖战。那赵云，单枪匹马，闯入曹营。砍倒大蠹两杆，夺槊三条。马落陷坑，堪堪废命。曹孟德，在山头之上观瞧，见一穿白小将，白盔白甲白旗靠，胯下白龙马，掌中亮银枪，实乃一员勇将。</p>
<p>　　当下就有爱将之意。旁有徐庶暗中保护赵云，那徐庶，自进得曹营以来，一语未发。今见赵将军马落陷坑，堪堪废命，口尊丞相，莫非有爱将之意？ 曹操言道，正是。徐庶言道，何不收留此将。</p>
<p>　　曹操闻听，急忙传令，令出山摇动，三军听分明，我要活赵云，不要死子龙。倘有一兵一将 伤损赵将军之性命，八十三万人马，五十一员战将，与他一人抵命。众将闻听，不敢上前，唯有后退。那赵云，一仗怀揣幼主，二仗常胜将军之特勇。</p>
<p>　　杀了个七进七出，这才闯出重围。曹操一见，这样勇将，焉能放走。在后面紧紧追赶。追至在当阳桥前，张飞赶到， 高叫四弟不必惊慌，某家在此，料也无妨！让过赵云的人马，曹操赶到，不见赵云，见一黑脸大汉，立于桥头之上。</p>
<p>　　曹操忙问夏侯憞， 这黑脸大汉，他是何人？夏侯憞道，此乃是张飞，一莽撞人。曹操闻听，大吃一惊。想当初关公在白马坡斩颜良诛文丑之时，曾对某家言道，他有一结拜三弟，姓张名飞字翼德，百万军中取上将之首级如探囊取物，反掌观纹。</p>
<p>　　今日一见，果然英勇，来呀，撤去某家青罗伞盖，观一观莽撞人的武艺如何？青罗伞盖撤下，但见张飞豹头环眼，面如润铁，黑中透亮，亮中透黑。颏下扎里扎沙一部黑钢髯，犹如钢针，恰似铁线。头戴镔铁盔，二龙斗宝，朱缨飘洒，上嵌八宝云罗伞盖，花冠云长。</p>
<p>　　身披锁子大叶连环甲，内衬皂罗袍。足蹬虎头战靴，跨下马，万里烟云兽，掌中丈八蛇矛。立于桥头之上，咬牙切齿，捶胸愤恨。大骂，曹操听真，呔！今有你家张三爷在此，尔或攻，或战或进或退或争或斗，不攻不战不进不退不争不斗，尔乃匹夫之辈。</p>
<p>　　大喊一声，曹兵吓退。大喊二声，顺水横流。大喊三声，把当阳桥吓断。后人有诗赞之曰，长坂桥前救赵云，吓退曹操百万军，姓张名飞字翼德，万古留芳莽撞人。</p>
<hr>
<video src="http://file.panjiangtao.cn/mangzhuangren.mp4" type="video/mp4" poster="http://file.panjiangtao.cn/mangzhuangren.jpg" controls="controls">
 4     <p>你的浏览器不支持video标签.</p>
 5 </video>

<h2 id="十八愁"><a href="#十八愁" class="headerlink" title="十八愁"></a>十八愁</h2><p>数九寒天，冷风嗖<br>年～年春打六九头<br>正月十五是个龙灯会，有一对狮～子滚绣球啊<br>三月三，王母娘娘蟠桃会<br>大闹天宫啊孙猴又把那个仙桃偷<br>五月单五是端阳日啊，白蛇许仙不到头<br>七月七，传说天河配啊，牛郎织女泪双流<br>八月十五啊云遮月，月里的嫦娥～犯～了忧愁<br>要说愁，净说愁啊，您听我唱上一回绕口令儿十八愁<br>虎也愁，狼也愁<br>象也愁，鹿也愁啊<br>骡子也愁马也愁<br>羊也愁，牛也愁，狗也愁，猪也愁啊<br>鸭子也愁鹅也愁<br>蛤蟆愁，蛤蜊愁，螃蟹也愁，乌龟愁啊，<br>鱼愁虾愁～，各有分由<br>虎愁，不敢把那高山下<br>狼愁的野心不改耍滑头<br>象愁那脸憨皮又厚啊<br>鹿也愁，脑袋上七叉八叉地长犄角<br>马愁鞴鞍行千里呐，骡子愁得一世休<br>羊愁从小把胡子长呐，牛愁愁得犯牛轴<br>狗愁改不了那净吃屎呐，猪愁离不开那臭水沟<br>鸭子愁呢扁了它的嘴，鹅愁得脑袋上它愁了一个奔儿了头<br>蛤蟆愁，长了一身脓疱疥呐，螃蟹愁得净横搂啊<br>蛤蜊也愁，闭关自守啊，那乌龟愁得～不敢出头<br>那个鱼愁离水不能够走呢，虾米愁得，空枪乱扎～没有准头<br>这个绕口令儿最难唱<br>我唱～的是<br>前门楼子九丈九，四门三桥五牌楼，出了便门儿往东走啊，离城四十到通州<br>通州倒有啊，六十六条胡同口<br>在里边住～着一个六十六岁刘老六啊，六十六岁六老刘啊，六十六岁的刘老头这么老哥儿仨<br>盖了那，六十六间好高楼<br>在楼里头有啊，六十六篓桂花油啊<br>在篓上面蒙着六～十六匹罗缎绸<br>在绸上面绣着六～十六个狮子滚绣球<br>在楼外头，栽了那，六十六根儿檀木轴<br>在轴上面拴着六～十六头大牤牛<br>在牛上面驮着六十六个大马猴<br>刘老六六老刘啊刘老头这么老哥仨<br>倒坐～在门口啃骨头<br>打南边来～了一条狗，这条狗好眼熟啊<br>它好像那大～大妈家，大大眉毛、大～大眼睛、大～大鼻子，大大耳朵、大大口啊、大～大妈家的大号挠头狮子狗<br>打北边又来一条狗啊，这条狗它也眼熟啊<br>它好像那二～大妈妈家、二大眉毛、二～大眼睛、二～大鼻子，二大耳朵、二大口啊、二～大妈家的二号挠头狮子狗<br>这两条狗啊抢骨头，它为抢骨～头抢成了仇<br>从南头跑到北头，撞倒了<br>六十六间好高楼，撞洒～了六十六篓桂花油<br>油了六十六匹罗缎绸啊，脏了六～十六个狮～子滚绣球，在楼外头，<br>砸倒了，六十六根儿檀木轴啊，砸惊了六十六头大牤牛，砸跑了六～十六个大马猴<br>打南边儿来个气～不休，手里头拿了个土坯头它去打狗的头<br>也不知气不休的土坯头啊打了狗～的头啊，还是那狗～的头，撞坏～了气不休的土坯头<br>打北边儿来了个秃妞妞，手里拿着个油篓口她去套狗～的头啊<br>也不知秃妞妞的油篓口啊，套上狗的头啊，还是那狗的头啊，钻进～了秃妞妞的油篓口啊<br>刘老六六老刘啊刘老头这么老哥仨<br>打跑了狗啊，他盖起来，六～十六间好高楼啊<br>收起来六十六篓桂花油，洗干净六～十六匹罗缎绸<br>他洗净了，六十六个狮～子滚绣球<br>在楼外头，栽起来，六十六棵儿檀木轴<br>牵回来六十六头大牤牛，逮回来六～十六个大马猴<br>刘老六六老刘啊刘老头这么老哥仨，他又看到那个鸡奔碎米墩漏豆，这个狗啃油篓篓油漏<br>鸡不奔这碎米墩不漏豆，这个狗不啃的油篓篓不漏油啊<br>绕口令儿最难唱<br>我唱～的是，正月里正月正有姐妹二人去逛灯<br>大～姑娘名叫粉红女，二～姑娘名叫女粉红啊<br>粉红女啊身穿一件粉红袄啊，女粉红她身穿一件袄粉红啊<br>粉红女，怀抱～着一瓶粉红酒啊，女粉红她怀抱一瓶酒粉红<br>粉红女女粉红啊，姐儿俩来到了无人处啊，推杯换盏饮刘伶<br>女粉红喝～了粉红女的粉红酒，粉红女饮了女粉红的酒粉红<br>粉红女喝了个酩酊醉，女粉红喝了个醉酩酊<br>女粉红见～着粉红女就打，粉红女揪～着女粉红就拧<br>女粉红撕～了粉红女的粉红袄，粉红女扯～了女粉红的袄粉红<br>姐儿俩打罢停了手啊，自己买线自己缝<br>粉红女买～了一条粉红线，女粉红买了那么一条线粉红啊<br>粉红女她反缝缝缝粉红袄，女粉红她缝反缝缝袄粉红<br>出前门，奔正南<br>有一个面铺面门面冲南<br>这个面铺挂着个蓝布棉门帘<br>摘～了蓝布棉门帘，我敲了敲这个面铺面门面冲南<br>挂上个蓝布棉门帘，我瞧了瞧啊，䁖了䁖啊，把了把啊，看了看啊，<br>这～个面铺面门还是面冲南<br>说出西门～走七步，拾块麂皮补皮裤<br>是麂皮补皮裤，不是麂皮不必补我的麂皮裤<br>说揭着窗户撕字纸，是字纸撕字纸，不是字纸不必撕字纸，在字纸里<br>裹～着一包细银丝，银丝上趴着四千四百四十四个似死似不死的死涩小死虱子皮儿啊<br>说我家有个肥净白净八斤鸡，飞到～了张家后院里<br>张家后院有个肥净白净八斤狗啊，咬了我的肥净白净八斤鸡<br>卖～了他的肥净白净八斤狗啊，赔了我的肥净白净八斤鸡<br>鸡登八八登鸡，鸡不登篱～笆，篱笆也不登鸡啊<br>说苏州有一个苏胡子，这个湖州有一个胡梳子<br>苏州的苏胡子找湖州的胡梳子借梳胡子的梳子梳胡子<br>山前住着一个严圆眼，山后边儿住了个严眼圆<br>二人山前来比眼<br>也不知严圆眼比严眼圆的眼圆，还是严眼圆比严圆眼的圆眼<br>山前，住了一个崔粗腿，山后～边儿住了个崔腿粗<br>二位山前来比腿，也～不知<br>崔粗腿，比崔腿粗的腿粗，还是崔腿粗比崔粗腿的粗腿<br>山前有四十四个小狮子，山后有四十四棵死涩柿子树<br>山前那四十四个小狮子，吃了山后边儿，四十四棵死涩柿子树的涩柿子<br>山前那四十四个小狮子，让山后边儿，四十四棵死涩柿子树的涩柿子给涩死了<br>说你会炖我的炖冻豆腐，来炖我的炖冻豆腐<br>你不会炖我的炖冻豆腐，比胡炖乱炖假充会炖～炖坏～了我的炖冻豆腐<br>说扁担长～板凳宽呐，板凳没有扁担长啊，扁担没有板凳宽<br>这个扁担绑在了板凳上，这个板凳不让这个扁担绑在了板凳上<br>扁担偏要扁担绑在了板凳上，这个板凳偏不让那个扁担绑在了板凳上<br>扁担偏要扁担绑在了板凳上<br>闲来没事儿，出趟城西啊<br>树～木琅琳呐数高低<br>一二三，三二一，一二三四五六七七六五四三二一,<br>六五四三二一啊，五四三二一啊，四三二一，三二一啊，二一一呀一个一啊<br>我数了半天一棵树，一棵树长着七个枝儿<br>一个枝儿结着一样果子， 结～的是那槟子橙子桔子柿子李子栗子梨啊<br>这就是绕口令儿，一个小段儿，我祝大家～身体健康～寿比天齐～</p>
<hr>
<video src="http://file.panjiangtao.cn/shibachou.mp4" type="video/mp4" poster="http://file.panjiangtao.cn/shibachou.jpg" controls="controls">
 4     <p>你的浏览器不支持video标签.</p>
 5 </video>]]></content>
      <categories>
        <category>相声</category>
      </categories>
      <tags>
        <tag>贯口</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言条件语句</title>
    <url>/posts/go-6tiaojian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Go-语言条件语句"><a href="#Go-语言条件语句" class="headerlink" title="Go 语言条件语句"></a>Go 语言条件语句</h1><p>条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">语句</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/go/go-if-statement.html">if 语句</a></td>
<td style="text-align:left"><strong>if 语句</strong> 由一个布尔表达式后紧跟一个或多个语句组成。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/go/go-if-else-statement.html">if…else 语句</a></td>
<td style="text-align:left"><strong>if 语句</strong> 后可以使用可选的 <strong>else 语句</strong>, else 语句中的表达式在布尔表达式为 false 时执行。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/go/go-nested-if-statements.html">if 嵌套语句</a></td>
<td style="text-align:left">你可以在 <strong>if</strong> 或 <strong>else if</strong> 语句中嵌入一个或多个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/go/go-switch-statement.html">switch 语句</a></td>
<td style="text-align:left"><strong>switch</strong> 语句用于基于不同条件执行不同动作。</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://www.runoob.com/go/go-select-statement.html">select 语句</a></td>
<td style="text-align:left"><strong>select</strong> 语句类似于 <strong>switch</strong> 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。</td>
</tr>
</tbody>
</table>
</div>
<a id="more"></a>
<p>if 语句、if…else 语句、if 嵌套语句与C语言一致，不加赘述</p>
<h2 id="Go-语言-switch-语句"><a href="#Go-语言-switch-语句" class="headerlink" title="Go 语言 switch 语句"></a>Go 语言 switch 语句</h2><ul>
<li>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上至下逐一测试，直到匹配为止。</li>
<li>switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加 break。</li>
<li>switch 默认情况下 case 最后自带 break 语句，匹配成功后就不会执行其他 case，如果我们需要执行后面的 case，可以使用 fallthrough 。</li>
</ul>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>可以加break语句<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> var1 &#123;</span><br><span class="line">    <span class="keyword">case</span> val1:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">case</span> val2:</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h3><p>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</p>
<p>Type Switch 语法格式如下：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> x.(<span class="keyword">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">type</span>:</span><br><span class="line">       statement(s); </span><br><span class="line">    <span class="comment">/* 你可以定义任意个数的case */</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="fallthrough"><a href="#fallthrough" class="headerlink" title="fallthrough"></a>fallthrough</h3><p>使用 fallthrough 会强制执行后面的 case 语句，fallthrough 不会判断下一条 case 的表达式结果是否为 true。<br>举例<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;1、case 条件语句为 false&quot;</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;2、case 条件语句为 true&quot;</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;3、case 条件语句为 false&quot;</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;4、case 条件语句为 true&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">false</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;5、case 条件语句为 false&quot;</span>)</span><br><span class="line">            <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;6、默认 case&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>结果为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2、case 条件语句为 true</span><br><span class="line">3、case 条件语句为 false</span><br><span class="line">4、case 条件语句为 true</span><br></pre></td></tr></table></figure></p>
<h2 id="Go-语言-select-语句"><a href="#Go-语言-select-语句" class="headerlink" title="Go 语言 select 语句"></a>Go 语言 select 语句</h2><p>select 是 Go 中的一个控制结构，类似于用于通信的 switch 语句。每个 case 必须是一个通信操作，要么是发送要么是接收。<br>select 随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。一个默认的子句应该总是可运行的。</p>
<h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><ul>
<li>每个 case 都必须是一个通信</li>
<li>所有 channel 表达式都会被求值</li>
<li>所有被发送的表达式都会被求值</li>
<li>如果任意某个通信可以进行，它就执行，其他被忽略。</li>
<li>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。 </li>
<li>若没有case可以运行：<ol>
<li>如果有 default 子句，则执行该语句。</li>
<li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</li>
</ol>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);      </span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s); </span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> c &lt;- x:</span><br><span class="line">                x, y = y, x+y</span><br><span class="line">            <span class="keyword">case</span> &lt;-quit:</span><br><span class="line">                fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">6</span>; i++ &#123;</span><br><span class="line">			fmt.Println(&lt;-c)</span><br><span class="line">		&#125;</span><br><span class="line">		quit &lt;- <span class="number">0</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	fibonacci(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果,自己品<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">8</span><br><span class="line">quit</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言运算符</title>
    <url>/posts/go-5yunsuanfu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Go-语言运算符"><a href="#Go-语言运算符" class="headerlink" title="Go 语言运算符"></a>Go 语言运算符</h1><p>运算符用于在程序运行时执行数学或逻辑运算。<br>Go 语言内置的运算符有：</p>
<ul>
<li>算术运算符(与C语言相同，不加赘述)</li>
<li>关系运算符(与C语言相同，不加赘述)</li>
<li>逻辑运算符(与C语言相同，不加赘述)</li>
<li>位运算符(与C语言相同，不加赘述)</li>
<li>赋值运算符</li>
<li>其他运算符</li>
</ul>
<p>接下来让我们来详细看看各个运算符的介绍。<br><a id="more"></a></p>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>下表列出了所有Go语言的赋值运算符。<br>| 运算符 | 描述                                           | 实例                                  |<br>| :—-: | :—————————————————————-: | :—————————————————: |<br>| =      | 简单的赋值运算符，将一个表达式的值赋给一个左值 | C = A + B 将 A + B 表达式结果赋值给 C |<br>| +=     | 相加后再赋值                                   | C += A 等于 C = C + A                 |<br>| -=     | 相减后再赋值                                   | C -= A 等于 C = C - A                 |<br>| *=     | 相乘后再赋值                                   | C *= A 等于 C = C * A                 |<br>| /=     | 相除后再赋值                                   | C /= A 等于 C = C / A                 |<br>| %=     | 求余后再赋值                                   | C %= A 等于 C = C % A                 |<br>| &lt;&lt;=    | 左移后赋值                                     | C &lt;&lt;= 2 等于 C = C &lt;&lt; 2               |<br>| &gt;&gt;=    | 右移后赋值                                     | C &gt;&gt;= 2 等于 C = C &gt;&gt; 2               |<br>| &amp;=     | 按位与后赋值                                   | C &amp;= 2 等于 C = C &amp; 2                 |<br>| ^=     | 按位异或后赋值                                 | C ^= 2 等于 C = C ^ 2                 |<br>| |=    | 按位或后赋值                                   | C |= 2 等于 C = C | 2               |</p>
<h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h2><p>下表列出了Go语言的其他运算符。<br>| 运算符 |       描述       |            实例            |<br>| :——: | :———————: | :————————————: |<br>|   &amp;    | 返回变量存储地址 | &a; 将给出变量的实际地址。 |<br>|   <em>    |    指针变量。    |     \</em>a; 是一个指针变量     |</p>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">优先级</th>
<th style="text-align:center">运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">* / % &lt;&lt; &gt;&gt; &amp; &amp;^</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">+ - \</td>
<td>^</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">== != &lt; &lt;= &gt; &gt;=</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">&amp;&amp;</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">\</td>
<td>\</td>
<td></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言常量</title>
    <url>/posts/go-4changliang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="常量的定义格式："><a href="#常量的定义格式：" class="headerlink" title="常量的定义格式："></a>常量的定义格式：</h1><h2 id="一般格式"><a href="#一般格式" class="headerlink" title="一般格式"></a>一般格式</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> identifier [<span class="keyword">type</span>] = value</span><br></pre></td></tr></table></figure>
<p>你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。</p>
<ul>
<li>显式类型定义： <code>const b string = &quot;abc&quot;</code></li>
<li>隐式类型定义： <code>const b = &quot;abc&quot;</code><a id="more"></a>
</li>
</ul>
<h2 id="多个相同类型的声明可以简写为："><a href="#多个相同类型的声明可以简写为：" class="headerlink" title="多个相同类型的声明可以简写为："></a>多个相同类型的声明可以简写为：</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> c_name1, c_name2 = value1, value2</span><br></pre></td></tr></table></figure>
<h2 id="常量还可以用作枚举："><a href="#常量还可以用作枚举：" class="headerlink" title="常量还可以用作枚举："></a>常量还可以用作枚举：</h2><p>(常量若未赋值，取值和上一个相同)<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    Unknown = <span class="number">0</span></span><br><span class="line">    Female = <span class="number">1</span></span><br><span class="line">    Male = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h1 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h1><ul>
<li>iota，特殊常量，可以认为是一个可以被编译器修改的常量。</li>
<li>iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。<br>iota 可以被用作枚举值：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b = <span class="literal">iota</span></span><br><span class="line">    c = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2<br>举例：<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        a = <span class="literal">iota</span>   <span class="comment">//0</span></span><br><span class="line">        b          <span class="comment">//1</span></span><br><span class="line">        c          <span class="comment">//2</span></span><br><span class="line">        d = <span class="string">&quot;ha&quot;</span>   <span class="comment">//独立值，iota += 1</span></span><br><span class="line">        e          <span class="comment">//&quot;ha&quot;   iota += 1</span></span><br><span class="line">        f = <span class="number">100</span>    <span class="comment">//iota +=1</span></span><br><span class="line">        g          <span class="comment">//100  iota +=1</span></span><br><span class="line">        h = <span class="literal">iota</span>   <span class="comment">//7,恢复计数</span></span><br><span class="line">        i          <span class="comment">//8</span></span><br><span class="line">    )</span><br><span class="line">    fmt.Println(a,b,c,d,e,f,g,h,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
结果为<code>0 1 2 ha ha 100 100 7 8</code></li>
</ul>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言变量</title>
    <url>/posts/go-3bianliang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Go-语言变量"><a href="#Go-语言变量" class="headerlink" title="Go 语言变量"></a>Go 语言变量</h1><h2 id="一般形式"><a href="#一般形式" class="headerlink" title="一般形式"></a>一般形式</h2><p>变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。<br>变量可以通过变量名访问。</p>
<p>Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。<br>声明变量的一般形式是使用 var 关键字：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier <span class="keyword">type</span></span><br></pre></td></tr></table></figure><br><a id="more"></a><br>可以一次声明多个变量：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> identifier1, identifier2 <span class="keyword">type</span></span><br></pre></td></tr></table></figure></p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><h3 id="第一种，指定变量类型，如果没有初始化，则变量默认为零值。"><a href="#第一种，指定变量类型，如果没有初始化，则变量默认为零值。" class="headerlink" title="第一种，指定变量类型，如果没有初始化，则变量默认为零值。"></a>第一种，指定变量类型，如果没有初始化，则变量默认为零值。</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明一个变量并初始化，零值为&quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span> = <span class="string">&quot;RUNOOB&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数值类型没有初始化就为0</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bool 零值为 false</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下几种类型零值为 nil：</span></span><br><span class="line"><span class="keyword">var</span> a *<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> a <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="keyword">var</span> a error <span class="comment">// error 是接口</span></span><br></pre></td></tr></table></figure>
<h3 id="第二种，根据值自行判定变量类型。"><a href="#第二种，根据值自行判定变量类型。" class="headerlink" title="第二种，根据值自行判定变量类型。"></a>第二种，根据值自行判定变量类型。</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v_name = value</span><br></pre></td></tr></table></figure>
<h3 id="第三种，省略-var-注意-左侧如果没有声明新的变量，就产生编译错误，格式："><a href="#第三种，省略-var-注意-左侧如果没有声明新的变量，就产生编译错误，格式：" class="headerlink" title="第三种，省略 var, 注意 := 左侧如果没有声明新的变量，就产生编译错误，格式："></a>第三种，省略 var, 注意 := 左侧如果没有声明新的变量，就产生编译错误，格式：</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v_name := value</span><br></pre></td></tr></table></figure>
<p>例<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intVal <span class="keyword">int</span> </span><br><span class="line">intVal :=<span class="number">1</span> <span class="comment">// 这时候会产生编译错误</span></span><br><span class="line">intVal,intVal1 := <span class="number">1</span>,<span class="number">2</span> <span class="comment">// 此时不会产生编译错误，因为有声明新的变量，因为 := 是一个声明语句,支持多变量声明</span></span><br></pre></td></tr></table></figure></p>
<h3 id="全局声明"><a href="#全局声明" class="headerlink" title="全局声明"></a>全局声明</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (  <span class="comment">// 这种因式分解关键字的写法一般用于声明全局变量</span></span><br><span class="line">    a <span class="keyword">int</span></span><br><span class="line">    b <span class="keyword">bool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">string</span></span><br><span class="line">a, b, c = <span class="number">5</span>, <span class="number">7</span>, <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面这行假设了变量 a，b 和 c 都已经被声明，否则的话应该这样使用：<br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a, b, c := <span class="number">5</span>, <span class="number">7</span>, <span class="string">&quot;abc&quot;</span></span><br></pre></td></tr></table></figure><br><div class="note info">
            <p>单纯地给变量赋值是不够的，这个值必须被使用</p>
          </div><br>如果你想要交换两个变量的值，则可以简单地使用<code>a, b = b, a</code>，两个变量的类型必须是相同。</p>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言基础语法</title>
    <url>/posts/go-2basic/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释不会被编译，每一个包应该有相关注释。<br>单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /<em> 开头，并以 </em>/ 结尾。如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 单行注释</span><br><span class="line">&#x2F;*</span><br><span class="line"> Author by 菜鸟教程</span><br><span class="line"> 我是多行注释</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(A~Z和a~z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。<br>以下是有效的标识符：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mahesh   kumar   abc   move_name   a_123</span><br><span class="line">myname50   _temp   j   a23b9   retVal</span><br></pre></td></tr></table></figure></p>
<h2 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h2><p>Go 语言的字符串可以通过’+’实现</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>下面列举了 Go 代码中会使用到的 25 个关键字或保留字：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">break</th>
<th style="text-align:center">default</th>
<th style="text-align:center">func</th>
<th style="text-align:center">interface</th>
<th style="text-align:center">select</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">case</td>
<td style="text-align:center">defer</td>
<td style="text-align:center">go</td>
<td style="text-align:center">map</td>
<td style="text-align:center">struct</td>
</tr>
<tr>
<td style="text-align:center">chan</td>
<td style="text-align:center">else</td>
<td style="text-align:center">goto</td>
<td style="text-align:center">package</td>
<td style="text-align:center">switch</td>
</tr>
<tr>
<td style="text-align:center">const</td>
<td style="text-align:center">fallthrough</td>
<td style="text-align:center">if</td>
<td style="text-align:center">range</td>
<td style="text-align:center">type</td>
</tr>
<tr>
<td style="text-align:center">continue</td>
<td style="text-align:center">for</td>
<td style="text-align:center">import</td>
<td style="text-align:center">return</td>
<td style="text-align:center">var</td>
</tr>
</tbody>
</table>
</div>
<p>除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>append</th>
<th>bool</th>
<th>byte</th>
<th>cap</th>
<th>close</th>
<th>complex</th>
<th>complex64</th>
<th>complex128</th>
<th>uint16</th>
</tr>
</thead>
<tbody>
<tr>
<td>copy</td>
<td>false</td>
<td>float32</td>
<td>float64</td>
<td>imag</td>
<td>int</td>
<td>int8</td>
<td>int16</td>
<td>uint32</td>
</tr>
<tr>
<td>int32</td>
<td>int64</td>
<td>iota</td>
<td>len</td>
<td>make</td>
<td>new</td>
<td>nil</td>
<td>panic</td>
<td>uint64</td>
</tr>
<tr>
<td>print</td>
<td>println</td>
<td>real</td>
<td>recover</td>
<td>string</td>
<td>true</td>
<td>uint</td>
<td>uint8</td>
<td>uintptr</td>
</tr>
</tbody>
</table>
</div>
<h2 id="Go-语言中变量的声明必须使用空格隔开，如："><a href="#Go-语言中变量的声明必须使用空格隔开，如：" class="headerlink" title="Go 语言中变量的声明必须使用空格隔开，如："></a>Go 语言中变量的声明必须使用空格隔开，如：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var age int;</span><br></pre></td></tr></table></figure>
<h2 id="Go-语言数据类型"><a href="#Go-语言数据类型" class="headerlink" title="Go 语言数据类型"></a>Go 语言数据类型</h2><p>在 Go 编程语言中，数据类型用于声明函数和变量。<br>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。<br>Go 语言按类别有以下几种数据类型：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>类型和描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>布尔型</strong> 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</td>
</tr>
<tr>
<td>2</td>
<td><strong>数字类型</strong> 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</td>
</tr>
<tr>
<td>3</td>
<td><strong>字符串类型:</strong> 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</td>
</tr>
<tr>
<td>4</td>
<td><strong>派生类型:</strong> 包括：(a) 指针类型（Pointer）(b) 数组类型(c) 结构化类型(struct)(d) Channel 类型(e) 函数类型(f) 切片类型(g) 接口类型（interface）(h) Map 类型</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言入门（环境安装）</title>
    <url>/posts/go-1intruduct/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="go语言简介"><a href="#go语言简介" class="headerlink" title="go语言简介"></a>go语言简介</h1><h2 id="Go-语言特色"><a href="#Go-语言特色" class="headerlink" title="Go 语言特色"></a>Go 语言特色</h2><ul>
<li>简洁、快速、安全</li>
<li>并行、有趣、开源</li>
<li>内存管理、数组安全、编译迅速</li>
</ul>
<h2 id="Go-语言用途"><a href="#Go-语言用途" class="headerlink" title="Go 语言用途"></a>Go 语言用途</h2><ul>
<li>Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。</li>
<li>对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。<a id="more"></a>
</li>
</ul>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="go语言环境安装"><a href="#go语言环境安装" class="headerlink" title="go语言环境安装"></a>go语言环境安装</h2><ul>
<li>访问<a href="https://golang.google.cn/dl/">go语言网站</a>，选择系统并下载</li>
<li>点击.msi文件进行安装</li>
<li>在cmd中输入 <code>go version</code> 测试环境是否安装</li>
</ul>
<h2 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h2><ul>
<li>在任意位置新建hello.go文件<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  定义了包名package, main表示一个可独立执行的程序</span></span><br><span class="line"><span class="comment">//  每个文件必须声明包</span></span><br><span class="line"><span class="comment">//  每个 Go 应用程序都包含一个名为 main 的包。</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">//  这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//  入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;   <span class="comment">//&#123; 不能在单独的行上</span></span><br><span class="line">	<span class="comment">// 打印，最后会换行</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>cmd定位到当前文件夹输入 <code>go run hello.go</code></li>
<li>输出结果为 <code>hello world</code></li>
<li><code>go build hello.go</code> 可以将代码打包成exe文件</li>
</ul>
<h2 id="VSCode插件安装"><a href="#VSCode插件安装" class="headerlink" title="VSCode插件安装"></a>VSCode插件安装</h2><h3 id="安装下图两个插件"><a href="#安装下图两个插件" class="headerlink" title="安装下图两个插件"></a>安装下图两个插件</h3><p><img src="/posts/go-1intruduct/go插件.jpg" alt="go插件"><br><img src="/posts/go-1intruduct/coderunner.jpg" alt="代码运行插件"></p>
<h3 id="编写代码，右键run-code运行"><a href="#编写代码，右键run-code运行" class="headerlink" title="编写代码，右键run code运行"></a>编写代码，右键run code运行</h3><div class="note info">
            <p>vscode需要以管理员身份运行</p>
          </div>
]]></content>
      <categories>
        <category>backend</category>
        <category>go语言</category>
      </categories>
      <tags>
        <tag>go语言</tag>
      </tags>
  </entry>
  <entry>
    <title>数据通信与网络</title>
    <url>/posts/jiwang/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="软件工程专业数据通信与网络课程笔记"><a href="#软件工程专业数据通信与网络课程笔记" class="headerlink" title="软件工程专业数据通信与网络课程笔记"></a>软件工程专业数据通信与网络课程笔记</h1><a id="more"></a>
<iframe src="http://file.panjiangtao.cn/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E4%B8%8E%E7%BD%91%E7%BB%9C.pdf" width="100%" height="1000px"></iframe>
]]></content>
      <categories>
        <category>笔记</category>
        <category>数据通信与网络</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>数据通信与网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机组成课堂笔记</title>
    <url>/posts/jizu/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="软件工程专业计算机组成课程笔记"><a href="#软件工程专业计算机组成课程笔记" class="headerlink" title="软件工程专业计算机组成课程笔记"></a>软件工程专业计算机组成课程笔记</h1><a id="more"></a>
<iframe src="http://file.panjiangtao.cn/%E8%AE%A1%E7%BB%84.pdf" width="100%" height="1000px"></iframe>]]></content>
      <categories>
        <category>笔记</category>
        <category>计算机组成</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>计算机组成</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理课堂笔记</title>
    <url>/posts/bianyi/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="软件工程专业编译原理课程笔记"><a href="#软件工程专业编译原理课程笔记" class="headerlink" title="软件工程专业编译原理课程笔记"></a>软件工程专业编译原理课程笔记</h1><a id="more"></a>
<iframe src="http://file.panjiangtao.cn/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.pdf" width="100%" height="1000px"></iframe>]]></content>
      <categories>
        <category>笔记</category>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统课堂笔记</title>
    <url>/posts/caozuoxitong/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="软件工程专业操作系统课程笔记"><a href="#软件工程专业操作系统课程笔记" class="headerlink" title="软件工程专业操作系统课程笔记"></a>软件工程专业操作系统课程笔记</h1><a id="more"></a>
<iframe src="http://file.panjiangtao.cn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.pdf" width="100%" height="1000px"></iframe>]]></content>
      <categories>
        <category>笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>软件体系结构课堂笔记</title>
    <url>/posts/ruanti/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="软件工程专业软件体系结构课程笔记"><a href="#软件工程专业软件体系结构课程笔记" class="headerlink" title="软件工程专业软件体系结构课程笔记"></a>软件工程专业软件体系结构课程笔记</h1><a id="more"></a>
<iframe src="http://file.panjiangtao.cn/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.pdf" width="100%" height="1000px"></iframe>]]></content>
      <categories>
        <category>笔记</category>
        <category>软件体系结构</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>软件体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>入门harmony鸿蒙的第一个程序</title>
    <url>/posts/harmony-start/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>视频教程链接：<a href="https://www.bilibili.com/video/BV1mv411179B">https://www.bilibili.com/video/BV1mv411179B</a></p>
</blockquote>
<h1 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>上<a href="https://developer.harmonyos.com/cn/develop/deveco-studio#download">华为鸿蒙官网</a>下载DevEco Studio开发工具</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>阅读<a href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/environment_config-0000001052902427">官方配置文档</a>进行配置，根据需要下载java，js和c/c++的SDK<br><a id="more"></a></p>
<h1 id="项目启动"><a href="#项目启动" class="headerlink" title="项目启动"></a>项目启动</h1><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><h3 id="选择应用类型和语言"><a href="#选择应用类型和语言" class="headerlink" title="选择应用类型和语言"></a>选择应用类型和语言</h3><p>我选择的是电视项目，使用java语言<br><img src="/posts/harmony-start/create.jpg" alt="选择应用类型和语言"></p>
<h3 id="选择项目名称和路径"><a href="#选择项目名称和路径" class="headerlink" title="选择项目名称和路径"></a>选择项目名称和路径</h3><p><img src="/posts/harmony-start/create2.jpg" alt="选择项目名称和路径"></p>
<h2 id="安装模拟器"><a href="#安装模拟器" class="headerlink" title="安装模拟器"></a>安装模拟器</h2><h3 id="点开hdv-manager"><a href="#点开hdv-manager" class="headerlink" title="点开hdv manager"></a>点开hdv manager</h3><p><img src="/posts/harmony-start/hvd.jpg" alt="点开hdv manager"><br><div class="note info">
            <p>千万不要用谷歌浏览器</p>
          </div></p>
<h3 id="登录华为账号"><a href="#登录华为账号" class="headerlink" title="登录华为账号"></a>登录华为账号</h3><h3 id="选择电视模拟器"><a href="#选择电视模拟器" class="headerlink" title="选择电视模拟器"></a>选择电视模拟器</h3><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>点击右上方运行箭头，选择在电视模拟器上运行，即可显示hello world<br><img src="/posts/harmony-start/hello.jpg" alt="运行结果"></p>
]]></content>
      <categories>
        <category>frontend</category>
        <category>harmony</category>
      </categories>
      <tags>
        <tag>harmony</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue框架搭建的餐厅管理系统</title>
    <url>/posts/Vue-rest/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>使用系统前务必阅读本文件！如果没有安装好环境，可以直接访问<a href="https://rest.guoshaocong.cn">餐厅管理系统</a>，功能与我们的代码是一致的。</p>
          </div>
<h2 id="餐厅管理系统"><a href="#餐厅管理系统" class="headerlink" title="餐厅管理系统"></a>餐厅管理系统</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一个餐厅管理系统，前端由Vue框架进行开发，后端使用js，和数据库一起部署在阿里云上。<br><a id="more"></a></p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol>
<li>用户正常登陆与登出</li>
<li>前台管理系统可以满足用户进行开台、买单与结账数据分析的需求</li>
<li>基础信息管理可以满足用户进行对餐品与餐桌的管理</li>
<li>服务管理部分可以满足用户进行点餐，开单，签单的需求</li>
<li>人员管理部分可以满足用户进行对顾客和员工的管理</li>
</ol>
<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>由于本系统后端部分部署在阿里云上，所以只需安装前端依赖</p>
<h3 id="安装Node-js，换源"><a href="#安装Node-js，换源" class="headerlink" title="安装Node.js，换源"></a>安装Node.js，换源</h3><ul>
<li>打开<a href="https://nodejs.org/en/">Node.js官网</a>，选择LTS版本下载（目前为12.16.1），并进行安装。</li>
<li>使用淘宝源：<code>npm config set registry https://registry.npm.taobao.org</code></li>
<li>验证换源是否成功：<code>npm config get registry</code></li>
</ul>
<h3 id="安装vue-cli"><a href="#安装vue-cli" class="headerlink" title="安装vue-cli"></a>安装vue-cli</h3><ul>
<li>安装：<code>npm install -g @vue/cli</code></li>
<li>验证：<code>vue --version</code></li>
</ul>
<h3 id="下载项目源码"><a href="#下载项目源码" class="headerlink" title="下载项目源码"></a>下载项目源码</h3><ul>
<li>使用git下载<br><code>git clone https://github.com/MofasJang/restaurant</code></li>
<li>访问<a href="https://github.com/MofasJang/restaurant">github仓库</a>下载</li>
</ul>
<h3 id="安装项目所需依赖"><a href="#安装项目所需依赖" class="headerlink" title="安装项目所需依赖"></a>安装项目所需依赖</h3><ul>
<li>确保终端位于frontend目录内</li>
<li><code>npm install</code>来按照package.json安装所有所需依赖</li>
</ul>
<h3 id="进行本地测试"><a href="#进行本地测试" class="headerlink" title="进行本地测试"></a>进行本地测试</h3><ul>
<li>运行开发服务器：<code>npm run serve</code></li>
<li>访问终端中显示的地址 <code>http://localhost:8080/</code> ，应该能看到前端页面。</li>
</ul>
<h2 id="为了方便于登陆，默认账号密码可以回车录入，点击登陆，就可以使用本系统了！"><a href="#为了方便于登陆，默认账号密码可以回车录入，点击登陆，就可以使用本系统了！" class="headerlink" title="为了方便于登陆，默认账号密码可以回车录入，点击登陆，就可以使用本系统了！"></a>为了方便于登陆，默认账号密码可以回车录入，点击登陆，就可以使用本系统了！</h2>]]></content>
      <categories>
        <category>frontend</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>晨午晚检自动填报工具</title>
    <url>/posts/chenwujian/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><div class="note info">
            <p>搬运自HPShark的<a href="https://github.com/HPShark/xdu_chenwuwanjian">github仓库</a></p>
          </div>
<h1 id="晨午晚检自动填报工具"><a href="#晨午晚检自动填报工具" class="headerlink" title="晨午晚检自动填报工具"></a>晨午晚检自动填报工具</h1><h4 id="本项目仅供学习交流使用，如作他用所承受的任何直接、间接法律责任一概与作者和搬运者无关"><a href="#本项目仅供学习交流使用，如作他用所承受的任何直接、间接法律责任一概与作者和搬运者无关" class="headerlink" title="本项目仅供学习交流使用，如作他用所承受的任何直接、间接法律责任一概与作者和搬运者无关"></a>本项目仅供学习交流使用，如作他用所承受的任何直接、间接法律责任一概与作者和搬运者无关</h4><h4 id="如果此项目侵犯了您或者您公司的权益，请立即联系我删除"><a href="#如果此项目侵犯了您或者您公司的权益，请立即联系我删除" class="headerlink" title="如果此项目侵犯了您或者您公司的权益，请立即联系我删除"></a>如果此项目侵犯了您或者您公司的权益，请立即联系我删除</h4><a id="more"></a>
<h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>本脚本只内置了南校区的经纬度,<strong>只适用于南校区在校的同学</strong></p>
<h1 id="项目说明"><a href="#项目说明" class="headerlink" title="项目说明"></a>项目说明</h1><ul>
<li><code>data</code> 需要提交给网站的信息</li>
<li><code>AccountInfo.ini</code> 登录的配置文件，用来保存帐号密码以及收发邮箱信息和邮箱key（只支持QQ邮箱）</li>
<li><code>index.py</code> 完成自动提交的py脚本</li>
<li><code>utils</code> 帮助生成默认项配置的py脚本</li>
<li><code>requirements.txt</code> py依赖库以及版本说明文件</li>
<li><code>层文件.zip</code> 打包好的云函数依赖库文件</li>
</ul>
<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><h3 id="配合腾讯云函数使用（免费）"><a href="#配合腾讯云函数使用（免费）" class="headerlink" title="配合腾讯云函数使用（免费）"></a>配合腾讯云函数使用（免费）</h3><ol>
<li><p>clone 或者 下载 此仓库到本地</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;HPShark&#x2F;xdu_chenwuwanjian.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>打开本地仓库文件夹，配置<code>AccountInfo.ini</code>中对应的信息，<strong>注意这里的学号和密码都是教务系统的学号和密码，key是邮箱的密码</strong></p>
</li>
<li><p>打开百度搜索<a href="https://console.cloud.tencent.com/scf/index?rid=1">腾讯云函数</a>，注册认证后，进入控制台，点击左边的层，然后点新建，名称随意，然后点击上传zip，选择项目中的<code>层文件.zip</code>上传，然后选择运行环境<code>python3.6</code>，然后点击确定，耐心等待一下，上传依赖包需要花费的时间比较长 <a href="ceng.jpg">新建腾讯云函数依赖</a></p>
</li>
<li><p>点左边的函数服务，新建云函数，名称随意，运行环境选择<code>python3.6</code>，创建方式选择空白函数，然后点击下一步 <img src="/posts/chenwujian/hanshu.jpg" alt="新建腾讯云函数"></p>
</li>
<li><p>提交方法选择上传本地压缩包，把本地的/data，/utils，AccountInfo.ini，index.py，requirements.txt五个文件和文件夹打包上传，在点击下面的高级设置，设置内存为256M，超时时间为<code>30秒</code>，添加层为刚刚新建的函数依赖层，环境变量设置一个<code>TZ=Asia/Shanghai</code>，然后点击完成<img src="/posts/chenwujian/gaoji.jpg" alt="高级设置"></p>
</li>
<li><p>进入新建好的云函数，左边点击触发管理，点击创建触发器，名称随意，触发周期选择自定义，然后配置cron表达式。下面的表达式表示每天中午十二点整执行，可配置多个时间以便早中晚自动运行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 0 12 * * * *</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后就可以测试云函数了，绿色代表云函数执行成功，红色代表云函数执行失败（失败的原因大部分是由于依赖造成的）。返回结果是<code>auto submit fail.</code>代表自动提交失败；返回结果是<code>auto submit success.</code>，代表自动提交成功，如遇到问题，请仔细查看日志</p>
</li>
<li><p>也可配合Windows计划任务或者使用linux定时任务，将脚本挂在自己的云服务器上，不会就搜索一下，过程不再赘述</p>
</li>
</ol>
<h4 id><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
      <categories>
        <category>生活</category>
        <category>搬运</category>
      </categories>
      <tags>
        <tag>XDU</tag>
        <tag>自动工具</tag>
      </tags>
  </entry>
  <entry>
    <title>测试一下</title>
    <url>/posts/test/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="tab选项卡"><a href="#tab选项卡" class="headerlink" title="tab选项卡"></a>tab选项卡</h2><div class="tabs" id="tab"><ul class="nav-tabs"><li class="tab"><a href="#tab-1">tab 1</a></li><li class="tab active"><a href="#tab-2">tab 2</a></li><li class="tab"><a href="#tab-3">tab 3</a></li></ul><div class="tab-content"><div class="tab-pane" id="tab-1"><p>this is tab1</p></div><div class="tab-pane active" id="tab-2"><p>this is tab2</p></div><div class="tab-pane" id="tab-3"><p>this is tab3</p></div></div></div>
<h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2>
        <div id="aplayer-NbbvLTzF" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">
            <pre class="aplayer-lrc-content">[ti:Something Just Like This]
[ar:The Chainsmokers/Coldplay]
[al:Something Just Like This]
[by:]
[offset:0]
[00:00.73]Something Just Like This (美国篮球联赛宣传片主题曲|第60届格莱美最佳流行对唱/组合提名歌曲) - The Chainsmokers/Coldplay
[00:02.13]Written by：Andrew Taggart/Christopher Martin/Guy Berryman/Jonny Buckland/Will Champion
[00:03.78]
[00:08.16]I've been reading books of old
[00:10.44]The legends and the myths
[00:12.79]Achilles and his gold
[00:15.10]Hercules and his gifts
[00:17.60]Spiderman's control
[00:19.88]And Batman with his fists
[00:22.20]
[00:22.82]And clearly I don't see myself upon that list
[00:26.46]She said where'd you wanna go
[00:28.98]How much you wanna risk
[00:31.25]I'm not looking for somebody
[00:33.41]With some Superhuman gifts
[00:36.08]Some Superhero
[00:37.78]
[00:38.39]Some fairytale bliss
[00:40.83]Just something I can turn to
[00:43.05]Somebody I can kiss
[00:45.12]I want something just like this
[00:47.69]Doo doo doo doo doo doo
[00:49.27]
[00:50.00]Doo doo doo doo doo
[00:51.59]
[00:52.40]Doo doo doo doo doo doo
[00:54.25]Oh I want something just like this
[00:56.99]Doo doo doo doo doo doo
[00:58.79]
[00:59.49]Doo doo doo doo doo
[01:01.16]
[01:01.69]Doo doo doo doo doo doo
[01:03.60]Oh I want something just like this
[01:06.31]
[01:13.20]I want something just like this
[01:15.78]
[01:22.85]I've been reading books of old
[01:24.52]
[01:25.03]The legends and the myths
[01:27.34]The testaments they told
[01:29.69]The moon and its eclipse
[01:32.04]And Superman unrolls
[01:34.38]A suit before he lifts
[01:36.64]
[01:37.69]But I'm not the kind of person that it fits
[01:40.92]She said where'd you wanna go
[01:43.75]How much you wanna risk
[01:45.79]I'm not looking for somebody
[01:48.04]With some Superhuman gifts
[01:50.57]Some Superhero
[01:52.28]
[01:52.93]Some fairytale bliss
[01:55.29]Just something I can turn to
[01:57.61]Somebody I can miss
[01:59.70]I want something just like this
[02:02.18]
[02:09.11]I want something just like this
[02:11.58]
[02:18.16]Oh I want something just like this
[02:21.18]Doo doo doo doo doo doo
[02:22.56]
[02:23.28]Doo doo doo doo doo
[02:24.85]
[02:25.53]Doo doo doo doo doo doo
[02:27.63]Oh I want something just like this
[02:30.23]Doo doo doo doo doo doo
[02:32.06]
[02:32.70]Doo doo doo doo doo
[02:34.87]Doo doo doo doo doo doo
[02:36.71]
[02:37.69]Where'd you wanna go
[02:39.62]How much you wanna risk
[02:41.59]I'm not looking for somebody
[02:44.00]With some Superhuman gifts
[02:46.59]Some Superhero
[02:48.68]Some fairytale bliss
[02:51.24]Just something I can turn to
[02:53.51]Somebody I can kiss
[02:55.59]I want something just like this
[02:58.18]
[03:14.04]Oh I want something just like this
[03:16.80]
[03:32.78]Oh I want something just like this
[03:35.50]
[03:51.44]Oh I want something just like this</pre>
        </div>
        <script>
          var ap = new APlayer({
            element: document.getElementById("aplayer-NbbvLTzF"),
            narrow: false,
            autoplay: false,
            showlrc: 2,
            music: {
              title: "SomethingJustLikeThis",
              author: "The Chainsmokers/Coldplay",
              url: "http://file.panjiangtao.cn/SomethingJustLikeThis.mp3",
              pic: "/posts/test/SomethingJustLikeThis.jpg",
              lrc: "SomethingJustLikeThis.txt"
            }
          });
          window.aplayers || (window.aplayers = []);
          window.aplayers.push(ap);
        </script>
<h2 id="b站外链"><a href="#b站外链" class="headerlink" title="b站外链"></a>b站外链</h2><p><a href="https://xbeibeix.com/api/bilibili/biliplayer/?url=">https://xbeibeix.com/api/bilibili/biliplayer/?url=</a></p>
<h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><center><a class="btn" href="#" title="Title">
            <i class="fa fa-home fa-fw fa-lg"></i>按一下
          </a></center>

<a id="more"></a>
<h2 id="便签"><a href="#便签" class="headerlink" title="便签"></a>便签</h2><div class="note info">
            <p>default,primary,success,info,warning,danger</p>
          </div>
<h2 id="pdf"><a href="#pdf" class="headerlink" title="pdf"></a>pdf</h2><iframe src="http://file.panjiangtao.cn/jianli.pdf" width="100%" height="800px"></iframe>


<h2 id="iframe插件"><a href="#iframe插件" class="headerlink" title="iframe插件"></a>iframe插件</h2><figure class="highlight md"><table><tr><td class="code"><pre><span class="line">&#123;% iframe url [width] [height] %&#125;</span><br></pre></td></tr></table></figure>
<iframe height="500" width="100%" src="http://file.panjiangtao.cn/gouge.mp4" frameborder="0" allowfullscreen>
</iframe>

]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>Socket多人聊天室</title>
    <url>/posts/Socket-chatroom/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote>
<p>作者：潘江涛<br><a href="https://github.com/MofasJang/Socket-chatroom">项目源码</a></p>
</blockquote>
<h3 id="一-项目简介"><a href="#一-项目简介" class="headerlink" title="一. 项目简介"></a>一. 项目简介</h3><p>　　使用java作为开发语言开发一款基于socket技术的多人聊天应用，该程序由服务端和客户端两个界面组成，其中客户端由聊天用户使用，发送聊天消息并接受服务端和其他客户端的消息；服务端由管理员使用，接受客户端的socket连接，转发各客户端发送的消息，也能够向客户端发送消息，并将所有消息存入数据库中，在界面上实时更新聊天记录。</p>
<a id="more"></a>
<h3 id="二-项目技术栈"><a href="#二-项目技术栈" class="headerlink" title="二. 项目技术栈"></a>二. 项目技术栈</h3><h4 id="1-java中Socket的使用"><a href="#1-java中Socket的使用" class="headerlink" title="1. java中Socket的使用"></a>1. java中Socket的使用</h4><h4 id="2-多线程接口Runnable的使用"><a href="#2-多线程接口Runnable的使用" class="headerlink" title="2. 多线程接口Runnable的使用"></a>2. 多线程接口Runnable的使用</h4><h4 id="3-SQL语言及JDBC的使用"><a href="#3-SQL语言及JDBC的使用" class="headerlink" title="3. SQL语言及JDBC的使用"></a>3. SQL语言及JDBC的使用</h4><h4 id="4-swing窗体程序的建立"><a href="#4-swing窗体程序的建立" class="headerlink" title="4. swing窗体程序的建立"></a>4. swing窗体程序的建立</h4><h3 id="三-项目参考资料"><a href="#三-项目参考资料" class="headerlink" title="三. 项目参考资料"></a>三. 项目参考资料</h3><h4 id="1-java中的Socket的使用"><a href="#1-java中的Socket的使用" class="headerlink" title="1. java中的Socket的使用"></a>1. <a href="https://blog.csdn.net/a78270528/article/details/80318571">java中的Socket的使用</a></h4><h4 id="2-java-多线程之-implements-Runnable"><a href="#2-java-多线程之-implements-Runnable" class="headerlink" title="2. java 多线程之 implements Runnable"></a>2. <a href="https://blog.csdn.net/qq_38428623/article/details/85868358">java 多线程之 implements Runnable</a></h4><h4 id="3-使用JAVA编程实现多人聊天室"><a href="#3-使用JAVA编程实现多人聊天室" class="headerlink" title="3. 使用JAVA编程实现多人聊天室"></a>3. <a href="https://blog.csdn.net/qq_29606255/article/details/78679815">使用JAVA编程实现多人聊天室</a></h4><h4 id="4-Eclipse搭建Java-Swing可视化开发环境"><a href="#4-Eclipse搭建Java-Swing可视化开发环境" class="headerlink" title="4. Eclipse搭建Java Swing可视化开发环境"></a>4. <a href="https://blog.csdn.net/renwudao24/article/details/51864323">Eclipse搭建Java Swing可视化开发环境</a></h4><h4 id="5-Java-MySQL-连接"><a href="#5-Java-MySQL-连接" class="headerlink" title="5. Java MySQL 连接"></a>5. <a href="https://www.runoob.com/java/java-mysql-connect.html">Java MySQL 连接</a></h4><h3 id="四-项目文件结构"><a href="#四-项目文件结构" class="headerlink" title="四. 项目文件结构"></a>四. 项目文件结构</h3><h4 id="socketchat-package"><a href="#socketchat-package" class="headerlink" title="* socketchat                  (package)"></a>* socketchat                  (package)</h4><ul>
<li>client.java            (客户端的socket连接，消息接收和发送)</li>
<li>clientapp.java     (客户端界面，显示其他客户端和服务端的消息)</li>
<li>server.java          (服务端的连接客户端socket，消息接收和转发)</li>
<li>serverapp.java    (服务端界面，显示所有客户端的消息和所有聊天记录)</li>
<li>sqltext.java          (连接数据库，存入和读取聊天记录)</li>
</ul>
<h3 id="五-项目代码描述"><a href="#五-项目代码描述" class="headerlink" title="五. 项目代码描述"></a>五. 项目代码描述</h3><h4 id="1-server-java-服务器转发线程"><a href="#1-server-java-服务器转发线程" class="headerlink" title="1. server.java 服务器转发线程"></a>1. server.java 服务器转发线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">server</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="comment">// 服务端</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;Socket&gt; socketList=<span class="keyword">new</span> ArrayList&lt;Socket&gt;(); <span class="comment">//多个socket实现多人聊天</span></span><br><span class="line">    <span class="keyword">static</span> Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> JTextArea textArea1=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">static</span> String buffer=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">server</span><span class="params">()</span> </span>&#123;  <span class="comment">// 构造方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	serverapp.WinMain();</span><br><span class="line"><span class="comment">//        Scanner input = new Scanner(System.in);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;************服务端*************&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">			sqltest.insert(<span class="string">&quot;服务器&quot;</span>,<span class="string">&quot;已上线&quot;</span>);</span><br><span class="line">			textArea1.append(<span class="string">&quot;*********************服务端*********************\n&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">        server t = <span class="keyword">new</span> server();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;   <span class="comment">//循环等待客户端连接       </span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                count++;</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span> + count + <span class="string">&quot;个客户已连接&quot;</span>);</span><br><span class="line">                textArea1.append(<span class="string">&quot;第&quot;</span> + count + <span class="string">&quot;个客户已连接\n&quot;</span>);</span><br><span class="line">                socketList.add(socket);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//开启转发线程和发消息线程</span></span><br><span class="line">            Print p = <span class="keyword">new</span> Print(socket);</span><br><span class="line">            Thread read = <span class="keyword">new</span> Thread(t);</span><br><span class="line">            Thread print = <span class="keyword">new</span> Thread(p);</span><br><span class="line">            read.start();</span><br><span class="line">            print.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setwin</span><span class="params">(JTextArea area1)</span> </span>&#123;<span class="comment">//将服务器界面的消息打印框赋值到server类中</span></span><br><span class="line">    	textArea1=area1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;		<span class="comment">// 重写run方法</span></span><br><span class="line">    	Socket current = <span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket</span><br><span class="line">                    .getInputStream()));</span><br><span class="line">            current=socket;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//将接收的字符串保存到数据库中</span></span><br><span class="line">                String jieshou = in.readLine();</span><br><span class="line">                System.out.println(jieshou);</span><br><span class="line">                textArea1.append(jieshou+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                String[] neirong=jieshou.split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                String buf1=neirong[<span class="number">0</span>],buf2;;</span><br><span class="line">                <span class="keyword">if</span>(neirong.length==<span class="number">1</span>) &#123; 	</span><br><span class="line">                	buf2=<span class="string">&quot; &quot;</span>;&#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                	buf2=neirong[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                sqltest.insert(buf1, buf2);</span><br><span class="line">                <span class="comment">//将消息转发给所有用户</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; socketList.size(); i++) &#123;</span><br><span class="line">                    Socket socket=socketList.get(i);</span><br><span class="line">                    PrintWriter out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">                    <span class="keyword">if</span> (socket!=current) &#123;</span><br><span class="line">                        out.println(jieshou);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        out.println(<span class="string">&quot;(你)&quot;</span>+jieshou);</span><br><span class="line">                    &#125;</span><br><span class="line">                    out.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        	socketList.remove(current);</span><br><span class="line">        	Print.socketList.remove(current);</span><br><span class="line">    		textArea1.append(<span class="string">&quot;用户已下线&quot;</span>+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-server-java-服务器发送消息线程"><a href="#2-server-java-服务器发送消息线程" class="headerlink" title="2. server.java 服务器发送消息线程"></a>2. server.java 服务器发送消息线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Print</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;Socket&gt; socketList=<span class="keyword">new</span> ArrayList&lt;Socket&gt;();</span><br><span class="line">    Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Print</span><span class="params">(Socket s)</span> </span>&#123;<span class="comment">// 构造方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketList.add(s);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            	<span class="keyword">while</span>(server.buffer==<span class="string">&quot;&quot;</span>) &#123;  <span class="comment">//如没有消息需要发送，则循环等待</span></span><br><span class="line">            		<span class="keyword">try</span> &#123;</span><br><span class="line">        				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">        				e.printStackTrace();</span><br><span class="line">        			&#125;</span><br><span class="line">            	&#125;</span><br><span class="line">            	String msg = server.buffer.replaceAll(<span class="string">&quot;(\r\n|\r|\n|\n\r)&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            	System.out.println(<span class="string">&quot;客户端数量：&quot;</span>+socketList.size());</span><br><span class="line">                <span class="comment">//向所有客户端发送服务器消息</span></span><br><span class="line">	            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; socketList.size(); i++) &#123;</span><br><span class="line">	                Socket socket=socketList.get(i);</span><br><span class="line">	                PrintWriter out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">	                out.println(<span class="string">&quot;服务器：&quot;</span>+msg);</span><br><span class="line">	                out.flush();</span><br><span class="line">	            &#125;</span><br><span class="line">	            System.out.println(<span class="string">&quot;服务器：&quot;</span>+msg);</span><br><span class="line">                server.textArea1.append(<span class="string">&quot;服务器：&quot;</span>+msg+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                sqltest.insert(<span class="string">&quot;服务器&quot;</span>, msg);</span><br><span class="line">	            server.buffer=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-client-java-客户端连接socket、发送消息线程"><a href="#3-client-java-客户端连接socket、发送消息线程" class="headerlink" title="3. client.java 客户端连接socket、发送消息线程"></a>3. client.java 客户端连接socket、发送消息线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">client</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;<span class="comment">// 客户端</span></span><br><span class="line">    <span class="keyword">static</span> Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">static</span> String name=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">static</span> JTextArea textArea=<span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> String buffer=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	clientapp.WinMain();</span><br><span class="line">    	<span class="keyword">while</span>(buffer==<span class="string">&quot;&quot;</span>) &#123; <span class="comment">//等待客户输入名字</span></span><br><span class="line">    		<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    	name=buffer.replaceAll(<span class="string">&quot;(\r\n|\r|\n|\n\r)&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    	System.out.println(<span class="string">&quot;************客户端:&quot;</span>+client.name+<span class="string">&quot;*************&quot;</span>);</span><br><span class="line">    	textArea.append(<span class="string">&quot;**************************客户端:&quot;</span>+client.name+<span class="string">&quot;***************************\n&quot;</span>);</span><br><span class="line">    	buffer=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;<span class="comment">//连接服务器socket</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">            PrintWriter out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">            out.println(name+<span class="string">&quot;:我已上线&quot;</span>);</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开启发送、接收消息线程</span></span><br><span class="line">        client t = <span class="keyword">new</span> client();</span><br><span class="line">        Read r = <span class="keyword">new</span> Read(socket);</span><br><span class="line">        Thread print = <span class="keyword">new</span> Thread(t);</span><br><span class="line">        Thread read = <span class="keyword">new</span> Thread(r);</span><br><span class="line">        print.start();</span><br><span class="line">        read.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setwin</span><span class="params">(JTextArea a1)</span> </span>&#123;<span class="comment">//将客户端界面的消息打印框赋值到client类中</span></span><br><span class="line">    	textArea=a1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    	PrintWriter out = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);         </span><br><span class="line">            out = <span class="keyword">new</span> PrintWriter(socket.getOutputStream());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;<span class="comment">//等待用户输入消息</span></span><br><span class="line">            	<span class="keyword">while</span>(buffer==<span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            		<span class="keyword">try</span> &#123;</span><br><span class="line">        				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">        				e.printStackTrace();</span><br><span class="line">        			&#125;</span><br><span class="line">            	&#125;</span><br><span class="line">                <span class="comment">//发送消息</span></span><br><span class="line">        		String msg = buffer.replaceAll(<span class="string">&quot;(\r\n|\r|\n|\n\r)&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        		out.println(name+<span class="string">&quot;:&quot;</span>+msg);</span><br><span class="line">        		out.flush();</span><br><span class="line">        		buffer=<span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;<span class="comment">//用户下线，向服务器发送下线消息，关闭socket</span></span><br><span class="line">            	out.println(name+<span class="string">&quot;:已下线&quot;</span>);</span><br><span class="line">        		out.flush();</span><br><span class="line">        		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-client-java-客户端接收消息线程"><a href="#4-client-java-客户端接收消息线程" class="headerlink" title="4. client.java 客户端接收消息线程"></a>4. client.java 客户端接收消息线程</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Read</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Read</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(socket</span><br><span class="line">                    .getInputStream()));</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;	<span class="comment">//接收到消息，打印在界面上</span></span><br><span class="line">            	String text=in.readLine() ;</span><br><span class="line">            	client.textArea.append(text+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            	System.out.println(text);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-sqltext-java-连接数据库"><a href="#5-sqltext-java-连接数据库" class="headerlink" title="5. sqltext.java 连接数据库"></a>5. sqltext.java 连接数据库</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">sqltest</span> </span>&#123;  <span class="comment">//连接数据库</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">&quot;jdbc:mysql://localhost:3306/chatroom?useUnicode=true&amp;characterEncoding=UTF-8&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">    <span class="keyword">static</span> JTextArea textArea=<span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String buf1,String buf2)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        SimpleDateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<span class="comment">//设置日期格式</span></span><br><span class="line">        String curtime=df.format(<span class="keyword">new</span> Date());<span class="comment">// new Date()为获取当前系统时间</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">// 注册 JDBC 驱动</span></span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 打开链接</span></span><br><span class="line">            conn = DriverManager.getConnection(DB_URL,USER,PASS);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行查询</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            String sql1;</span><br><span class="line">            <span class="comment">//将聊天人的名字、聊天内容和时间记入数据库</span></span><br><span class="line">            sql1 = <span class="string">&quot;insert into record (name,buf,time) values (\&#x27;&quot;</span>+buf1+<span class="string">&quot;\&#x27;, \&#x27;&quot;</span>+buf2+<span class="string">&quot;\&#x27;,\&#x27;&quot;</span>+curtime+<span class="string">&quot;\&#x27;)&quot;</span>;</span><br><span class="line">            stmt.executeUpdate(sql1);</span><br><span class="line">            String sql2;</span><br><span class="line">            <span class="comment">//查询数据库中所有聊天记录</span></span><br><span class="line">            sql2 = <span class="string">&quot;SELECT id,name, buf,time FROM record&quot;</span>;</span><br><span class="line">            ResultSet rs = stmt.executeQuery(sql2);</span><br><span class="line">            textArea.setText(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 展开结果集数据库</span></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                <span class="comment">// 通过字段检索</span></span><br><span class="line">                String name  = rs.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                String buf = rs.getString(<span class="string">&quot;buf&quot;</span>);</span><br><span class="line">                String time = rs.getString(<span class="string">&quot;time&quot;</span>);</span><br><span class="line">                </span><br><span class="line">                textArea.append(time+<span class="string">&quot;\n&quot;</span>+name+<span class="string">&quot; : &quot;</span>+buf+<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 完成后关闭</span></span><br><span class="line">            rs.close();</span><br><span class="line">            stmt.close();</span><br><span class="line">            conn.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">            <span class="comment">// 处理 JDBC 错误</span></span><br><span class="line">            se.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            <span class="comment">// 处理 Class.forName 错误</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">// 关闭资源</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stmt!=<span class="keyword">null</span>) stmt.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se2)&#123;</span><br><span class="line">            &#125;<span class="comment">// 什么都不做</span></span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(conn!=<span class="keyword">null</span>) conn.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span>(SQLException se)&#123;</span><br><span class="line">                se.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setwin</span><span class="params">(JTextArea area)</span> </span>&#123;</span><br><span class="line">    	textArea=area;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-serverapp-java-clientapp-java-客户端和服务器界面主要由AWT-SWING可视化插件生成界面代码"><a href="#6-serverapp-java-clientapp-java-客户端和服务器界面主要由AWT-SWING可视化插件生成界面代码" class="headerlink" title="6. serverapp.java , clientapp.java 客户端和服务器界面主要由AWT/SWING可视化插件生成界面代码"></a>6. serverapp.java , clientapp.java 客户端和服务器界面主要由AWT/SWING可视化插件生成界面代码</h4><h3 id="六-项目成果截图"><a href="#六-项目成果截图" class="headerlink" title="六. 项目成果截图"></a>六. 项目成果截图</h3><h4 id="1-服务器初始化，调出所有聊天记录"><a href="#1-服务器初始化，调出所有聊天记录" class="headerlink" title="1. 服务器初始化，调出所有聊天记录"></a>1. 服务器初始化，调出所有聊天记录</h4><p><img src="/posts/Socket-chatroom/服务端初始.jpg" alt></p>
<h4 id="2-客户端初始化，需要输入名字"><a href="#2-客户端初始化，需要输入名字" class="headerlink" title="2. 客户端初始化，需要输入名字"></a>2. 客户端初始化，需要输入名字</h4><p><img src="/posts/Socket-chatroom/客户端初始.jpg" alt></p>
<h4 id="3-客户上线"><a href="#3-客户上线" class="headerlink" title="3. 客户上线"></a>3. 客户上线</h4><p><img src="/posts/Socket-chatroom/客户上线.jpg" alt></p>
<h4 id="4-客户和服务器分别发送消息"><a href="#4-客户和服务器分别发送消息" class="headerlink" title="4. 客户和服务器分别发送消息"></a>4. 客户和服务器分别发送消息</h4><p><img src="/posts/Socket-chatroom/发送消息.jpg" alt></p>
<h4 id="5-客户端下线"><a href="#5-客户端下线" class="headerlink" title="5. 客户端下线"></a>5. 客户端下线</h4><p><img src="/posts/Socket-chatroom/客户端下线.jpg" alt></p>
]]></content>
      <categories>
        <category>backend</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<a id="more"></a>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
